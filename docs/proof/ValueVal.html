<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.16: http://docutils.sourceforge.net/" />
<title>ValueVal.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
</head>
<body>
<div class="alectryon-root alectryon-floating"><div class="document">


<pre class="alectryon-io"><!-- Generator: Alectryon v1.0 --><span class="coq-wsp"><span class="highlight"><span class="c">(*</span>
<span class="c"> * Vericert: Verified high-level synthesis.</span>
<span class="c"> * Copyright (C) 2020 Yann Herklotz &lt;yann@yannherklotz.com&gt;</span>
<span class="c"> *</span>
<span class="c"> * This program is free software: you can redistribute it and/or modify</span>
<span class="c"> * it under the terms of the GNU General Public License as published by</span>
<span class="c"> * the Free Software Foundation, either version 3 of the License, or</span>
<span class="c"> * (at your option) any later version.</span>
<span class="c"> *</span>
<span class="c"> * This program is distributed in the hope that it will be useful,</span>
<span class="c"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"> * GNU General Public License for more details.</span>
<span class="c"> *</span>
<span class="c"> * You should have received a copy of the GNU General Public License</span>
<span class="c"> * along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>
<span class="c"> *)</span>

<span class="c">(* begin hide *)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> Coq <span class="kn">Require Import</span> ZArith.ZArith FSets.FMapPositive Lia.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> compcert <span class="kn">Require Export</span> lib.Integers common.Values.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> vericert <span class="kn">Require Import</span> Vericertlib.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight"><span class="c">(* end hide *)</span>

<span class="sd">(** * Value</span>

<span class="sd">A [value] is a bitvector with a specific size. We are using the implementation</span>
<span class="sd">of the bitvector by mit-plv/bbv, because it has many theorems that we can reuse.</span>
<span class="sd">However, we need to wrap it with an [Inductive] so that we can specify and match</span>
<span class="sd">on the size of the [value]. This is necessary so that we can easily store</span>
<span class="sd">[value]s of different sizes in a list or in a map.</span>

<span class="sd">Using the default [word], this would not be possible, as the size is part of the type. *)</span>

<span class="c">(* Definition value : Type := val.</span>

<span class="c">(** ** Value conversions</span>

<span class="c">Various conversions to different number types such as [N], [Z], [positive] and</span>
<span class="c">[int], where the last one is a theory of integers of powers of 2 in CompCert. *)</span>

<span class="c">Definition valueToNat (v : value) : nat :=</span>
<span class="c">  match v with</span>
<span class="c">  | value_bool b =&gt; Nat.b2n b</span>
<span class="c">  | value_int i =&gt; Z.to_nat (Int.unsigned i)</span>
<span class="c">  | value_int64 i =&gt; Z.to_nat (Int64.unsigned i)</span>
<span class="c">  end.</span>

<span class="c">Definition natToValue (n : nat) : value :=</span>
<span class="c">  value_int (Int.repr (Z.of_nat n)).</span>

<span class="c">Definition natToValue64 (n : nat) : value :=</span>
<span class="c">  value_int64 (Int64.repr (Z.of_nat n)).</span>

<span class="c">Definition valueToN (v : value) : N :=</span>
<span class="c">  match v with</span>
<span class="c">  | value_bool b =&gt; N.b2n b</span>
<span class="c">  | value_int i =&gt; Z.to_N (Int.unsigned i)</span>
<span class="c">  | value_int64 i =&gt; Z.to_N (Int64.unsigned i)</span>
<span class="c">  end.</span>

<span class="c">Definition NToValue (n : N) : value :=</span>
<span class="c">  value_int (Int.repr (Z.of_N n)).</span>

<span class="c">Definition NToValue64 (n : N) : value :=</span>
<span class="c">  value_int64 (Int64.repr (Z.of_N n)).</span>

<span class="c">Definition ZToValue (z : Z) : value :=</span>
<span class="c">  value_int (Int.repr z).</span>

<span class="c">Definition ZToValue64 (z : Z) : value :=</span>
<span class="c">  value_int64 (Int64.repr z).</span>

<span class="c">Definition valueToZ (v : value) : Z :=</span>
<span class="c">  match v with</span>
<span class="c">  | value_bool b =&gt; Z.b2z b</span>
<span class="c">  | value_int i =&gt; Int.signed i</span>
<span class="c">  | value_int64 i =&gt; Int64.signed i</span>
<span class="c">  end.</span>

<span class="c">Definition uvalueToZ (v : value) : Z :=</span>
<span class="c">  match v with</span>
<span class="c">  | value_bool b =&gt; Z.b2z b</span>
<span class="c">  | value_int i =&gt; Int.unsigned i</span>
<span class="c">  | value_int64 i =&gt; Int64.unsigned i</span>
<span class="c">  end.</span>

<span class="c">Definition posToValue (p : positive) : value :=</span>
<span class="c">  value_int (Int.repr (Z.pos p)).</span>

<span class="c">Definition posToValue64 (p : positive) : value :=</span>
<span class="c">  value_int64 (Int64.repr (Z.pos p)).</span>

<span class="c">Definition valueToPos (v : value) : positive :=</span>
<span class="c">  match v with</span>
<span class="c">  | value_bool b =&gt; 1%positive</span>
<span class="c">  | value_int i =&gt; Z.to_pos (Int.unsigned i)</span>
<span class="c">  | value_int64 i =&gt; Z.to_pos (Int64.unsigned i)</span>
<span class="c">  end.</span>

<span class="c">Definition intToValue (i : Integers.int) : value := value_int i.</span>

<span class="c">Definition int64ToValue (i : Integers.int64) : value := value_int64 i.</span>

<span class="c">Definition valueToInt (v : value) : Integers.int :=</span>
<span class="c">  match v with</span>
<span class="c">  | value_bool b =&gt; Int.repr (if b then 1 else 0)</span>
<span class="c">  | value_int i =&gt; i</span>
<span class="c">  | value_int64 i =&gt; Int.repr (Int64.unsigned i)</span>
<span class="c">  end.</span>

<span class="c">(*Definition ptrToValue (i : ptrofs) : value :=</span>
<span class="c">  value_int (Ptrofs.to_int i).</span>

<span class="c">Definition valueToPtr (i : value) : Integers.ptrofs :=</span>
<span class="c">  Ptrofs.of_int i.</span>

<span class="c">Definition valToValue (v : Values.val) : option value :=</span>
<span class="c">  match v with</span>
<span class="c">  | Values.Vint i =&gt; Some (intToValue i)</span>
<span class="c">  | Values.Vint64 i =&gt; Some (intToValue i)</span>
<span class="c">  | Values.Vptr b off =&gt; Some (ptrToValue off)</span>
<span class="c">  | Values.Vundef =&gt; Some (ZToValue 0%Z)</span>
<span class="c">  | _ =&gt; None</span>
<span class="c">  end.</span>

<span class="c">(** Convert a [value] to a [bool], so that choices can be made based on the</span>
<span class="c">result. This is also because comparison operators will give back [value] instead</span>
<span class="c">of [bool], so if they are in a condition, they will have to be converted before</span>
<span class="c">they can be used. *)</span>

<span class="c">Definition valueToBool (v : value) : bool :=</span>
<span class="c">  if Z.eqb (uvalueToZ v) 0 then false else true.</span>

<span class="c">Definition boolToValue (b : bool) : value :=</span>
<span class="c">  natToValue (if b then 1 else 0).</span>

<span class="c">(** ** Arithmetic operations *)</span>

<span class="c">Definition unify_word (sz1 sz2 : nat) (w1 : word sz2): sz1 = sz2 -&gt; word sz1.</span>
<span class="c">intros; subst; assumption. Defined.</span>

<span class="c">Lemma unify_word_unfold :</span>
<span class="c">  forall sz w,</span>
<span class="c">  unify_word sz sz w eq_refl = w.</span>
<span class="c">Proof. auto. Qed.</span>

<span class="c">Inductive val_value_lessdef: val -&gt; value -&gt; Prop :=</span>
<span class="c">| val_value_lessdef_int:</span>
<span class="c">    forall i v&#39;,</span>
<span class="c">    i = valueToInt v&#39; -&gt;</span>
<span class="c">    val_value_lessdef (Vint i) v&#39;</span>
<span class="c">| val_value_lessdef_ptr:</span>
<span class="c">    forall b off v&#39;,</span>
<span class="c">    off = valueToPtr v&#39; -&gt;</span>
<span class="c">    val_value_lessdef (Vptr b off) v&#39;</span>
<span class="c">| lessdef_undef: forall v, val_value_lessdef Vundef v.</span>

<span class="c">Inductive opt_val_value_lessdef: option val -&gt; value -&gt; Prop :=</span>
<span class="c">| opt_lessdef_some:</span>
<span class="c">    forall v v&#39;, val_value_lessdef v v&#39; -&gt; opt_val_value_lessdef (Some v) v&#39;</span>
<span class="c">| opt_lessdef_none: forall v, opt_val_value_lessdef None v.</span>

<span class="c">Lemma valueToZ_ZToValue :</span>
<span class="c">  forall z,</span>
<span class="c">  (Int.min_signed &lt;= z &lt;= Int.max_signed)%Z -&gt;</span>
<span class="c">  valueToZ (ZToValue z) = z.</span>
<span class="c">Proof. auto using Int.signed_repr. Qed.</span>

<span class="c">Lemma uvalueToZ_ZToValue :</span>
<span class="c">  forall z,</span>
<span class="c">  (0 &lt;= z &lt;= Int.max_unsigned)%Z -&gt;</span>
<span class="c">  uvalueToZ (ZToValue z) = z.</span>
<span class="c">Proof. auto using Int.unsigned_repr. Qed.</span>

<span class="c">Lemma valueToPos_posToValue :</span>
<span class="c">  forall v,</span>
<span class="c">  0 &lt;= Z.pos v &lt;= Int.max_unsigned -&gt;</span>
<span class="c">  valueToPos (posToValue v) = v.</span>
<span class="c">Proof.</span>
<span class="c">  unfold valueToPos, posToValue.</span>
<span class="c">  intros. rewrite Int.unsigned_repr.</span>
<span class="c">  apply Pos2Z.id. assumption.</span>
<span class="c">Qed.</span>

<span class="c">Lemma valueToInt_intToValue :</span>
<span class="c">  forall v,</span>
<span class="c">  valueToInt (intToValue v) = v.</span>
<span class="c">Proof. auto. Qed.</span>

<span class="c">Lemma valToValue_lessdef :</span>
<span class="c">  forall v v&#39;,</span>
<span class="c">    valToValue v = Some v&#39; -&gt;</span>
<span class="c">    val_value_lessdef v v&#39;.</span>
<span class="c">Proof.</span>
<span class="c">  intros.</span>
<span class="c">  destruct v; try discriminate; constructor.</span>
<span class="c">  unfold valToValue in H. inversion H.</span>
<span class="c">  unfold valueToInt. unfold intToValue in H1. auto.</span>
<span class="c">  inv H. symmetry. unfold valueToPtr, ptrToValue. apply Ptrofs.of_int_to_int. trivial.</span>
<span class="c">Qed.</span>

<span class="c">Ltac simplify_val := repeat (simplify; unfold uvalueToZ, valueToPtr, Ptrofs.of_int, valueToInt, intToValue,</span>
<span class="c">                                       ptrToValue in *)</span>

<span class="c">(*Ltac crush_val := simplify_val; try discriminate; try congruence; try lia; liapp; try assumption.*)</span>
<span class="c">*)</span></span></span></pre>
</div>
</div></body>
</html>
