<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.16: http://docutils.sourceforge.net/" />
<title>HTLgenspec.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
</head>
<body>
<div class="alectryon-root alectryon-floating"><div class="document">


<pre class="alectryon-io"><!-- Generator: Alectryon v1.0 --><span class="coq-wsp"><span class="highlight"><span class="c">(*</span>
<span class="c"> * Vericert: Verified high-level synthesis.</span>
<span class="c"> * Copyright (C) 2020 Yann Herklotz &lt;yann@yannherklotz.com&gt;</span>
<span class="c"> *</span>
<span class="c"> * This program is free software: you can redistribute it and/or modify</span>
<span class="c"> * it under the terms of the GNU General Public License as published by</span>
<span class="c"> * the Free Software Foundation, either version 3 of the License, or</span>
<span class="c"> * (at your option) any later version.</span>
<span class="c"> *</span>
<span class="c"> * This program is distributed in the hope that it will be useful,</span>
<span class="c"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"> * GNU General Public License for more details.</span>
<span class="c"> *</span>
<span class="c"> * You should have received a copy of the GNU General Public License</span>
<span class="c"> * along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>
<span class="c"> *)</span>

</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> compcert <span class="kn">Require</span> RTL Op Maps Errors.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> compcert <span class="kn">Require Import</span> Maps Integers.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">From</span> vericert <span class="kn">Require Import</span> Vericertlib Verilog ValueInt HTL HTLgen AssocMap.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Require Import</span> Lia.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> Maps.PTree.elements_keys_norepet : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> Maps.PTree.elements_correct : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk0" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk0"><span class="highlight"><span class="kn">Remark</span> <span class="nf">bind_inversion</span>:
  <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span>: <span class="kt">Type</span>) (<span class="nv">f</span>: mon A) (<span class="nv">g</span>: A -&gt; mon B)
         (<span class="nv">y</span>: B) (<span class="nv">s1</span> <span class="nv">s3</span>: st) (<span class="nv">i</span>: st_incr s1 s3),
    bind f g s1 = OK y s3 i -&gt;
    <span class="kr">exists</span> <span class="nv">x</span>, <span class="kr">exists</span> <span class="nv">s2</span>, <span class="kr">exists</span> <span class="nv">i1</span>, <span class="kr">exists</span> <span class="nv">i2</span>,
            f s1 = OK x s2 i1 /\ g x s2 = OK y s3 i2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : mon A) (<span class="nv">g</span> : A -&gt; mon B)
  (<span class="nv">y</span> : B) (<span class="nv">s1</span> <span class="nv">s3</span> : st) (<span class="nv">i</span> : st_incr s1 s3),
(<span class="kp">do</span> X &lt;- f; g X) s1 = OK y s3 i -&gt;
<span class="kr">exists</span>
  (<span class="nv">x</span> : A) (<span class="nv">s2</span> : st) (<span class="nv">i1</span> : st_prop s1 s2) (<span class="nv">i2</span> : st_prop
                                                 s2 s3),
  f s1 = OK x s2 i1 /\ g x s2 = OK y s3 i2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk1" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : mon A) (<span class="nv">g</span> : A -&gt; mon B)
  (<span class="nv">y</span> : B) (<span class="nv">s1</span> <span class="nv">s3</span> : st) (<span class="nv">i</span> : st_incr s1 s3),
(<span class="kp">do</span> X &lt;- f; g X) s1 = OK y s3 i -&gt;
<span class="kr">exists</span>
  (<span class="nv">x</span> : A) (<span class="nv">s2</span> : st) (<span class="nv">i1</span> : st_prop s1 s2) (<span class="nv">i2</span> : st_prop
                                                 s2 s3),
  f s1 = OK x s2 i1 /\ g x s2 = OK y s3 i2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk2" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk2"><span class="highlight"><span class="nb">intros until</span> i.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mon A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; mon B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_incr s1 s3</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kp">do</span> X &lt;- f; g X) s1 = OK y s3 i -&gt;
<span class="kr">exists</span>
  (<span class="nv">x</span> : A) (<span class="nv">s2</span> : st) (<span class="nv">i1</span> : st_prop s1 s2) (<span class="nv">i2</span> : st_prop
                                                 s2 s3),
  f s1 = OK x s2 i1 /\ g x s2 = OK y s3 i2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk3" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk3"><span class="highlight"><span class="nb">unfold</span> bind.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mon A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; mon B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_incr s1 s3</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">match</span> f s1 <span class="kr">with</span>
| Error msg =&gt; Error msg
| OK a s&#39; i =&gt;
    <span class="kr">match</span> g a s&#39; <span class="kr">with</span>
    | Error msg =&gt; Error msg
    | OK b s&#39;&#39; i&#39; =&gt;
        OK b s&#39;&#39; (st_trans s1 s&#39; s&#39;&#39; i i&#39;)
    <span class="kr">end</span>
<span class="kr">end</span> = OK y s3 i -&gt;
<span class="kr">exists</span>
  (<span class="nv">x</span> : A) (<span class="nv">s2</span> : st) (<span class="nv">i1</span> : st_prop s1 s2) (<span class="nv">i2</span> : st_prop
                                                 s2 s3),
  f s1 = OK x s2 i1 /\ g x s2 = OK y s3 i2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk4" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk4"><span class="highlight"><span class="nb">destruct</span> (f s1); <span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mon A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; mon B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_incr s1 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Errors.errmsg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Error e = OK y s3 i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span>
  (<span class="nv">x</span> : A) (<span class="nv">s2</span> : st) (<span class="nv">i1</span> : st_prop s1 s2) (<span class="nv">i2</span> : st_prop
                                                 s2 s3),
  Error e = OK x s2 i1 /\ g x s2 = OK y s3 i2</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chk5" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mon A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; mon B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_incr s1 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> g a s&#39; <span class="kr">with</span>
| Error msg =&gt; Error msg
| OK b s&#39;&#39; i&#39; =&gt;
    OK b s&#39;&#39; (st_trans s1 s&#39; s&#39;&#39; s i&#39;)
<span class="kr">end</span> = OK y s3 i</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chk5"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span>
  (<span class="nv">x</span> : A) (<span class="nv">s2</span> : st) (<span class="nv">i1</span> : st_prop s1 s2) (<span class="nv">i2</span> : st_prop
                                                 s2 s3),
  OK a s&#39; s = OK x s2 i1 /\ g x s2 = OK y s3 i2</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk6" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk6"><span class="highlight"><span class="bp">discriminate</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mon A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; mon B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_incr s1 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> g a s&#39; <span class="kr">with</span>
| Error msg =&gt; Error msg
| OK b s&#39;&#39; i&#39; =&gt;
    OK b s&#39;&#39; (st_trans s1 s&#39; s&#39;&#39; s i&#39;)
<span class="kr">end</span> = OK y s3 i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span>
  (<span class="nv">x</span> : A) (<span class="nv">s2</span> : st) (<span class="nv">i1</span> : st_prop s1 s2) (<span class="nv">i2</span> : st_prop
                                                 s2 s3),
  OK a s&#39; s = OK x s2 i1 /\ g x s2 = OK y s3 i2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk7" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk7"><span class="highlight"><span class="kr">exists</span> <span class="nv">a</span>; <span class="kr">exists</span> <span class="nv">s&#39;</span>; <span class="kr">exists</span> <span class="nv">s</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mon A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; mon B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_incr s1 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> g a s&#39; <span class="kr">with</span>
| Error msg =&gt; Error msg
| OK b s&#39;&#39; i&#39; =&gt;
    OK b s&#39;&#39; (st_trans s1 s&#39; s&#39;&#39; s i&#39;)
<span class="kr">end</span> = OK y s3 i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">i2</span> : st_prop s&#39; s3,
  OK a s&#39; s = OK a s&#39; s /\ g a s&#39; = OK y s3 i2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk8" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk8"><span class="highlight"><span class="nb">destruct</span> (g a s&#39;); inv H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mon A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; mon B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_incr s1 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s3</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span> <span class="nv">i2</span> : st_prop s&#39; s3,
  OK a s&#39; s = OK a s&#39; s /\ OK y s3 s0 = OK y s3 i2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kr">exists</span> <span class="nv">s0</span>; <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk9" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk9"><span class="highlight"><span class="kn">Remark</span> <span class="nf">bind2_inversion</span>:
  <span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>: <span class="kt">Type</span>) (<span class="nv">f</span>: mon (A*B)) (<span class="nv">g</span>: A -&gt; B -&gt; mon C)
         (<span class="nv">z</span>: C) (<span class="nv">s1</span> <span class="nv">s3</span>: st) (<span class="nv">i</span>: st_incr s1 s3),
    bind2 f g s1 = OK z s3 i -&gt;
    <span class="kr">exists</span> <span class="nv">x</span>, <span class="kr">exists</span> <span class="nv">y</span>, <span class="kr">exists</span> <span class="nv">s2</span>, <span class="kr">exists</span> <span class="nv">i1</span>, <span class="kr">exists</span> <span class="nv">i2</span>,
              f s1 = OK (x, y) s2 i1 /\ g x y s2 = OK z s3 i2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : mon (A * B))
  (<span class="nv">g</span> : A -&gt; B -&gt; mon C) (<span class="nv">z</span> : C) (<span class="nv">s1</span> <span class="nv">s3</span> : st)
  (<span class="nv">i</span> : st_incr s1 s3),
(<span class="kp">do</span> (X, Y)&lt;- f; g X Y) s1 = OK z s3 i -&gt;
<span class="kr">exists</span>
  (<span class="nv">x</span> : A) (<span class="nv">y</span> : B) (<span class="nv">s2</span> : st) (<span class="nv">i1</span> : st_prop s1 s2) (<span class="nv">i2</span> : 
                                                 st_prop
                                                 s2 s3),
  f s1 = OK (x, y) s2 i1 /\ g x y s2 = OK z s3 i2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chka" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chka"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : mon (A * B))
  (<span class="nv">g</span> : A -&gt; B -&gt; mon C) (<span class="nv">z</span> : C) (<span class="nv">s1</span> <span class="nv">s3</span> : st)
  (<span class="nv">i</span> : st_incr s1 s3),
(<span class="kp">do</span> (X, Y)&lt;- f; g X Y) s1 = OK z s3 i -&gt;
<span class="kr">exists</span>
  (<span class="nv">x</span> : A) (<span class="nv">y</span> : B) (<span class="nv">s2</span> : st) (<span class="nv">i1</span> : st_prop s1 s2) (<span class="nv">i2</span> : 
                                                 st_prop
                                                 s2 s3),
  f s1 = OK (x, y) s2 i1 /\ g x y s2 = OK z s3 i2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkb" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkb"><span class="highlight"><span class="nb">unfold</span> bind2; <span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mon (A * B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B -&gt; mon C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_incr s1 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kp">do</span> xy &lt;- f; g (fst xy) (snd xy)) s1 = OK z s3 i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span>
  (<span class="nv">x</span> : A) (<span class="nv">y</span> : B) (<span class="nv">s2</span> : st) (<span class="nv">i1</span> : st_prop s1 s2) (<span class="nv">i2</span> : 
                                                 st_prop
                                                 s2 s3),
  f s1 = OK (x, y) s2 i1 /\ g x y s2 = OK z s3 i2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkc" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkc"><span class="highlight">exploit bind_inversion; <span class="nb">eauto</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mon (A * B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B -&gt; mon C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_incr s1 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kp">do</span> xy &lt;- f; g (fst xy) (snd xy)) s1 = OK z s3 i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">exists</span>
   (<span class="nv">x</span> : A * B) (<span class="nv">s2</span> : st) (<span class="nv">i1</span> : st_prop s1 s2) (<span class="nv">i2</span> : 
                                               st_prop
                                                 s2 s3),
   f s1 = OK x s2 i1 /\
   (<span class="kr">fun</span> <span class="nv">xy</span> : A * B =&gt; g (fst xy) (snd xy)) x s2 =
   OK z s3 i2) -&gt;
<span class="kr">exists</span>
  (<span class="nv">x</span> : A) (<span class="nv">y</span> : B) (<span class="nv">s2</span> : st) (<span class="nv">i1</span> : st_prop s1 s2) (<span class="nv">i2</span> : 
                                                 st_prop
                                                 s2 s3),
  f s1 = OK (x, y) s2 i1 /\ g x y s2 = OK z s3 i2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkd" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkd"><span class="highlight"><span class="nb">intros</span> [[x y] [s2 [i1 [i2 [P Q]]]]].</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mon (A * B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B -&gt; mon C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_incr s1 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kp">do</span> xy &lt;- f; g (fst xy) (snd xy)) s1 = OK z s3 i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f s1 = OK (x, y) s2 i1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g (fst (x, y)) (snd (x, y)) s2 = OK z s3 i2</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span>
  (<span class="nv">x</span> : A) (<span class="nv">y</span> : B) (<span class="nv">s2</span> : st) (<span class="nv">i1</span> : st_prop s1 s2) (<span class="nv">i2</span> : 
                                                 st_prop
                                                 s2 s3),
  f s1 = OK (x, y) s2 i1 /\ g x y s2 = OK z s3 i2</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chke" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chke"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> Q.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">mon (A * B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B -&gt; mon C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_incr s1 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kp">do</span> xy &lt;- f; g (fst xy) (snd xy)) s1 = OK z s3 i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f s1 = OK (x, y) s2 i1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g x y s2 = OK z s3 i2</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">exists</span>
  (<span class="nv">x</span> : A) (<span class="nv">y</span> : B) (<span class="nv">s2</span> : st) (<span class="nv">i1</span> : st_prop s1 s2) (<span class="nv">i2</span> : 
                                                 st_prop
                                                 s2 s3),
  f s1 = OK (x, y) s2 i1 /\ g x y s2 = OK z s3 i2</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kr">exists</span> <span class="nv">x</span>; <span class="kr">exists</span> <span class="nv">y</span>; <span class="kr">exists</span> <span class="nv">s2</span>; <span class="kr">exists</span> <span class="nv">i1</span>; <span class="kr">exists</span> <span class="nv">i2</span>; <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">monadInv1</span> H :=
  <span class="kr">match</span> <span class="kp">type of</span> H <span class="kr">with</span>
  | (OK _ _ _ = OK _ _ _) =&gt;
    <span class="nb">inversion</span> H; <span class="nb">clear</span> H; <span class="kp">try</span> <span class="nb">subst</span>
  | (Error _ _ = OK _ _ _) =&gt;
    <span class="bp">discriminate</span>
  | (ret _ _ = OK _ _ _) =&gt;
    <span class="nb">inversion</span> H; <span class="nb">clear</span> H; <span class="kp">try</span> <span class="nb">subst</span>
  | (error _ _ = OK _ _ _) =&gt;
    <span class="bp">discriminate</span>
  | (bind <span class="nl">?F</span> <span class="nl">?G</span> <span class="nl">?S</span> = OK <span class="nl">?X</span> <span class="nl">?S&#39;</span> <span class="nl">?I</span>) =&gt;
    <span class="kr">let</span> <span class="nv">x</span> := <span class="kp">fresh</span> <span class="s2">&quot;x&quot;</span> <span class="kr">in</span> (
      <span class="kr">let</span> <span class="nv">s</span> := <span class="kp">fresh</span> <span class="s2">&quot;s&quot;</span> <span class="kr">in</span> (
        <span class="kr">let</span> <span class="nv">i1</span> := <span class="kp">fresh</span> <span class="s2">&quot;INCR&quot;</span> <span class="kr">in</span> (
          <span class="kr">let</span> <span class="nv">i2</span> := <span class="kp">fresh</span> <span class="s2">&quot;INCR&quot;</span> <span class="kr">in</span> (
            <span class="kr">let</span> <span class="nv">EQ1</span> := <span class="kp">fresh</span> <span class="s2">&quot;EQ&quot;</span> <span class="kr">in</span> (
              <span class="kr">let</span> <span class="nv">EQ2</span> := <span class="kp">fresh</span> <span class="s2">&quot;EQ&quot;</span> <span class="kr">in</span> (
                <span class="nb">destruct</span> (bind_inversion _ _ F G X S S&#39; I H) <span class="kr">as</span> [x [s [i1 [i2 [EQ1 EQ2]]]]];
                <span class="nb">clear</span> H;
                <span class="kp">try</span> (monadInv1 EQ2)))))))
  | (bind2 <span class="nl">?F</span> <span class="nl">?G</span> <span class="nl">?S</span> = OK <span class="nl">?X</span> <span class="nl">?S&#39;</span> <span class="nl">?I</span>) =&gt;
    <span class="kr">let</span> <span class="nv">x1</span> := <span class="kp">fresh</span> <span class="s2">&quot;x&quot;</span> <span class="kr">in</span> (
      <span class="kr">let</span> <span class="nv">x2</span> := <span class="kp">fresh</span> <span class="s2">&quot;x&quot;</span> <span class="kr">in</span> (
        <span class="kr">let</span> <span class="nv">s</span> := <span class="kp">fresh</span> <span class="s2">&quot;s&quot;</span> <span class="kr">in</span> (
          <span class="kr">let</span> <span class="nv">i1</span> := <span class="kp">fresh</span> <span class="s2">&quot;INCR&quot;</span> <span class="kr">in</span> (
            <span class="kr">let</span> <span class="nv">i2</span> := <span class="kp">fresh</span> <span class="s2">&quot;INCR&quot;</span> <span class="kr">in</span> (
              <span class="kr">let</span> <span class="nv">EQ1</span> := <span class="kp">fresh</span> <span class="s2">&quot;EQ&quot;</span> <span class="kr">in</span> (
                <span class="kr">let</span> <span class="nv">EQ2</span> := <span class="kp">fresh</span> <span class="s2">&quot;EQ&quot;</span> <span class="kr">in</span> (
                  <span class="nb">destruct</span> (bind2_inversion _ _ _ F G X S S&#39; I H) <span class="kr">as</span> [x1 [x2 [s [i1 [i2 [EQ1 EQ2]]]]]];
                  <span class="nb">clear</span> H;
                  <span class="kp">try</span> (monadInv1 EQ2))))))))
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">monadInv</span> H :=
  <span class="kr">match</span> <span class="kp">type of</span> H <span class="kr">with</span>
  | (ret _ _ = OK _ _ _) =&gt; monadInv1 H
  | (error _ _ = OK _ _ _) =&gt; monadInv1 H
  | (bind <span class="nl">?F</span> <span class="nl">?G</span> <span class="nl">?S</span> = OK <span class="nl">?X</span> <span class="nl">?S&#39;</span> <span class="nl">?I</span>) =&gt; monadInv1 H
  | (bind2 <span class="nl">?F</span> <span class="nl">?G</span> <span class="nl">?S</span> = OK <span class="nl">?X</span> <span class="nl">?S&#39;</span> <span class="nl">?I</span>) =&gt; monadInv1 H
  | (<span class="nl">?F</span> _ _ _ _ _ _ _ _ = OK _ _ _) =&gt;
    ((<span class="kp">progress</span> <span class="nb">simpl</span> <span class="kr">in</span> H) || <span class="nb">unfold</span> F <span class="kr">in</span> H); monadInv1 H
  | (<span class="nl">?F</span> _ _ _ _ _ _ _ = OK _ _ _) =&gt;
    ((<span class="kp">progress</span> <span class="nb">simpl</span> <span class="kr">in</span> H) || <span class="nb">unfold</span> F <span class="kr">in</span> H); monadInv1 H
  | (<span class="nl">?F</span> _ _ _ _ _ _ = OK _ _ _) =&gt;
    ((<span class="kp">progress</span> <span class="nb">simpl</span> <span class="kr">in</span> H) || <span class="nb">unfold</span> F <span class="kr">in</span> H); monadInv1 H
  | (<span class="nl">?F</span> _ _ _ _ _ = OK _ _ _) =&gt;
    ((<span class="kp">progress</span> <span class="nb">simpl</span> <span class="kr">in</span> H) || <span class="nb">unfold</span> F <span class="kr">in</span> H); monadInv1 H
  | (<span class="nl">?F</span> _ _ _ _ = OK _ _ _) =&gt;
    ((<span class="kp">progress</span> <span class="nb">simpl</span> <span class="kr">in</span> H) || <span class="nb">unfold</span> F <span class="kr">in</span> H); monadInv1 H
  | (<span class="nl">?F</span> _ _ _ = OK _ _ _) =&gt;
    ((<span class="kp">progress</span> <span class="nb">simpl</span> <span class="kr">in</span> H) || <span class="nb">unfold</span> F <span class="kr">in</span> H); monadInv1 H
  | (<span class="nl">?F</span> _ _ = OK _ _ _) =&gt;
    ((<span class="kp">progress</span> <span class="nb">simpl</span> <span class="kr">in</span> H) || <span class="nb">unfold</span> F <span class="kr">in</span> H); monadInv1 H
  | (<span class="nl">?F</span> _ = OK _ _ _) =&gt;
    ((<span class="kp">progress</span> <span class="nb">simpl</span> <span class="kr">in</span> H) || <span class="nb">unfold</span> F <span class="kr">in</span> H); monadInv1 H
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
<span class="sd">(** * Relational specification of the translation *)</span>

<span class="sd">(** We now define inductive predicates that characterise the fact that the</span>
<span class="sd">statemachine that is created by the translation contains the correct</span>
<span class="sd">translations for each of the elements *)</span>

</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">tr_instr</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">st</span> <span class="nv">stk</span> : reg) : RTL.instruction -&gt; stmnt -&gt; stmnt -&gt; <span class="kt">Prop</span> :=
| tr_instr_Inop :
    <span class="kr">forall</span> <span class="nv">n</span>,
      Z.pos n &lt;= Int.max_unsigned -&gt;
      tr_instr fin rtrn st stk (RTL.Inop n) Vskip (state_goto st n)
| tr_instr_Iop :
    <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">op</span> <span class="nv">args</span> <span class="nv">dst</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">e</span> <span class="nv">i</span>,
      Z.pos n &lt;= Int.max_unsigned -&gt;
      translate_instr op args s = OK e s&#39; i -&gt;
      tr_instr fin rtrn st stk (RTL.Iop op args dst n) (Vnonblock (Vvar dst) e) (state_goto st n)
| tr_instr_Icond :
    <span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">cond</span> <span class="nv">args</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">i</span> <span class="nv">c</span>,
      Z.pos n1 &lt;= Int.max_unsigned -&gt;
      Z.pos n2 &lt;= Int.max_unsigned -&gt;
      translate_condition cond args s = OK c s&#39; i -&gt;
      tr_instr fin rtrn st stk (RTL.Icond cond args n1 n2) Vskip (state_cond st c n1 n2)
| tr_instr_Ireturn_None :
    tr_instr fin rtrn st stk (RTL.Ireturn None) (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>%Z)))
                                                  (block rtrn (Vlit (ZToValue <span class="mi">0</span>%Z)))) Vskip
| tr_instr_Ireturn_Some :
    <span class="kr">forall</span> <span class="nv">r</span>,
      tr_instr fin rtrn st stk (RTL.Ireturn (Some r))
               (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>%Z))) (block rtrn (Vvar r))) Vskip
| tr_instr_Iload :
    <span class="kr">forall</span> <span class="nv">mem</span> <span class="nv">addr</span> <span class="nv">args</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">i</span> <span class="nv">c</span> <span class="nv">dst</span> <span class="nv">n</span>,
      Z.pos n &lt;= Int.max_unsigned -&gt;
      translate_arr_access mem addr args stk s = OK c s&#39; i -&gt;
      tr_instr fin rtrn st stk (RTL.Iload mem addr args dst n) (nonblock dst c) (state_goto st n)
| tr_instr_Istore :
    <span class="kr">forall</span> <span class="nv">mem</span> <span class="nv">addr</span> <span class="nv">args</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">i</span> <span class="nv">c</span> <span class="nv">src</span> <span class="nv">n</span>,
      Z.pos n &lt;= Int.max_unsigned -&gt;
      translate_arr_access mem addr args stk s = OK c s&#39; i -&gt;
      tr_instr fin rtrn st stk (RTL.Istore mem addr args src n) (Vnonblock c (Vvar src))
               (state_goto st n).</span></span></span></pre><dl class="docutils">
<dt>tr_instr_Ijumptable :</dt>
<dd><p class="first">forall cexpr tbl r,
cexpr = tbl_to_case_expr st tbl -&gt;
tr_instr fin rtrn st stk (RTL.Ijumptable r tbl) (Vskip) (Vcase (Vvar r) cexpr (Some Vskip)).</p>
<div class="last"><pre class="alectryon-io"><!-- Generator: Alectryon v1.0 --><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Constructors</span> tr_instr : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">tr_code</span> (<span class="nv">c</span> : RTL.code) (<span class="nv">pc</span> : RTL.node) (<span class="nv">i</span> : RTL.instruction) (<span class="nv">stmnts</span> <span class="nv">trans</span> : PTree.t stmnt)
          (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">st</span> <span class="nv">stk</span> : reg) : <span class="kt">Prop</span> :=
  tr_code_intro :
    <span class="kr">forall</span> <span class="nv">s</span> <span class="nv">t</span>,
      c!pc = Some i -&gt;
      stmnts!pc = Some s -&gt;
      trans!pc = Some t -&gt;
      tr_instr fin rtrn st stk i s t -&gt;
      tr_code c pc i stmnts trans fin rtrn st stk.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Constructors</span> tr_code : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">tr_module</span> (<span class="nv">f</span> : RTL.function) : module -&gt; <span class="kt">Prop</span> :=
  tr_module_intro :
    <span class="kr">forall</span> <span class="nv">data</span> <span class="nv">control</span> <span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">st</span> <span class="nv">stk</span> <span class="nv">stk_len</span> <span class="nv">m</span> <span class="nv">start</span> <span class="nv">rst</span> <span class="nv">clk</span> <span class="nv">scldecls</span> <span class="nv">arrdecls</span> <span class="nv">wf</span>,
      m = (mkmodule f.(RTL.fn_params)
                        data
                        control
                        f.(RTL.fn_entrypoint)
                        st stk stk_len fin rtrn start rst clk scldecls arrdecls <span class="kn">wf</span>) -&gt;
      (<span class="kr">forall</span> <span class="nv">pc</span> <span class="nv">i</span>, Maps.PTree.get pc f.(RTL.fn_code) = Some i -&gt;
               tr_code f.(RTL.fn_code) pc i data control fin rtrn st stk) -&gt;
      stk_len = Z.to_nat (f.(RTL.fn_stacksize) / <span class="mi">4</span>) -&gt;
      Z.modulo (f.(RTL.fn_stacksize)) <span class="mi">4</span> = <span class="mi">0</span> -&gt;
      <span class="mi">0</span> &lt;= f.(RTL.fn_stacksize) &lt; Integers.Ptrofs.modulus -&gt;
      st = ((RTL.max_reg_function f) + <span class="mi">1</span>)%positive -&gt;
      fin = ((RTL.max_reg_function f) + <span class="mi">2</span>)%positive -&gt;
      rtrn = ((RTL.max_reg_function f) + <span class="mi">3</span>)%positive -&gt;
      stk = ((RTL.max_reg_function f) + <span class="mi">4</span>)%positive -&gt;
      start = ((RTL.max_reg_function f) + <span class="mi">5</span>)%positive -&gt;
      rst = ((RTL.max_reg_function f) + <span class="mi">6</span>)%positive -&gt;
      clk = ((RTL.max_reg_function f) + <span class="mi">7</span>)%positive -&gt;
      tr_module f m.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Constructors</span> tr_module : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkf" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkf"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">create_reg_datapath_trans</span> :
  <span class="kr">forall</span> <span class="nv">sz</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">x</span> <span class="nv">i</span> <span class="nv">iop</span>,
    create_reg iop sz s = OK x s&#39; i -&gt;
    s.(st_datapath) = s&#39;.(st_datapath).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">sz</span> : nat) (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : reg)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">iop</span> : option io),
create_reg iop sz s = OK x s&#39; i -&gt;
st_datapath s = st_datapath s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk10" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk10"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">sz</span> : nat) (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : reg)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">iop</span> : option io),
create_reg iop sz s = OK x s&#39; i -&gt;
st_datapath s = st_datapath s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk11" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk11"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">sz</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">iop</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg iop sz s = OK x s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_datapath s = st_datapath s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk12" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk12"><span class="highlight">monadInv H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">sz</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">iop</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s
  {|
  st_st := st_st s;
  st_freshreg := Pos.succ (st_freshreg s);
  st_freshstate := st_freshstate s;
  st_scldecls := AssocMap.<span class="nb">set</span> (st_freshreg s)
                   (iop, VScalar sz)
                   (st_scldecls s);
  st_arrdecls := st_arrdecls s;
  st_datapath := st_datapath s;
  st_controllogic := st_controllogic s |}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_datapath s =
st_datapath
  {|
  st_st := st_st s;
  st_freshreg := Pos.succ (st_freshreg s);
  st_freshstate := st_freshstate s;
  st_scldecls := AssocMap.<span class="nb">set</span> (st_freshreg s)
                   (iop, VScalar sz) (st_scldecls s);
  st_arrdecls := st_arrdecls s;
  st_datapath := st_datapath s;
  st_controllogic := st_controllogic s |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> create_reg_datapath_trans : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk13" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk13"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">create_reg_controllogic_trans</span> :
  <span class="kr">forall</span> <span class="nv">sz</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">x</span> <span class="nv">i</span> <span class="nv">iop</span>,
    create_reg iop sz s = OK x s&#39; i -&gt;
    s.(st_controllogic) = s&#39;.(st_controllogic).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">sz</span> : nat) (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : reg)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">iop</span> : option io),
create_reg iop sz s = OK x s&#39; i -&gt;
st_controllogic s = st_controllogic s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk14" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk14"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">sz</span> : nat) (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : reg)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">iop</span> : option io),
create_reg iop sz s = OK x s&#39; i -&gt;
st_controllogic s = st_controllogic s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk15" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk15"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">sz</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">iop</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg iop sz s = OK x s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_controllogic s = st_controllogic s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk16" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk16"><span class="highlight">monadInv H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">sz</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">iop</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s
  {|
  st_st := st_st s;
  st_freshreg := Pos.succ (st_freshreg s);
  st_freshstate := st_freshstate s;
  st_scldecls := AssocMap.<span class="nb">set</span> (st_freshreg s)
                   (iop, VScalar sz)
                   (st_scldecls s);
  st_arrdecls := st_arrdecls s;
  st_datapath := st_datapath s;
  st_controllogic := st_controllogic s |}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_controllogic s =
st_controllogic
  {|
  st_st := st_st s;
  st_freshreg := Pos.succ (st_freshreg s);
  st_freshstate := st_freshstate s;
  st_scldecls := AssocMap.<span class="nb">set</span> (st_freshreg s)
                   (iop, VScalar sz) (st_scldecls s);
  st_arrdecls := st_arrdecls s;
  st_datapath := st_datapath s;
  st_controllogic := st_controllogic s |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> create_reg_controllogic_trans : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk17" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk17"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">declare_reg_datapath_trans</span> :
  <span class="kr">forall</span> <span class="nv">sz</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">x</span> <span class="nv">i</span> <span class="nv">iop</span> <span class="nv">r</span>,
    declare_reg iop r sz s = OK x s&#39; i -&gt;
    s.(st_datapath) = s&#39;.(st_datapath).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">sz</span> : nat) (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">iop</span> : option io) (<span class="nv">r</span> : reg),
declare_reg iop r sz s = OK x s&#39; i -&gt;
st_datapath s = st_datapath s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk18" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk18"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">sz</span> : nat) (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">iop</span> : option io) (<span class="nv">r</span> : reg),
declare_reg iop r sz s = OK x s&#39; i -&gt;
st_datapath s = st_datapath s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk19" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk19"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">sz</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">iop</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">declare_reg iop r sz s = OK x s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_datapath s = st_datapath s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk1a" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk1a"><span class="highlight">monadInv H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">sz</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">iop</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s
  {|
  st_st := st_st s;
  st_freshreg := st_freshreg s;
  st_freshstate := st_freshstate s;
  st_scldecls := AssocMap.<span class="nb">set</span> r (iop, VScalar sz)
                   (st_scldecls s);
  st_arrdecls := st_arrdecls s;
  st_datapath := st_datapath s;
  st_controllogic := st_controllogic s |}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_datapath s =
st_datapath
  {|
  st_st := st_st s;
  st_freshreg := st_freshreg s;
  st_freshstate := st_freshstate s;
  st_scldecls := AssocMap.<span class="nb">set</span> r (iop, VScalar sz)
                   (st_scldecls s);
  st_arrdecls := st_arrdecls s;
  st_datapath := st_datapath s;
  st_controllogic := st_controllogic s |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> create_reg_datapath_trans : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk1b" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk1b"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">declare_reg_controllogic_trans</span> :
  <span class="kr">forall</span> <span class="nv">sz</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">x</span> <span class="nv">i</span> <span class="nv">iop</span> <span class="nv">r</span>,
    declare_reg iop r sz s = OK x s&#39; i -&gt;
    s.(st_controllogic) = s&#39;.(st_controllogic).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">sz</span> : nat) (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">iop</span> : option io) (<span class="nv">r</span> : reg),
declare_reg iop r sz s = OK x s&#39; i -&gt;
st_controllogic s = st_controllogic s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk1c" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk1c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">sz</span> : nat) (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">iop</span> : option io) (<span class="nv">r</span> : reg),
declare_reg iop r sz s = OK x s&#39; i -&gt;
st_controllogic s = st_controllogic s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk1d" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk1d"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">sz</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">iop</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">declare_reg iop r sz s = OK x s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_controllogic s = st_controllogic s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk1e" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk1e"><span class="highlight">monadInv H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">sz</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">iop</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s
  {|
  st_st := st_st s;
  st_freshreg := st_freshreg s;
  st_freshstate := st_freshstate s;
  st_scldecls := AssocMap.<span class="nb">set</span> r (iop, VScalar sz)
                   (st_scldecls s);
  st_arrdecls := st_arrdecls s;
  st_datapath := st_datapath s;
  st_controllogic := st_controllogic s |}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_controllogic s =
st_controllogic
  {|
  st_st := st_st s;
  st_freshreg := st_freshreg s;
  st_freshstate := st_freshstate s;
  st_scldecls := AssocMap.<span class="nb">set</span> r (iop, VScalar sz)
                   (st_scldecls s);
  st_arrdecls := st_arrdecls s;
  st_datapath := st_datapath s;
  st_controllogic := st_controllogic s |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> create_reg_controllogic_trans : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk1f" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk1f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">declare_reg_freshreg_trans</span> :
  <span class="kr">forall</span> <span class="nv">sz</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">x</span> <span class="nv">i</span> <span class="nv">iop</span> <span class="nv">r</span>,
    declare_reg iop r sz s = OK x s&#39; i -&gt;
    s.(st_freshreg) = s&#39;.(st_freshreg).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">sz</span> : nat) (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">iop</span> : option io) (<span class="nv">r</span> : reg),
declare_reg iop r sz s = OK x s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk20" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk20"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">sz</span> : nat) (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">iop</span> : option io) (<span class="nv">r</span> : reg),
declare_reg iop r sz s = OK x s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion</span> <span class="mi">1</span>; <span class="nb">auto</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> declare_reg_freshreg_trans : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk21" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk21"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">create_arr_datapath_trans</span> :
  <span class="kr">forall</span> <span class="nv">sz</span> <span class="nv">ln</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">x</span> <span class="nv">i</span> <span class="nv">iop</span>,
    create_arr iop sz ln s = OK x s&#39; i -&gt;
    s.(st_datapath) = s&#39;.(st_datapath).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">sz</span> <span class="nv">ln</span> : nat) (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : reg * nat)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">iop</span> : option io),
create_arr iop sz ln s = OK x s&#39; i -&gt;
st_datapath s = st_datapath s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk22" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk22"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">sz</span> <span class="nv">ln</span> : nat) (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : reg * nat)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">iop</span> : option io),
create_arr iop sz ln s = OK x s&#39; i -&gt;
st_datapath s = st_datapath s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk23" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk23"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">sz, ln</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(reg * nat)%type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">iop</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr iop sz ln s = OK x s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_datapath s = st_datapath s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk24" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk24"><span class="highlight">monadInv H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">sz, ln</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">iop</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s
  {|
  st_st := st_st s;
  st_freshreg := Pos.succ (st_freshreg s);
  st_freshstate := st_freshstate s;
  st_scldecls := st_scldecls s;
  st_arrdecls := AssocMap.<span class="nb">set</span> (st_freshreg s)
                   (iop, VArray sz ln)
                   (st_arrdecls s);
  st_datapath := st_datapath s;
  st_controllogic := st_controllogic s |}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_datapath s =
st_datapath
  {|
  st_st := st_st s;
  st_freshreg := Pos.succ (st_freshreg s);
  st_freshstate := st_freshstate s;
  st_scldecls := st_scldecls s;
  st_arrdecls := AssocMap.<span class="nb">set</span> (st_freshreg s)
                   (iop, VArray sz ln) (st_arrdecls s);
  st_datapath := st_datapath s;
  st_controllogic := st_controllogic s |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> create_arr_datapath_trans : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk25" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk25"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">create_arr_controllogic_trans</span> :
  <span class="kr">forall</span> <span class="nv">sz</span> <span class="nv">ln</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">x</span> <span class="nv">i</span> <span class="nv">iop</span>,
    create_arr iop sz ln s = OK x s&#39; i -&gt;
    s.(st_controllogic) = s&#39;.(st_controllogic).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">sz</span> <span class="nv">ln</span> : nat) (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : reg * nat)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">iop</span> : option io),
create_arr iop sz ln s = OK x s&#39; i -&gt;
st_controllogic s = st_controllogic s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk26" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk26"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">sz</span> <span class="nv">ln</span> : nat) (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : reg * nat)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">iop</span> : option io),
create_arr iop sz ln s = OK x s&#39; i -&gt;
st_controllogic s = st_controllogic s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk27" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk27"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">sz, ln</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(reg * nat)%type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">iop</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr iop sz ln s = OK x s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_controllogic s = st_controllogic s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk28" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk28"><span class="highlight">monadInv H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">sz, ln</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">iop</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s
  {|
  st_st := st_st s;
  st_freshreg := Pos.succ (st_freshreg s);
  st_freshstate := st_freshstate s;
  st_scldecls := st_scldecls s;
  st_arrdecls := AssocMap.<span class="nb">set</span> (st_freshreg s)
                   (iop, VArray sz ln)
                   (st_arrdecls s);
  st_datapath := st_datapath s;
  st_controllogic := st_controllogic s |}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_controllogic s =
st_controllogic
  {|
  st_st := st_st s;
  st_freshreg := Pos.succ (st_freshreg s);
  st_freshstate := st_freshstate s;
  st_scldecls := st_scldecls s;
  st_arrdecls := AssocMap.<span class="nb">set</span> (st_freshreg s)
                   (iop, VArray sz ln) (st_arrdecls s);
  st_datapath := st_datapath s;
  st_controllogic := st_controllogic s |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> create_arr_controllogic_trans : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk29" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk29"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">get_refl_x</span> :
  <span class="kr">forall</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">x</span> <span class="nv">i</span>,
    get s = OK x s&#39; i -&gt;
    s = x.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">x</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
get s = OK x s&#39; i -&gt; s = x</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk2a" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk2a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">x</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
get s = OK x s&#39; i -&gt; s = x</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk2b" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk2b"><span class="highlight"><span class="nb">inversion</span> <span class="mi">1</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s, s', x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s = OK x s&#39; i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">s = x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x = s&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s&#39; = s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> get_refl_x : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk2c" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk2c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">get_refl_s</span> :
  <span class="kr">forall</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">x</span> <span class="nv">i</span>,
    get s = OK x s&#39; i -&gt;
    s = s&#39;.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">x</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
get s = OK x s&#39; i -&gt; s = s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk2d" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk2d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">x</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
get s = OK x s&#39; i -&gt; s = s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk2e" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk2e"><span class="highlight"><span class="nb">inversion</span> <span class="mi">1</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">s, s', x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s = OK x s&#39; i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">s = x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x = s&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">s&#39; = s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> get_refl_s : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">inv_incr</span> :=
  <span class="kp">repeat</span> <span class="kr">match goal with</span>
  | [ H: create_reg _ _ <span class="nl">?s</span> = OK _ <span class="nl">?s&#39;</span> _ |- _ ] =&gt;
    <span class="kr">let</span> <span class="nv">H1</span> := <span class="kp">fresh</span> <span class="s2">&quot;H&quot;</span> <span class="kr">in</span>
    <span class="nb">assert</span> (H1 := H); <span class="nb">eapply</span> create_reg_datapath_trans <span class="kr">in</span> H;
    <span class="nb">eapply</span> create_reg_controllogic_trans <span class="kr">in</span> H1
  | [ H: create_arr _ _ _ <span class="nl">?s</span> = OK _ <span class="nl">?s&#39;</span> _ |- _ ] =&gt;
    <span class="kr">let</span> <span class="nv">H1</span> := <span class="kp">fresh</span> <span class="s2">&quot;H&quot;</span> <span class="kr">in</span>
    <span class="nb">assert</span> (H1 := H); <span class="nb">eapply</span> create_arr_datapath_trans <span class="kr">in</span> H;
    <span class="nb">eapply</span> create_arr_controllogic_trans <span class="kr">in</span> H1
  | [ H: get <span class="nl">?s</span> = OK _ _ _ |- _ ] =&gt;
    <span class="kr">let</span> <span class="nv">H1</span> := <span class="kp">fresh</span> <span class="s2">&quot;H&quot;</span> <span class="kr">in</span>
    <span class="nb">assert</span> (H1 := H); <span class="nb">apply</span> get_refl_x <span class="kr">in</span> H; <span class="nb">apply</span> get_refl_s <span class="kr">in</span> H1;
    <span class="nb">subst</span>
  | [ H: st_prop _ _ |- _ ] =&gt; <span class="nb">unfold</span> st_prop <span class="kr">in</span> H; <span class="nb">destruct</span> H
  | [ H: st_incr _ _ |- _ ] =&gt; <span class="nb">destruct</span> st_incr
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk2f" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk2f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">collect_controllogic_trans</span> :
  <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">f</span> <span class="nv">l</span> <span class="nv">cs</span> <span class="nv">cs&#39;</span> <span class="nv">ci</span>,
  (<span class="kr">forall</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">x</span> <span class="nv">i</span> <span class="nv">y</span>, f y s = OK x s&#39; i -&gt; s.(st_controllogic) = s&#39;.(st_controllogic)) -&gt;
  @HTLMonadExtra.collectlist A f l cs = OK tt cs&#39; ci -&gt; cs.(st_controllogic) = cs&#39;.(st_controllogic).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0)
  (<span class="nv">l</span> : list A) (<span class="nv">cs</span> <span class="nv">cs&#39;</span> : st) (<span class="nv">ci</span> : st_prop cs cs&#39;),
(<span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
   (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">y</span> : A),
 f y s = OK x s&#39; i -&gt;
 st_controllogic s = st_controllogic s&#39;) -&gt;
HTLMonadExtra.collectlist f l cs = OK tt cs&#39; ci -&gt;
st_controllogic cs = st_controllogic cs&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk30" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk30"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0)
  (<span class="nv">l</span> : list A) (<span class="nv">cs</span> <span class="nv">cs&#39;</span> : st) (<span class="nv">ci</span> : st_prop cs cs&#39;),
(<span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
   (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">y</span> : A),
 f y s = OK x s&#39; i -&gt;
 st_controllogic s = st_controllogic s&#39;) -&gt;
HTLMonadExtra.collectlist f l cs = OK tt cs&#39; ci -&gt;
st_controllogic cs = st_controllogic cs&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk31" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk31"><span class="highlight"><span class="nb">induction</span> l; <span class="nb">intros</span>; monadInv H0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cs'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ci</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs&#39; cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt;
st_controllogic s = st_controllogic s&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_controllogic cs&#39; = st_controllogic cs&#39;</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chk32" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">cs</span> <span class="nv">cs&#39;</span> : st) (<span class="nv">ci</span> : st_prop cs cs&#39;),
(<span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt; st_controllogic s = st_controllogic s&#39;) -&gt;
HTLMonadExtra.collectlist f l cs = OK tt cs&#39; ci -&gt;
st_controllogic cs = st_controllogic cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cs, cs'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ci</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt;
st_controllogic s = st_controllogic s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f a cs = OK x s INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist f l s =
OK tt cs&#39; INCR0</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chk32"><hr></label><div class="goal-conclusion"><span class="highlight">st_controllogic cs = st_controllogic cs&#39;</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk33" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk33"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cs'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ci</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs&#39; cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
  (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt;
st_controllogic s = st_controllogic s&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_controllogic cs&#39; = st_controllogic cs&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk34" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk34"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">cs</span> <span class="nv">cs&#39;</span> : st) (<span class="nv">ci</span> : st_prop cs cs&#39;),
(<span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
   (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
   (<span class="nv">y</span> : A),
 f y s = OK x s&#39; i -&gt;
 st_controllogic s = st_controllogic s&#39;) -&gt;
HTLMonadExtra.collectlist f l cs = OK tt cs&#39; ci -&gt;
st_controllogic cs = st_controllogic cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cs, cs'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ci</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
  (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt;
st_controllogic s = st_controllogic s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f a cs = OK x s INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist f l s =
OK tt cs&#39; INCR0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_controllogic cs = st_controllogic cs&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk35" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk35"><span class="highlight"><span class="nb">apply</span> H <span class="kr">in</span> EQ.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">cs</span> <span class="nv">cs&#39;</span> : st) (<span class="nv">ci</span> : st_prop cs cs&#39;),
(<span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
   (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
   (<span class="nv">y</span> : A),
 f y s = OK x s&#39; i -&gt;
 st_controllogic s = st_controllogic s&#39;) -&gt;
HTLMonadExtra.collectlist f l cs = OK tt cs&#39; ci -&gt;
st_controllogic cs = st_controllogic cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cs, cs'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ci</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
  (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt;
st_controllogic s = st_controllogic s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic cs = st_controllogic s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist f l s =
OK tt cs&#39; INCR0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_controllogic cs = st_controllogic cs&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk36" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk36"><span class="highlight"><span class="nb">rewrite</span> EQ.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">cs</span> <span class="nv">cs&#39;</span> : st) (<span class="nv">ci</span> : st_prop cs cs&#39;),
(<span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
   (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
   (<span class="nv">y</span> : A),
 f y s = OK x s&#39; i -&gt;
 st_controllogic s = st_controllogic s&#39;) -&gt;
HTLMonadExtra.collectlist f l cs = OK tt cs&#39; ci -&gt;
st_controllogic cs = st_controllogic cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cs, cs'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ci</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
  (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt;
st_controllogic s = st_controllogic s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic cs = st_controllogic s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist f l s =
OK tt cs&#39; INCR0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_controllogic s = st_controllogic cs&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">eauto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk37" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk37"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">collect_datapath_trans</span> :
  <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">f</span> <span class="nv">l</span> <span class="nv">cs</span> <span class="nv">cs&#39;</span> <span class="nv">ci</span>,
  (<span class="kr">forall</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">x</span> <span class="nv">i</span> <span class="nv">y</span>, f y s = OK x s&#39; i -&gt; s.(st_datapath) = s&#39;.(st_datapath)) -&gt;
  @HTLMonadExtra.collectlist A f l cs = OK tt cs&#39; ci -&gt; cs.(st_datapath) = cs&#39;.(st_datapath).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0)
  (<span class="nv">l</span> : list A) (<span class="nv">cs</span> <span class="nv">cs&#39;</span> : st) (<span class="nv">ci</span> : st_prop cs cs&#39;),
(<span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
   (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">y</span> : A),
 f y s = OK x s&#39; i -&gt; st_datapath s = st_datapath s&#39;) -&gt;
HTLMonadExtra.collectlist f l cs = OK tt cs&#39; ci -&gt;
st_datapath cs = st_datapath cs&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk38" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk38"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0)
  (<span class="nv">l</span> : list A) (<span class="nv">cs</span> <span class="nv">cs&#39;</span> : st) (<span class="nv">ci</span> : st_prop cs cs&#39;),
(<span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
   (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">y</span> : A),
 f y s = OK x s&#39; i -&gt; st_datapath s = st_datapath s&#39;) -&gt;
HTLMonadExtra.collectlist f l cs = OK tt cs&#39; ci -&gt;
st_datapath cs = st_datapath cs&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk39" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk39"><span class="highlight"><span class="nb">induction</span> l; <span class="nb">intros</span>; monadInv H0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cs'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ci</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs&#39; cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt;
st_datapath s = st_datapath s&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_datapath cs&#39; = st_datapath cs&#39;</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chk3a" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">cs</span> <span class="nv">cs&#39;</span> : st) (<span class="nv">ci</span> : st_prop cs cs&#39;),
(<span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt; st_datapath s = st_datapath s&#39;) -&gt;
HTLMonadExtra.collectlist f l cs = OK tt cs&#39; ci -&gt;
st_datapath cs = st_datapath cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cs, cs'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ci</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt;
st_datapath s = st_datapath s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f a cs = OK x s INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist f l s =
OK tt cs&#39; INCR0</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chk3a"><hr></label><div class="goal-conclusion"><span class="highlight">st_datapath cs = st_datapath cs&#39;</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk3b" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk3b"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cs'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ci</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs&#39; cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
  (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt;
st_datapath s = st_datapath s&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_datapath cs&#39; = st_datapath cs&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk3c" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk3c"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">cs</span> <span class="nv">cs&#39;</span> : st) (<span class="nv">ci</span> : st_prop cs cs&#39;),
(<span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
   (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
   (<span class="nv">y</span> : A),
 f y s = OK x s&#39; i -&gt;
 st_datapath s = st_datapath s&#39;) -&gt;
HTLMonadExtra.collectlist f l cs = OK tt cs&#39; ci -&gt;
st_datapath cs = st_datapath cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cs, cs'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ci</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
  (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt;
st_datapath s = st_datapath s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f a cs = OK x s INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist f l s =
OK tt cs&#39; INCR0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_datapath cs = st_datapath cs&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk3d" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk3d"><span class="highlight"><span class="nb">apply</span> H <span class="kr">in</span> EQ.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">cs</span> <span class="nv">cs&#39;</span> : st) (<span class="nv">ci</span> : st_prop cs cs&#39;),
(<span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
   (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
   (<span class="nv">y</span> : A),
 f y s = OK x s&#39; i -&gt;
 st_datapath s = st_datapath s&#39;) -&gt;
HTLMonadExtra.collectlist f l cs = OK tt cs&#39; ci -&gt;
st_datapath cs = st_datapath cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cs, cs'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ci</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
  (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt;
st_datapath s = st_datapath s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath cs = st_datapath s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist f l s =
OK tt cs&#39; INCR0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_datapath cs = st_datapath cs&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk3e" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk3e"><span class="highlight"><span class="nb">rewrite</span> EQ.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">cs</span> <span class="nv">cs&#39;</span> : st) (<span class="nv">ci</span> : st_prop cs cs&#39;),
(<span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
   (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
   (<span class="nv">y</span> : A),
 f y s = OK x s&#39; i -&gt;
 st_datapath s = st_datapath s&#39;) -&gt;
HTLMonadExtra.collectlist f l cs = OK tt cs&#39; ci -&gt;
st_datapath cs = st_datapath cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cs, cs'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ci</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
  (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt;
st_datapath s = st_datapath s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath cs = st_datapath s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist f l s =
OK tt cs&#39; INCR0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_datapath s = st_datapath cs&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">eauto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk3f" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk3f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">collect_freshreg_trans</span> :
  <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">f</span> <span class="nv">l</span> <span class="nv">cs</span> <span class="nv">cs&#39;</span> <span class="nv">ci</span>,
  (<span class="kr">forall</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">x</span> <span class="nv">i</span> <span class="nv">y</span>, f y s = OK x s&#39; i -&gt; s.(st_freshreg) = s&#39;.(st_freshreg)) -&gt;
  @HTLMonadExtra.collectlist A f l cs = OK tt cs&#39; ci -&gt; cs.(st_freshreg) = cs&#39;.(st_freshreg).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0)
  (<span class="nv">l</span> : list A) (<span class="nv">cs</span> <span class="nv">cs&#39;</span> : st) (<span class="nv">ci</span> : st_prop cs cs&#39;),
(<span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
   (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">y</span> : A),
 f y s = OK x s&#39; i -&gt; st_freshreg s = st_freshreg s&#39;) -&gt;
HTLMonadExtra.collectlist f l cs = OK tt cs&#39; ci -&gt;
st_freshreg cs = st_freshreg cs&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk40" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk40"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>)
  (<span class="nv">f</span> : A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0)
  (<span class="nv">l</span> : list A) (<span class="nv">cs</span> <span class="nv">cs&#39;</span> : st) (<span class="nv">ci</span> : st_prop cs cs&#39;),
(<span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
   (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">y</span> : A),
 f y s = OK x s&#39; i -&gt; st_freshreg s = st_freshreg s&#39;) -&gt;
HTLMonadExtra.collectlist f l cs = OK tt cs&#39; ci -&gt;
st_freshreg cs = st_freshreg cs&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk41" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk41"><span class="highlight"><span class="nb">induction</span> l; <span class="nb">intros</span>; monadInv H0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cs'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ci</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs&#39; cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg cs&#39; = st_freshreg cs&#39;</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chk42" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">cs</span> <span class="nv">cs&#39;</span> : st) (<span class="nv">ci</span> : st_prop cs cs&#39;),
(<span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt; st_freshreg s = st_freshreg s&#39;) -&gt;
HTLMonadExtra.collectlist f l cs = OK tt cs&#39; ci -&gt;
st_freshreg cs = st_freshreg cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cs, cs'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ci</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f a cs = OK x s INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist f l s =
OK tt cs&#39; INCR0</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chk42"><hr></label><div class="goal-conclusion"><span class="highlight">st_freshreg cs = st_freshreg cs&#39;</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk43" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk43"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cs'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ci</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs&#39; cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
  (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg cs&#39; = st_freshreg cs&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">trivial</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk44" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk44"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">cs</span> <span class="nv">cs&#39;</span> : st) (<span class="nv">ci</span> : st_prop cs cs&#39;),
(<span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
   (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
   (<span class="nv">y</span> : A),
 f y s = OK x s&#39; i -&gt;
 st_freshreg s = st_freshreg s&#39;) -&gt;
HTLMonadExtra.collectlist f l cs = OK tt cs&#39; ci -&gt;
st_freshreg cs = st_freshreg cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cs, cs'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ci</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
  (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f a cs = OK x s INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist f l s =
OK tt cs&#39; INCR0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg cs = st_freshreg cs&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk45" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk45"><span class="highlight"><span class="nb">apply</span> H <span class="kr">in</span> EQ.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">cs</span> <span class="nv">cs&#39;</span> : st) (<span class="nv">ci</span> : st_prop cs cs&#39;),
(<span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
   (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
   (<span class="nv">y</span> : A),
 f y s = OK x s&#39; i -&gt;
 st_freshreg s = st_freshreg s&#39;) -&gt;
HTLMonadExtra.collectlist f l cs = OK tt cs&#39; ci -&gt;
st_freshreg cs = st_freshreg cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cs, cs'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ci</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
  (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg cs = st_freshreg s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist f l s =
OK tt cs&#39; INCR0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg cs = st_freshreg cs&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk46" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk46"><span class="highlight"><span class="nb">rewrite</span> EQ.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kr">forall</span> <span class="nv">x0</span> : state, res unit x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">cs</span> <span class="nv">cs&#39;</span> : st) (<span class="nv">ci</span> : st_prop cs cs&#39;),
(<span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
   (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
   (<span class="nv">y</span> : A),
 f y s = OK x s&#39; i -&gt;
 st_freshreg s = st_freshreg s&#39;) -&gt;
HTLMonadExtra.collectlist f l cs = OK tt cs&#39; ci -&gt;
st_freshreg cs = st_freshreg cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cs, cs'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ci</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
  (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">y</span> : A),
f y s = OK x s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop cs s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s cs&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg cs = st_freshreg s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist f l s =
OK tt cs&#39; INCR0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg cs&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">eauto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk47" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk47"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">collect_declare_controllogic_trans</span> :
  <span class="kr">forall</span> <span class="nv">io</span> <span class="nv">n</span> <span class="nv">l</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">i</span>,
  HTLMonadExtra.collectlist (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) l s = OK tt s&#39; i -&gt;
  s.(st_controllogic) = s&#39;.(st_controllogic).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">io</span> : option io) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list reg)
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) l s = OK tt s&#39; i -&gt;
st_controllogic s = st_controllogic s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk48" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk48"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">io</span> : option io) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list reg)
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) l s = OK tt s&#39; i -&gt;
st_controllogic s = st_controllogic s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk49" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk49"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">io</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option Verilog.io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) l s =
OK tt s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_controllogic s = st_controllogic s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk4a" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk4a"><span class="highlight"><span class="nb">eapply</span> collect_controllogic_trans; <span class="kp">try</span> <span class="bp">eassumption</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">io</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option Verilog.io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) l s =
OK tt s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">y</span> : reg),
(<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) y s = OK x s&#39; i -&gt;
st_controllogic s = st_controllogic s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk4b" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk4b"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">io</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option Verilog.io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) l s =
OK tt s&#39; i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) y s0 =
OK x s&#39;0 i0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_controllogic s0 = st_controllogic s&#39;0</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">eapply</span> declare_reg_controllogic_trans.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> H0.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">eassumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk4c" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk4c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">collect_declare_datapath_trans</span> :
  <span class="kr">forall</span> <span class="nv">io</span> <span class="nv">n</span> <span class="nv">l</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">i</span>,
  HTLMonadExtra.collectlist (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) l s = OK tt s&#39; i -&gt;
  s.(st_datapath) = s&#39;.(st_datapath).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">io</span> : option io) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list reg)
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) l s = OK tt s&#39; i -&gt;
st_datapath s = st_datapath s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk4d" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk4d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">io</span> : option io) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list reg)
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) l s = OK tt s&#39; i -&gt;
st_datapath s = st_datapath s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk4e" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk4e"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">io</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option Verilog.io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) l s =
OK tt s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_datapath s = st_datapath s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk4f" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk4f"><span class="highlight"><span class="nb">eapply</span> collect_datapath_trans; <span class="kp">try</span> <span class="bp">eassumption</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">io</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option Verilog.io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) l s =
OK tt s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">y</span> : reg),
(<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) y s = OK x s&#39; i -&gt;
st_datapath s = st_datapath s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk50" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk50"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">io</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option Verilog.io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) l s =
OK tt s&#39; i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) y s0 =
OK x s&#39;0 i0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_datapath s0 = st_datapath s&#39;0</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">eapply</span> declare_reg_datapath_trans.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> H0.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">eassumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk51" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk51"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">collect_declare_freshreg_trans</span> :
  <span class="kr">forall</span> <span class="nv">io</span> <span class="nv">n</span> <span class="nv">l</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">i</span>,
  HTLMonadExtra.collectlist (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) l s = OK tt s&#39; i -&gt;
  s.(st_freshreg) = s&#39;.(st_freshreg).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">io</span> : option io) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list reg)
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) l s = OK tt s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk52" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk52"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">io</span> : option io) (<span class="nv">n</span> : nat) (<span class="nv">l</span> : list reg)
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) l s = OK tt s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk53" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk53"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">io</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option Verilog.io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) l s =
OK tt s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk54" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk54"><span class="highlight"><span class="nb">eapply</span> collect_freshreg_trans; <span class="kp">try</span> <span class="bp">eassumption</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">io</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option Verilog.io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) l s =
OK tt s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) (<span class="nv">x</span> : unit)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">y</span> : reg),
(<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) y s = OK x s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk55" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk55"><span class="highlight"><span class="nb">inversion</span> <span class="mi">1</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">io</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">option Verilog.io</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) l s =
OK tt s&#39; i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg io r n) y s0 =
OK x s&#39;0 i0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">tt = x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{|
st_st := st_st s0;
st_freshreg := st_freshreg s0;
st_freshstate := st_freshstate s0;
st_scldecls := AssocMap.<span class="nb">set</span> y (io, VScalar n)
                 (st_scldecls s0);
st_arrdecls := st_arrdecls s0;
st_datapath := st_datapath s0;
st_controllogic := st_controllogic s0 |} = s&#39;0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s0 =
st_freshreg
  {|
  st_st := st_st s0;
  st_freshreg := st_freshreg s0;
  st_freshstate := st_freshstate s0;
  st_scldecls := AssocMap.<span class="nb">set</span> y (io, VScalar n)
                   (st_scldecls s0);
  st_arrdecls := st_arrdecls s0;
  st_datapath := st_datapath s0;
  st_controllogic := st_controllogic s0 |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">unfold_match</span> H :=
  <span class="kr">match</span> <span class="kp">type of</span> H <span class="kr">with</span>
  | <span class="kp">context</span>[<span class="kr">match</span> <span class="nl">?g</span> <span class="kr">with</span> _ =&gt; _ <span class="kr">end</span>] =&gt; <span class="nb">destruct</span> g <span class="nb">eqn</span>:?; <span class="kp">try</span> <span class="bp">discriminate</span>
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk56" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk56"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">translate_eff_addressing_freshreg_trans</span> :
  <span class="kr">forall</span> <span class="nv">op</span> <span class="nv">args</span> <span class="nv">s</span> <span class="nv">r</span> <span class="nv">s&#39;</span> <span class="nv">i</span>,
  translate_eff_addressing op args s = OK r s&#39; i -&gt;
  s.(st_freshreg) = s&#39;.(st_freshreg).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">op</span> : Op.addressing) (<span class="nv">args</span> : list reg) (<span class="nv">s</span> : st)
  (<span class="nv">r</span> : expr) (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
translate_eff_addressing op args s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk57" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk57"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">op</span> : Op.addressing) (<span class="nv">args</span> : list reg) (<span class="nv">s</span> : st)
  (<span class="nv">r</span> : expr) (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
translate_eff_addressing op args s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> op; <span class="nb">intros</span>; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="kp">repeat</span> (unfold_match H); inv H; <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> translate_eff_addressing_freshreg_trans : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk58" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk58"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">translate_comparison_freshreg_trans</span> :
  <span class="kr">forall</span> <span class="nv">op</span> <span class="nv">args</span> <span class="nv">s</span> <span class="nv">r</span> <span class="nv">s&#39;</span> <span class="nv">i</span>,
  translate_comparison op args s = OK r s&#39; i -&gt;
  s.(st_freshreg) = s&#39;.(st_freshreg).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">op</span> : comparison) (<span class="nv">args</span> : list reg) (<span class="nv">s</span> : st)
  (<span class="nv">r</span> : expr) (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
translate_comparison op args s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk59" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk59"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">op</span> : comparison) (<span class="nv">args</span> : list reg) (<span class="nv">s</span> : st)
  (<span class="nv">r</span> : expr) (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
translate_comparison op args s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> op; <span class="nb">intros</span>; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="kp">repeat</span> (unfold_match H); inv H; <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> translate_comparison_freshreg_trans : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk5a" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk5a"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">translate_comparisonu_freshreg_trans</span> :
  <span class="kr">forall</span> <span class="nv">op</span> <span class="nv">args</span> <span class="nv">s</span> <span class="nv">r</span> <span class="nv">s&#39;</span> <span class="nv">i</span>,
  translate_comparisonu op args s = OK r s&#39; i -&gt;
  s.(st_freshreg) = s&#39;.(st_freshreg).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">op</span> : comparison) (<span class="nv">args</span> : list reg) (<span class="nv">s</span> : st)
  (<span class="nv">r</span> : expr) (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
translate_comparisonu op args s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk5b" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk5b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">op</span> : comparison) (<span class="nv">args</span> : list reg) (<span class="nv">s</span> : st)
  (<span class="nv">r</span> : expr) (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
translate_comparisonu op args s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> op; <span class="nb">intros</span>; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="kp">repeat</span> (unfold_match H); inv H; <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> translate_comparisonu_freshreg_trans : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk5c" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk5c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">translate_comparison_imm_freshreg_trans</span> :
  <span class="kr">forall</span> <span class="nv">op</span> <span class="nv">args</span> <span class="nv">s</span> <span class="nv">r</span> <span class="nv">s&#39;</span> <span class="nv">i</span> <span class="nv">n</span>,
  translate_comparison_imm op args n s = OK r s&#39; i -&gt;
  s.(st_freshreg) = s&#39;.(st_freshreg).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">op</span> : comparison) (<span class="nv">args</span> : list reg) (<span class="nv">s</span> : st)
  (<span class="nv">r</span> : expr) (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">n</span> : int),
translate_comparison_imm op args n s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk5d" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk5d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">op</span> : comparison) (<span class="nv">args</span> : list reg) (<span class="nv">s</span> : st)
  (<span class="nv">r</span> : expr) (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">n</span> : int),
translate_comparison_imm op args n s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> op; <span class="nb">intros</span>; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="kp">repeat</span> (unfold_match H); inv H; <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> translate_comparison_imm_freshreg_trans : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk5e" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk5e"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">translate_comparison_immu_freshreg_trans</span> :
  <span class="kr">forall</span> <span class="nv">op</span> <span class="nv">args</span> <span class="nv">s</span> <span class="nv">r</span> <span class="nv">s&#39;</span> <span class="nv">i</span> <span class="nv">n</span>,
  translate_comparison_immu op args n s = OK r s&#39; i -&gt;
  s.(st_freshreg) = s&#39;.(st_freshreg).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">op</span> : comparison) (<span class="nv">args</span> : list reg) (<span class="nv">s</span> : st)
  (<span class="nv">r</span> : expr) (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">n</span> : int),
translate_comparison_immu op args n s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk5f" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk5f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">op</span> : comparison) (<span class="nv">args</span> : list reg) (<span class="nv">s</span> : st)
  (<span class="nv">r</span> : expr) (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">n</span> : int),
translate_comparison_immu op args n s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> op; <span class="nb">intros</span>; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="kp">repeat</span> (unfold_match H); inv H; <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> translate_comparison_immu_freshreg_trans : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk60" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk60"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">translate_condition_freshreg_trans</span> :
  <span class="kr">forall</span> <span class="nv">op</span> <span class="nv">args</span> <span class="nv">s</span> <span class="nv">r</span> <span class="nv">s&#39;</span> <span class="nv">i</span>,
  translate_condition op args s = OK r s&#39; i -&gt;
  s.(st_freshreg) = s&#39;.(st_freshreg).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">op</span> : Op.condition) (<span class="nv">args</span> : list reg) (<span class="nv">s</span> : st)
  (<span class="nv">r</span> : expr) (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
translate_condition op args s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk61" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk61"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">op</span> : Op.condition) (<span class="nv">args</span> : list reg) (<span class="nv">s</span> : st)
  (<span class="nv">r</span> : expr) (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
translate_condition op args s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> op; <span class="nb">intros</span>; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="kp">repeat</span> (unfold_match H); inv H; <span class="nb">eauto with</span> htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> translate_condition_freshreg_trans : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk62" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk62"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">translate_instr_freshreg_trans</span> :
  <span class="kr">forall</span> <span class="nv">op</span> <span class="nv">args</span> <span class="nv">s</span> <span class="nv">r</span> <span class="nv">s&#39;</span> <span class="nv">i</span>,
  translate_instr op args s = OK r s&#39; i -&gt;
  s.(st_freshreg) = s&#39;.(st_freshreg).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">op</span> : Op.operation) (<span class="nv">args</span> : list reg) (<span class="nv">s</span> : st)
  (<span class="nv">r</span> : expr) (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
translate_instr op args s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk63" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk63"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">op</span> : Op.operation) (<span class="nv">args</span> : list reg) (<span class="nv">s</span> : st)
  (<span class="nv">r</span> : expr) (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
translate_instr op args s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk64" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk64"><span class="highlight"><span class="nb">destruct</span> op; <span class="nb">intros</span>; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="kp">repeat</span> (unfold_match H); inv H; <span class="nb">eauto with</span> htlspec.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.condition</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r0, r1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kp">do</span> tc &lt;- translate_condition c l0;
 ret (Vternary tc (Vvar r0) (Vvar r1))) s =
OK r s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk65" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk65"><span class="highlight">monadInv H1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.condition</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r0, r1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">translate_condition c l0 s = OK x s&#39; INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">eauto with</span> htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> translate_instr_freshreg_trans : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk66" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk66"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">translate_arr_access_freshreg_trans</span> :
  <span class="kr">forall</span> <span class="nv">mem</span> <span class="nv">addr</span> <span class="nv">args</span> <span class="nv">st</span> <span class="nv">s</span> <span class="nv">r</span> <span class="nv">s&#39;</span> <span class="nv">i</span>,
  translate_arr_access mem addr args st s = OK r s&#39; i -&gt;
  s.(st_freshreg) = s&#39;.(st_freshreg).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">mem</span> : AST.memory_chunk) (<span class="nv">addr</span> : Op.addressing)
  (<span class="nv">args</span> : list reg) (<span class="nv">st0</span> : reg) (<span class="nv">s</span> : st) (<span class="nv">r</span> : expr)
  (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
translate_arr_access mem addr args st0 s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk67" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk67"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">mem</span> : AST.memory_chunk) (<span class="nv">addr</span> : Op.addressing)
  (<span class="nv">args</span> : list reg) (<span class="nv">st0</span> : reg) (<span class="nv">s</span> : st) (<span class="nv">r</span> : expr)
  (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
translate_arr_access mem addr args st0 s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk68" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk68"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">mem</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AST.memory_chunk</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">addr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.addressing</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">args</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">translate_arr_access mem addr args st0 s =
OK r s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk69" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk69"><span class="highlight"><span class="nb">unfold</span> translate_arr_access <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">mem</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AST.memory_chunk</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">addr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.addressing</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">args</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> mem <span class="kr">with</span>
| AST.Mint32 =&gt;
    <span class="kr">match</span> addr <span class="kr">with</span>
    | Op.Aindexed off =&gt;
        <span class="kr">match</span> args <span class="kr">with</span>
        | nil =&gt;
            error
              (Errors.msg
                 <span class="s2">&quot;HTLgen: translate_arr_access unsuported addressing&quot;</span>)
        | r1 :: nil =&gt;
            <span class="kr">if</span> check_address_parameter_signed off
            <span class="kr">then</span>
             ret
               (Vvari st0
                  (Vbinop Vdivu
                     (boplitz Vadd r1 off)
                     (Vlit (ZToValue <span class="mi">4</span>))))
            <span class="kr">else</span>
             error
               (Errors.msg
                  <span class="s2">&quot;HTLgen: translate_arr_access address out of bounds&quot;</span>)
        | r1 :: _ :: _ =&gt;
            error
              (Errors.msg
                 <span class="s2">&quot;HTLgen: translate_arr_access unsuported addressing&quot;</span>)
        <span class="kr">end</span>
    | Op.Aindexed2scaled scale offset =&gt;
        <span class="kr">match</span> args <span class="kr">with</span>
        | nil =&gt;
            error
              (Errors.msg
                 <span class="s2">&quot;HTLgen: translate_arr_access unsuported addressing&quot;</span>)
        | r1 :: nil =&gt;
            error
              (Errors.msg
                 <span class="s2">&quot;HTLgen: translate_arr_access unsuported addressing&quot;</span>)
        | r1 :: r2 :: nil =&gt;
            <span class="kr">if</span>
             check_address_parameter_signed scale &amp;&amp;
             check_address_parameter_signed offset
            <span class="kr">then</span>
             ret
               (Vvari st0
                  (Vbinop Vdivu
                     (Vbinop Vadd
                        (boplitz Vadd r1 offset)
                        (boplitz Vmul r2 scale))
                     (Vlit (ZToValue <span class="mi">4</span>))))
            <span class="kr">else</span>
             error
               (Errors.msg
                  <span class="s2">&quot;HTLgen: translate_arr_access address out of bounds&quot;</span>)
        | r1 :: r2 :: _ :: _ =&gt;
            error
              (Errors.msg
                 <span class="s2">&quot;HTLgen: translate_arr_access unsuported addressing&quot;</span>)
        <span class="kr">end</span>
    | Op.Ainstack a =&gt;
        <span class="kr">match</span> args <span class="kr">with</span>
        | nil =&gt;
            <span class="kr">if</span>
             check_address_parameter_unsigned
               (Ptrofs.unsigned a)
            <span class="kr">then</span>
             ret
               (Vvari st0
                  (Vlit
                     (ZToValue
                        (Ptrofs.unsigned a / <span class="mi">4</span>))))
            <span class="kr">else</span>
             error
               (Errors.msg
                  <span class="s2">&quot;HTLgen: eff_addressing out of bounds stack offset&quot;</span>)
        | _ :: _ =&gt;
            error
              (Errors.msg
                 <span class="s2">&quot;HTLgen: translate_arr_access unsuported addressing&quot;</span>)
        <span class="kr">end</span>
    | _ =&gt;
        error
          (Errors.msg
             <span class="s2">&quot;HTLgen: translate_arr_access unsuported addressing&quot;</span>)
    <span class="kr">end</span>
| _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;HTLgen: translate_arr_access unsuported addressing&quot;</span>)
<span class="kr">end</span> s = OK r s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kp">repeat</span> (unfold_match H); inv H; <span class="nb">eauto with</span> htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> translate_arr_access_freshreg_trans : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk6a" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk6a"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">add_instr_freshreg_trans</span> :
  <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">n&#39;</span> <span class="nv">st</span> <span class="nv">s</span> <span class="nv">r</span> <span class="nv">s&#39;</span> <span class="nv">i</span>,
  add_instr n n&#39; st s = OK r s&#39; i -&gt;
  s.(st_freshreg) = s&#39;.(st_freshreg).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> <span class="nv">n&#39;</span> : node) (<span class="nv">st0</span> : stmnt) (<span class="nv">s</span> : st) (<span class="nv">r</span> : unit)
  (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
add_instr n n&#39; st0 s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk6b" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk6b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> <span class="nv">n&#39;</span> : node) (<span class="nv">st0</span> : stmnt) (<span class="nv">s</span> : st) (<span class="nv">r</span> : unit)
  (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
add_instr n n&#39; st0 s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk6c" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk6c"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, n'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">stmnt</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">add_instr n n&#39; st0 s = OK r s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk6d" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk6d"><span class="highlight"><span class="nb">unfold</span> add_instr <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, n'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">stmnt</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> check_empty_node_datapath s n <span class="kr">with</span>
| <span class="nb">left</span> STM =&gt;
    <span class="kr">match</span> check_empty_node_controllogic s n <span class="kr">with</span>
    | <span class="nb">left</span> TRANS =&gt;
        OK tt
          {|
          st_st := st_st s;
          st_freshreg := st_freshreg s;
          st_freshstate := st_freshstate s;
          st_scldecls := st_scldecls s;
          st_arrdecls := st_arrdecls s;
          st_datapath := AssocMap.<span class="nb">set</span> n st0
                           (st_datapath s);
          st_controllogic := AssocMap.<span class="nb">set</span> n
                               (state_goto
                                  (st_st s) n&#39;)
                               (st_controllogic s) |}
          (add_instr_state_incr s n n&#39; st0 STM
             TRANS)
    | <span class="nb">right</span> _ =&gt;
        Error (Errors.msg <span class="s2">&quot;HTL.add_instr&quot;</span>)
    <span class="kr">end</span>
| <span class="nb">right</span> _ =&gt; Error (Errors.msg <span class="s2">&quot;HTL.add_instr&quot;</span>)
<span class="kr">end</span> = OK r s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk6e" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk6e"><span class="highlight"><span class="kp">repeat</span> (unfold_match H).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, n'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">stmnt</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_datapath s) ! n = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_datapath s n = <span class="nb">left</span> e</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_controllogic s) ! n = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_controllogic s n = <span class="nb">left</span> e0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">OK tt
  {|
  st_st := st_st s;
  st_freshreg := st_freshreg s;
  st_freshstate := st_freshstate s;
  st_scldecls := st_scldecls s;
  st_arrdecls := st_arrdecls s;
  st_datapath := AssocMap.<span class="nb">set</span> n st0
                   (st_datapath s);
  st_controllogic := AssocMap.<span class="nb">set</span> n
                       (state_goto (st_st s) n&#39;)
                       (st_controllogic s) |}
  (add_instr_state_incr s n n&#39; st0 e e0) =
OK r s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk6f" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk6f"><span class="highlight">inv H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, n'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">stmnt</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s
  {|
  st_st := st_st s;
  st_freshreg := st_freshreg s;
  st_freshstate := st_freshstate s;
  st_scldecls := st_scldecls s;
  st_arrdecls := st_arrdecls s;
  st_datapath := AssocMap.<span class="nb">set</span> n st0
                   (st_datapath s);
  st_controllogic := AssocMap.<span class="nb">set</span> n
                       (state_goto (st_st s) n&#39;)
                       (st_controllogic s) |}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_datapath s) ! n = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_datapath s n = <span class="nb">left</span> e</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_controllogic s) ! n = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_controllogic s n = <span class="nb">left</span> e0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s =
st_freshreg
  {|
  st_st := st_st s;
  st_freshreg := st_freshreg s;
  st_freshstate := st_freshstate s;
  st_scldecls := st_scldecls s;
  st_arrdecls := st_arrdecls s;
  st_datapath := AssocMap.<span class="nb">set</span> n st0 (st_datapath s);
  st_controllogic := AssocMap.<span class="nb">set</span> n
                       (state_goto (st_st s) n&#39;)
                       (st_controllogic s) |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">auto</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> add_instr_freshreg_trans : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk70" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk70"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">add_branch_instr_freshreg_trans</span> :
  <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">n0</span> <span class="nv">n1</span> <span class="nv">e</span> <span class="nv">s</span> <span class="nv">r</span> <span class="nv">s&#39;</span> <span class="nv">i</span>,
  add_branch_instr e n n0 n1 s = OK r s&#39; i -&gt;
  s.(st_freshreg) = s&#39;.(st_freshreg).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> <span class="nv">n0</span> <span class="nv">n1</span> : node) (<span class="nv">e</span> : expr) (<span class="nv">s</span> : st) (<span class="nv">r</span> : unit)
  (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
add_branch_instr e n n0 n1 s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk71" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk71"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> <span class="nv">n0</span> <span class="nv">n1</span> : node) (<span class="nv">e</span> : expr) (<span class="nv">s</span> : st) (<span class="nv">r</span> : unit)
  (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
add_branch_instr e n n0 n1 s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk72" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk72"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, n0, n1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">add_branch_instr e n n0 n1 s = OK r s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk73" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk73"><span class="highlight"><span class="nb">unfold</span> add_branch_instr <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, n0, n1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> check_empty_node_datapath s n <span class="kr">with</span>
| <span class="nb">left</span> NSTM =&gt;
    <span class="kr">match</span> check_empty_node_controllogic s n <span class="kr">with</span>
    | <span class="nb">left</span> NTRANS =&gt;
        OK tt
          {|
          st_st := st_st s;
          st_freshreg := st_freshreg s;
          st_freshstate := st_freshstate s;
          st_scldecls := st_scldecls s;
          st_arrdecls := st_arrdecls s;
          st_datapath := AssocMap.<span class="nb">set</span> n Vskip
                           (st_datapath s);
          st_controllogic := AssocMap.<span class="nb">set</span> n
                               (state_cond
                                  (st_st s) e n0
                                  n1)
                               (st_controllogic s) |}
          (add_branch_instr_state_incr s e n n0 n1
             NSTM NTRANS)
    | <span class="nb">right</span> _ =&gt;
        Error
          (Errors.msg <span class="s2">&quot;Htlgen: add_branch_instr&quot;</span>)
    <span class="kr">end</span>
| <span class="nb">right</span> _ =&gt;
    Error (Errors.msg <span class="s2">&quot;Htlgen: add_branch_instr&quot;</span>)
<span class="kr">end</span> = OK r s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk74" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk74"><span class="highlight"><span class="kp">repeat</span> (unfold_match H).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, n0, n1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_datapath s) ! n = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_datapath s n = <span class="nb">left</span> e0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_controllogic s) ! n = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_controllogic s n = <span class="nb">left</span> e1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">OK tt
  {|
  st_st := st_st s;
  st_freshreg := st_freshreg s;
  st_freshstate := st_freshstate s;
  st_scldecls := st_scldecls s;
  st_arrdecls := st_arrdecls s;
  st_datapath := AssocMap.<span class="nb">set</span> n Vskip
                   (st_datapath s);
  st_controllogic := AssocMap.<span class="nb">set</span> n
                       (state_cond 
                       (st_st s) e n0 n1)
                       (st_controllogic s) |}
  (add_branch_instr_state_incr s e n n0 n1 e0 e1) =
OK r s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk75" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk75"><span class="highlight">inv H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, n0, n1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s
  {|
  st_st := st_st s;
  st_freshreg := st_freshreg s;
  st_freshstate := st_freshstate s;
  st_scldecls := st_scldecls s;
  st_arrdecls := st_arrdecls s;
  st_datapath := AssocMap.<span class="nb">set</span> n Vskip
                   (st_datapath s);
  st_controllogic := AssocMap.<span class="nb">set</span> n
                       (state_cond 
                       (st_st s) e n0 n1)
                       (st_controllogic s) |}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_datapath s) ! n = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_datapath s n = <span class="nb">left</span> e0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_controllogic s) ! n = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_controllogic s n = <span class="nb">left</span> e1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s =
st_freshreg
  {|
  st_st := st_st s;
  st_freshreg := st_freshreg s;
  st_freshstate := st_freshstate s;
  st_scldecls := st_scldecls s;
  st_arrdecls := st_arrdecls s;
  st_datapath := AssocMap.<span class="nb">set</span> n Vskip (st_datapath s);
  st_controllogic := AssocMap.<span class="nb">set</span> n
                       (state_cond (st_st s) e n0 n1)
                       (st_controllogic s) |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">auto</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> add_branch_instr_freshreg_trans : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk76" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk76"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">add_node_skip_freshreg_trans</span> :
  <span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">s</span> <span class="nv">r</span> <span class="nv">s&#39;</span> <span class="nv">i</span>,
  add_node_skip n1 n2 s = OK r s&#39; i -&gt;
  s.(st_freshreg) = s&#39;.(st_freshreg).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n1</span> : node) (<span class="nv">n2</span> : stmnt) (<span class="nv">s</span> : st) (<span class="nv">r</span> : unit)
  (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
add_node_skip n1 n2 s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk77" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk77"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n1</span> : node) (<span class="nv">n2</span> : stmnt) (<span class="nv">s</span> : st) (<span class="nv">r</span> : unit)
  (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
add_node_skip n1 n2 s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk78" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk78"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">stmnt</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">add_node_skip n1 n2 s = OK r s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk79" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk79"><span class="highlight"><span class="nb">unfold</span> add_node_skip <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">stmnt</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> check_empty_node_datapath s n1 <span class="kr">with</span>
| <span class="nb">left</span> STM =&gt;
    <span class="kr">match</span> check_empty_node_controllogic s n1 <span class="kr">with</span>
    | <span class="nb">left</span> TRANS =&gt;
        OK tt
          {|
          st_st := st_st s;
          st_freshreg := st_freshreg s;
          st_freshstate := st_freshstate s;
          st_scldecls := st_scldecls s;
          st_arrdecls := st_arrdecls s;
          st_datapath := AssocMap.<span class="nb">set</span> n1 Vskip
                           (st_datapath s);
          st_controllogic := AssocMap.<span class="nb">set</span> n1 n2
                               (st_controllogic s) |}
          (add_node_skip_state_incr s n1 n2 STM
             TRANS)
    | <span class="nb">right</span> _ =&gt;
        Error (Errors.msg <span class="s2">&quot;HTL.add_instr&quot;</span>)
    <span class="kr">end</span>
| <span class="nb">right</span> _ =&gt; Error (Errors.msg <span class="s2">&quot;HTL.add_instr&quot;</span>)
<span class="kr">end</span> = OK r s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk7a" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk7a"><span class="highlight"><span class="kp">repeat</span> (unfold_match H).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">stmnt</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_datapath s) ! n1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_datapath s n1 = <span class="nb">left</span> e</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_controllogic s) ! n1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_controllogic s n1 = <span class="nb">left</span> e0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">OK tt
  {|
  st_st := st_st s;
  st_freshreg := st_freshreg s;
  st_freshstate := st_freshstate s;
  st_scldecls := st_scldecls s;
  st_arrdecls := st_arrdecls s;
  st_datapath := AssocMap.<span class="nb">set</span> n1 Vskip
                   (st_datapath s);
  st_controllogic := AssocMap.<span class="nb">set</span> n1 n2
                       (st_controllogic s) |}
  (add_node_skip_state_incr s n1 n2 e e0) =
OK r s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk7b" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk7b"><span class="highlight">inv H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">stmnt</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s
  {|
  st_st := st_st s;
  st_freshreg := st_freshreg s;
  st_freshstate := st_freshstate s;
  st_scldecls := st_scldecls s;
  st_arrdecls := st_arrdecls s;
  st_datapath := AssocMap.<span class="nb">set</span> n1 Vskip
                   (st_datapath s);
  st_controllogic := AssocMap.<span class="nb">set</span> n1 n2
                       (st_controllogic s) |}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_datapath s) ! n1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_datapath s n1 = <span class="nb">left</span> e</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_controllogic s) ! n1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_controllogic s n1 = <span class="nb">left</span> e0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s =
st_freshreg
  {|
  st_st := st_st s;
  st_freshreg := st_freshreg s;
  st_freshstate := st_freshstate s;
  st_scldecls := st_scldecls s;
  st_arrdecls := st_arrdecls s;
  st_datapath := AssocMap.<span class="nb">set</span> n1 Vskip (st_datapath s);
  st_controllogic := AssocMap.<span class="nb">set</span> n1 n2
                       (st_controllogic s) |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">auto</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> add_node_skip_freshreg_trans : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk7c" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk7c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">add_instr_skip_freshreg_trans</span> :
  <span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">s</span> <span class="nv">r</span> <span class="nv">s&#39;</span> <span class="nv">i</span>,
  add_instr_skip n1 n2 s = OK r s&#39; i -&gt;
  s.(st_freshreg) = s&#39;.(st_freshreg).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n1</span> : node) (<span class="nv">n2</span> : stmnt) (<span class="nv">s</span> : st) (<span class="nv">r</span> : unit)
  (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
add_instr_skip n1 n2 s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk7d" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk7d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n1</span> : node) (<span class="nv">n2</span> : stmnt) (<span class="nv">s</span> : st) (<span class="nv">r</span> : unit)
  (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
add_instr_skip n1 n2 s = OK r s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk7e" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk7e"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">stmnt</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">add_instr_skip n1 n2 s = OK r s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk7f" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk7f"><span class="highlight"><span class="nb">unfold</span> add_instr_skip <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">stmnt</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> check_empty_node_datapath s n1 <span class="kr">with</span>
| <span class="nb">left</span> STM =&gt;
    <span class="kr">match</span> check_empty_node_controllogic s n1 <span class="kr">with</span>
    | <span class="nb">left</span> TRANS =&gt;
        OK tt
          {|
          st_st := st_st s;
          st_freshreg := st_freshreg s;
          st_freshstate := st_freshstate s;
          st_scldecls := st_scldecls s;
          st_arrdecls := st_arrdecls s;
          st_datapath := AssocMap.<span class="nb">set</span> n1 n2
                           (st_datapath s);
          st_controllogic := AssocMap.<span class="nb">set</span> n1 Vskip
                               (st_controllogic s) |}
          (add_instr_skip_state_incr s n1 n2 STM
             TRANS)
    | <span class="nb">right</span> _ =&gt;
        Error (Errors.msg <span class="s2">&quot;HTL.add_instr&quot;</span>)
    <span class="kr">end</span>
| <span class="nb">right</span> _ =&gt; Error (Errors.msg <span class="s2">&quot;HTL.add_instr&quot;</span>)
<span class="kr">end</span> = OK r s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk80" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk80"><span class="highlight"><span class="kp">repeat</span> (unfold_match H).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">stmnt</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_datapath s) ! n1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_datapath s n1 = <span class="nb">left</span> e</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_controllogic s) ! n1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_controllogic s n1 = <span class="nb">left</span> e0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">OK tt
  {|
  st_st := st_st s;
  st_freshreg := st_freshreg s;
  st_freshstate := st_freshstate s;
  st_scldecls := st_scldecls s;
  st_arrdecls := st_arrdecls s;
  st_datapath := AssocMap.<span class="nb">set</span> n1 n2
                   (st_datapath s);
  st_controllogic := AssocMap.<span class="nb">set</span> n1 Vskip
                       (st_controllogic s) |}
  (add_instr_skip_state_incr s n1 n2 e e0) =
OK r s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk81" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk81"><span class="highlight">inv H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">stmnt</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s
  {|
  st_st := st_st s;
  st_freshreg := st_freshreg s;
  st_freshstate := st_freshstate s;
  st_scldecls := st_scldecls s;
  st_arrdecls := st_arrdecls s;
  st_datapath := AssocMap.<span class="nb">set</span> n1 n2
                   (st_datapath s);
  st_controllogic := AssocMap.<span class="nb">set</span> n1 Vskip
                       (st_controllogic s) |}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_datapath s) ! n1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_datapath s n1 = <span class="nb">left</span> e</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_controllogic s) ! n1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_controllogic s n1 = <span class="nb">left</span> e0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s =
st_freshreg
  {|
  st_st := st_st s;
  st_freshreg := st_freshreg s;
  st_freshstate := st_freshstate s;
  st_scldecls := st_scldecls s;
  st_arrdecls := st_arrdecls s;
  st_datapath := AssocMap.<span class="nb">set</span> n1 n2 (st_datapath s);
  st_controllogic := AssocMap.<span class="nb">set</span> n1 Vskip
                       (st_controllogic s) |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">auto</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> add_instr_skip_freshreg_trans : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk82" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk82"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">transf_instr_freshreg_trans</span> :
  <span class="kr">forall</span> <span class="nv">fin</span> <span class="nv">ret</span> <span class="nv">st</span> <span class="nv">instr</span> <span class="nv">s</span> <span class="nv">v</span> <span class="nv">s&#39;</span> <span class="nv">i</span>,
    transf_instr fin ret st instr s = OK v s&#39; i -&gt;
    s.(st_freshreg) = s&#39;.(st_freshreg).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">ret</span> <span class="nv">st0</span> : reg)
  (<span class="nv">instr</span> : node * RTL.instruction) (<span class="nv">s</span> : st) (<span class="nv">v</span> : unit)
  (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
transf_instr fin ret st0 instr s = OK v s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk83" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk83"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">ret</span> <span class="nv">st0</span> : reg)
  (<span class="nv">instr</span> : node * RTL.instruction) (<span class="nv">s</span> : st) (<span class="nv">v</span> : unit)
  (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
transf_instr fin ret st0 instr s = OK v s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk84" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk84"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(node * RTL.instruction)%type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">transf_instr fin ret0 st0 instr s = OK v s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk85" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk85"><span class="highlight"><span class="nb">destruct</span> instr <span class="nb">eqn</span>:?.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(node * RTL.instruction)%type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqp</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">instr = (n, i0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">transf_instr fin ret0 st0 (n, i0) s = OK v s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk86" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk86"><span class="highlight"><span class="nb">subst</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">transf_instr fin ret0 st0 (n, i0) s = OK v s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk87" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk87"><span class="highlight"><span class="nb">unfold</span> transf_instr <span class="kr">in</span> H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> i0 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr n n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr n n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args st0;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr n n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args st0;
     add_instr n n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e n n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip n
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block ret0 (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip n
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block ret0 (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s = OK v s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk88" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk88"><span class="highlight"><span class="nb">destruct</span> i0; <span class="kp">try</span> (monadInv H); <span class="kp">try</span> (unfold_match H); <span class="nb">eauto with</span> htlspec.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.operation</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kp">do</span> instr &lt;- translate_instr o l;
 <span class="kp">do</span> _ &lt;- declare_reg None r <span class="mi">32</span>;
 add_instr n n0 (nonblock r instr)) s = 
OK v s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chk89" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AST.memory_chunk</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.addressing</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kp">do</span> src &lt;- translate_arr_access m a l st0;
 <span class="kp">do</span> _ &lt;- declare_reg None r <span class="mi">32</span>;
 add_instr n n0 (nonblock r src)) s = 
OK v s&#39; i</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chk89"><hr></label><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote><input class="coq-extra-goal-toggle" id="htlgenspec-v-chk8a" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AST.memory_chunk</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.addressing</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kp">do</span> dst &lt;- translate_arr_access m a l st0;
 add_instr n n0 (Vnonblock dst (Vvar r))) s =
OK v s&#39; i</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chk8a"><hr></label><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote><input class="coq-extra-goal-toggle" id="htlgenspec-v-chk8b" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.condition</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0, n1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) &amp;&amp;
(Z.pos n1 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kp">do</span> e &lt;- translate_condition c l;
 add_branch_instr e n n0 n1) s = 
OK v s&#39; i</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chk8b"><hr></label><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk8c" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk8c"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.operation</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kp">do</span> instr &lt;- translate_instr o l;
 <span class="kp">do</span> _ &lt;- declare_reg None r <span class="mi">32</span>;
 add_instr n n0 (nonblock r instr)) s = 
OK v s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk8d" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk8d"><span class="highlight">monadInv H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.operation</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">translate_instr o l s = OK x s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">declare_reg None r <span class="mi">32</span> s0 = OK x0 s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">add_instr n n0 (nonblock r x) s1 = OK v s&#39; INCR2</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk8e" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk8e"><span class="highlight"><span class="nb">apply</span> add_instr_freshreg_trans <span class="kr">in</span> EQ2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.operation</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">translate_instr o l s = OK x s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">declare_reg None r <span class="mi">32</span> s0 = OK x0 s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = st_freshreg s&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk8f" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk8f"><span class="highlight"><span class="nb">apply</span> translate_instr_freshreg_trans <span class="kr">in</span> EQ.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.operation</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s = st_freshreg s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">declare_reg None r <span class="mi">32</span> s0 = OK x0 s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = st_freshreg s&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk90" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk90"><span class="highlight"><span class="nb">apply</span> declare_reg_freshreg_trans <span class="kr">in</span> EQ1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.operation</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s = st_freshreg s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 = st_freshreg s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = st_freshreg s&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk91" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk91"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AST.memory_chunk</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.addressing</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kp">do</span> src &lt;- translate_arr_access m a l st0;
 <span class="kp">do</span> _ &lt;- declare_reg None r <span class="mi">32</span>;
 add_instr n n0 (nonblock r src)) s = 
OK v s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk92" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk92"><span class="highlight">monadInv H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AST.memory_chunk</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.addressing</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">translate_arr_access m a l st0 s = OK x s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">declare_reg None r <span class="mi">32</span> s0 = OK x0 s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">add_instr n n0 (nonblock r x) s1 = OK v s&#39; INCR2</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk93" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk93"><span class="highlight"><span class="nb">apply</span> add_instr_freshreg_trans <span class="kr">in</span> EQ2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AST.memory_chunk</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.addressing</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">translate_arr_access m a l st0 s = OK x s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">declare_reg None r <span class="mi">32</span> s0 = OK x0 s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = st_freshreg s&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk94" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk94"><span class="highlight"><span class="nb">apply</span> translate_arr_access_freshreg_trans <span class="kr">in</span> EQ.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AST.memory_chunk</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.addressing</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s = st_freshreg s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">declare_reg None r <span class="mi">32</span> s0 = OK x0 s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = st_freshreg s&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk95" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk95"><span class="highlight"><span class="nb">apply</span> declare_reg_freshreg_trans <span class="kr">in</span> EQ1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AST.memory_chunk</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.addressing</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s = st_freshreg s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 = st_freshreg s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = st_freshreg s&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk96" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk96"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AST.memory_chunk</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.addressing</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kp">do</span> dst &lt;- translate_arr_access m a l st0;
 add_instr n n0 (Vnonblock dst (Vvar r))) s =
OK v s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk97" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk97"><span class="highlight">monadInv H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AST.memory_chunk</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.addressing</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">translate_arr_access m a l st0 s = OK x s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">add_instr n n0 (Vnonblock x (Vvar r)) s0 =
OK v s&#39; INCR0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk98" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk98"><span class="highlight"><span class="nb">apply</span> add_instr_freshreg_trans <span class="kr">in</span> EQ0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AST.memory_chunk</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.addressing</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">translate_arr_access m a l st0 s = OK x s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 = st_freshreg s&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk99" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk99"><span class="highlight"><span class="nb">apply</span> translate_arr_access_freshreg_trans <span class="kr">in</span> EQ.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AST.memory_chunk</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.addressing</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s = st_freshreg s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 = st_freshreg s&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk9a" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk9a"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.condition</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0, n1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) &amp;&amp;
(Z.pos n1 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kp">do</span> e &lt;- translate_condition c l;
 add_branch_instr e n n0 n1) s = 
OK v s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk9b" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk9b"><span class="highlight">monadInv H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.condition</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0, n1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) &amp;&amp;
(Z.pos n1 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">translate_condition c l s = OK x s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">add_branch_instr x n n0 n1 s0 = OK v s&#39; INCR0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk9c" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk9c"><span class="highlight"><span class="nb">apply</span> translate_condition_freshreg_trans <span class="kr">in</span> EQ.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.condition</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0, n1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) &amp;&amp;
(Z.pos n1 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s = st_freshreg s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">add_branch_instr x n n0 n1 s0 = OK v s&#39; INCR0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk9d" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk9d"><span class="highlight"><span class="nb">apply</span> add_branch_instr_freshreg_trans <span class="kr">in</span> EQ0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Op.condition</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list Registers.reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n0, n1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Z.pos n0 &lt;=? Int.max_unsigned) &amp;&amp;
(Z.pos n1 &lt;=? Int.max_unsigned) = true</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">expr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s = st_freshreg s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 = st_freshreg s&#39;</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">  <span class="c">(*- inv EQ. apply add_node_skip_freshreg_trans in EQ0. congruence.*)</span>
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> transf_instr_freshreg_trans : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk9e" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk9e"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">collect_trans_instr_freshreg_trans</span> :
  <span class="kr">forall</span> <span class="nv">fin</span> <span class="nv">ret</span> <span class="nv">st</span> <span class="nv">l</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">i</span>,
  HTLMonadExtra.collectlist (transf_instr fin ret st) l s = OK tt s&#39; i -&gt;
  s.(st_freshreg) = s&#39;.(st_freshreg).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">ret</span> <span class="nv">st0</span> : reg)
  (<span class="nv">l</span> : list (node * RTL.instruction)) (<span class="nv">s</span> <span class="nv">s&#39;</span> : st)
  (<span class="nv">i</span> : st_prop s s&#39;),
HTLMonadExtra.collectlist (transf_instr fin ret st0) l
  s = OK tt s&#39; i -&gt; st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk9f" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk9f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">ret</span> <span class="nv">st0</span> : reg)
  (<span class="nv">l</span> : list (node * RTL.instruction)) (<span class="nv">s</span> <span class="nv">s&#39;</span> : st)
  (<span class="nv">i</span> : st_prop s s&#39;),
HTLMonadExtra.collectlist (transf_instr fin ret st0) l
  s = OK tt s&#39; i -&gt; st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chka0" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chka0"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin ret0 st0) l s = 
OK tt s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chka1" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chka1"><span class="highlight"><span class="nb">eapply</span> collect_freshreg_trans; <span class="kp">try</span> <span class="bp">eassumption</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">fin, ret0, st0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin ret0 st0) l s = 
OK tt s&#39; i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">s</span> : state) (<span class="nv">s&#39;</span> : st) 
  (<span class="nv">x</span> : unit) (<span class="nv">i</span> : st_prop s s&#39;)
  (<span class="nv">y</span> : node * RTL.instruction),
transf_instr fin ret0 st0 y s = OK x s&#39; i -&gt;
st_freshreg s = st_freshreg s&#39;</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">eauto with</span> htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">rewrite_states</span> :=
  <span class="kr">match goal with</span>
  | [ H: <span class="nl">?x</span> <span class="nl">?s</span> = <span class="nl">?x</span> <span class="nl">?s&#39;</span> |- _ ] =&gt;
    <span class="kr">let</span> <span class="nv">c1</span> := <span class="kp">fresh</span> <span class="s2">&quot;c&quot;</span> <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">c2</span> := <span class="kp">fresh</span> <span class="s2">&quot;c&quot;</span> <span class="kr">in</span>
    <span class="nb">remember</span> (<span class="nl">?x</span> <span class="nl">?s</span>) <span class="kr">as</span> c1; <span class="nb">remember</span> (<span class="nl">?x</span> <span class="nl">?s&#39;</span>) <span class="kr">as</span> c2; <span class="kp">try</span> <span class="nb">subst</span>
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">inv_add_instr&#39;</span> H :=
  <span class="kr">match</span> <span class="kp">type of</span> H <span class="kr">with</span>
  | <span class="nl">?f</span> _ _ = OK _ _ _ =&gt; <span class="nb">unfold</span> f <span class="kr">in</span> H
  | <span class="nl">?f</span> _ _ _ = OK _ _ _ =&gt; <span class="nb">unfold</span> f <span class="kr">in</span> H
  | <span class="nl">?f</span> _ _ _ _ = OK _ _ _ =&gt; <span class="nb">unfold</span> f <span class="kr">in</span> H
  | <span class="nl">?f</span> _ _ _ _ _ = OK _ _ _ =&gt; <span class="nb">unfold</span> f <span class="kr">in</span> H
  | <span class="nl">?f</span> _ _ _ _ _ _ = OK _ _ _ =&gt; <span class="nb">unfold</span> f <span class="kr">in</span> H
  <span class="kr">end</span>; <span class="kp">repeat</span> unfold_match H; <span class="nb">inversion</span> H.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">inv_add_instr</span> :=
  <span class="kr">match goal with</span>
  | H: (<span class="kr">if</span> <span class="nl">?c</span> <span class="kr">then</span> _ <span class="kr">else</span> _) _ = OK _ _ _ |- _ =&gt; <span class="nb">destruct</span> c <span class="nb">eqn</span>:EQN; <span class="kp">try</span> <span class="bp">discriminate</span>; inv_add_instr
  | H: <span class="kp">context</span>[add_instr_skip _ _ _] |- _ =&gt;
    inv_add_instr&#39; H
  | H: <span class="kp">context</span>[add_instr_skip _ _] |- _ =&gt;
    monadInv H; inv_incr; inv_add_instr
  | H: <span class="kp">context</span>[add_instr _ _ _ _] |- _ =&gt;
    inv_add_instr&#39; H
  | H: <span class="kp">context</span>[add_instr _ _ _] |- _ =&gt;
    monadInv H; inv_incr; inv_add_instr
  | H: <span class="kp">context</span>[add_branch_instr _ _ _ _ _] |- _ =&gt;
    inv_add_instr&#39; H
  | H: <span class="kp">context</span>[add_branch_instr _ _ _ _] |- _ =&gt;
    monadInv H; inv_incr; inv_add_instr
  | H: <span class="kp">context</span>[add_node_skip _ _ _] |- _ =&gt;
    inv_add_instr&#39; H
  | H: <span class="kp">context</span>[add_node_skip _ _] |- _ =&gt;
    monadInv H; inv_incr; inv_add_instr
  <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">destruct_optional</span> :=
  <span class="kr">match goal with</span> H: option <span class="nl">?r</span> |- _ =&gt; <span class="nb">destruct</span> H <span class="kr">end</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chka2" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chka2"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">iter_expand_instr_spec</span> :
  <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> <span class="nv">s</span> <span class="nv">s&#39;</span> <span class="nv">i</span> <span class="nv">x</span> <span class="nv">c</span>,
    HTLMonadExtra.collectlist (transf_instr fin rtrn stack) l s = OK x s&#39; i -&gt;
    list_norepet (List.map fst l) -&gt;
    (<span class="kr">forall</span> <span class="nv">pc</span> <span class="nv">instr</span>, In (pc, instr) l -&gt; c!pc = Some instr) -&gt;
    (<span class="kr">forall</span> <span class="nv">pc</span> <span class="nv">instr</span>, In (pc, instr) l -&gt;
                      c!pc = Some instr -&gt;
                      tr_code c pc instr s&#39;.(st_datapath) s&#39;.(st_controllogic) fin rtrn s&#39;.(st_st) stack).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">l</span> : list (node * RTL.instruction))
  (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) (<span class="nv">s</span> <span class="nv">s&#39;</span> : st)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">x</span> : unit)
  (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn (st_st s&#39;) stack</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chka3" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chka3"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">l</span> : list (node * RTL.instruction))
  (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) (<span class="nv">s</span> <span class="nv">s&#39;</span> : st)
  (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">x</span> : unit)
  (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn (st_st s&#39;) stack</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chka4" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chka4"><span class="highlight"><span class="nb">induction</span> l; <span class="nb">simpl</span>; <span class="nb">intros</span>; <span class="kp">try</span> <span class="bp">contradiction</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(node * RTL.instruction)%type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) (<span class="nv">x</span> : unit)
(<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist (transf_instr fin rtrn stack) l s = OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;) (st_controllogic s&#39;) fin rtrn (st_st s&#39;)
stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kp">do</span> _ &lt;- transf_instr fin rtrn stack a;
 HTLMonadExtra.collectlist
   (transf_instr fin rtrn stack) l) s = 
OK x s&#39; i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (fst a :: map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
a = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn (st_st s&#39;) stack</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chka5" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chka5"><span class="highlight"><span class="nb">destruct</span> a <span class="kr">as</span> [pc1 instr1]; <span class="nb">simpl</span> <span class="kr">in</span> *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kp">do</span> _ &lt;-
 <span class="kr">match</span> instr1 <span class="kr">with</span>
 | RTL.Inop n&#39; =&gt;
     <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
     <span class="kr">then</span> add_instr pc1 n&#39; Vskip
     <span class="kr">else</span>
      error
        (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
 | RTL.Iop op args dst n&#39; =&gt;
     <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
     <span class="kr">then</span>
      <span class="kp">do</span> instr &lt;- translate_instr op args;
      <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
      add_instr pc1 n&#39; (nonblock dst instr)
     <span class="kr">else</span>
      error
        (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
 | RTL.Iload mem addr args dst n&#39; =&gt;
     <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
     <span class="kr">then</span>
      <span class="kp">do</span> src &lt;-
      translate_arr_access mem addr args stack;
      <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
      add_instr pc1 n&#39; (nonblock dst src)
     <span class="kr">else</span>
      error
        (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
 | RTL.Istore mem addr args src n&#39; =&gt;
     <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
     <span class="kr">then</span>
      <span class="kp">do</span> dst &lt;-
      translate_arr_access mem addr args stack;
      add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
     <span class="kr">else</span>
      error
        (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
 | RTL.Icall _ _ _ _ _ =&gt;
     error
       (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
 | RTL.Itailcall _ _ _ =&gt;
     error
       (Errors.msg
          <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
 | RTL.Ibuiltin _ _ _ _ =&gt;
     error
       (Errors.msg
          <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
 | RTL.Icond cond args n1 n2 =&gt;
     <span class="kr">if</span>
      (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
      (Z.pos n2 &lt;=? Int.max_unsigned)
     <span class="kr">then</span>
      <span class="kp">do</span> e &lt;- translate_condition cond args;
      add_branch_instr e pc1 n1 n2
     <span class="kr">else</span>
      error
        (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
 | RTL.Ijumptable _ _ =&gt;
     error
       (Errors.msg
          <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
 | RTL.Ireturn (Some r&#39;) =&gt;
     add_instr_skip pc1
       (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
          (block rtrn (Vvar r&#39;)))
 | RTL.Ireturn None =&gt;
     add_instr_skip pc1
       (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
          (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
 <span class="kr">end</span>;
 HTLMonadExtra.collectlist
   (transf_instr fin rtrn stack) l) s = 
OK x s&#39; i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (pc1 :: map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chka6" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chka6"><span class="highlight">inv H0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kp">do</span> _ &lt;-
 <span class="kr">match</span> instr1 <span class="kr">with</span>
 | RTL.Inop n&#39; =&gt;
     <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
     <span class="kr">then</span> add_instr pc1 n&#39; Vskip
     <span class="kr">else</span>
      error
        (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
 | RTL.Iop op args dst n&#39; =&gt;
     <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
     <span class="kr">then</span>
      <span class="kp">do</span> instr &lt;- translate_instr op args;
      <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
      add_instr pc1 n&#39; (nonblock dst instr)
     <span class="kr">else</span>
      error
        (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
 | RTL.Iload mem addr args dst n&#39; =&gt;
     <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
     <span class="kr">then</span>
      <span class="kp">do</span> src &lt;-
      translate_arr_access mem addr args stack;
      <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
      add_instr pc1 n&#39; (nonblock dst src)
     <span class="kr">else</span>
      error
        (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
 | RTL.Istore mem addr args src n&#39; =&gt;
     <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
     <span class="kr">then</span>
      <span class="kp">do</span> dst &lt;-
      translate_arr_access mem addr args stack;
      add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
     <span class="kr">else</span>
      error
        (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
 | RTL.Icall _ _ _ _ _ =&gt;
     error
       (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
 | RTL.Itailcall _ _ _ =&gt;
     error
       (Errors.msg
          <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
 | RTL.Ibuiltin _ _ _ _ =&gt;
     error
       (Errors.msg
          <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
 | RTL.Icond cond args n1 n2 =&gt;
     <span class="kr">if</span>
      (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
      (Z.pos n2 &lt;=? Int.max_unsigned)
     <span class="kr">then</span>
      <span class="kp">do</span> e &lt;- translate_condition cond args;
      add_branch_instr e pc1 n1 n2
     <span class="kr">else</span>
      error
        (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
 | RTL.Ijumptable _ _ =&gt;
     error
       (Errors.msg
          <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
 | RTL.Ireturn (Some r&#39;) =&gt;
     add_instr_skip pc1
       (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
          (block rtrn (Vvar r&#39;)))
 | RTL.Ireturn None =&gt;
     add_instr_skip pc1
       (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
          (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
 <span class="kr">end</span>;
 HTLMonadExtra.collectlist
   (transf_instr fin rtrn stack) l) s = 
OK x s&#39; i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chka7" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chka7"><span class="highlight">monadInv H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s, s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s = OK x0 s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s&#39; INCR0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chka8" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chka8"><span class="highlight">inv_incr.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_code c pc instr (st_datapath s2)
  (st_controllogic s2) fin rtrn 
  (st_st s2) stack</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chka9" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chka9"><span class="highlight"><span class="nb">destruct</span> (peq pc pc1).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc = pc1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_code c pc instr (st_datapath s2)
  (st_controllogic s2) fin rtrn 
  (st_st s2) stack</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkaa" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkaa"><hr></label><div class="goal-conclusion"><span class="highlight">tr_code c pc instr (st_datapath s2)
  (st_controllogic s2) fin rtrn 
  (st_st s2) stack</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkab" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkab"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc = pc1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_code c pc instr (st_datapath s2)
  (st_controllogic s2) fin rtrn 
  (st_st s2) stack</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkac" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkac"><span class="highlight"><span class="nb">subst</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc1 = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc1, instr) \/ In (pc1, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_code c pc1 instr (st_datapath s2)
  (st_controllogic s2) fin rtrn 
  (st_st s2) stack</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> instr1 <span class="nb">eqn</span>:?; <span class="kp">try</span> <span class="bp">discriminate</span>;
      <span class="kp">try</span> destruct_optional; inv_add_instr; <span class="nb">econstructor</span>; <span class="kp">try</span> <span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">+</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> o <span class="kr">with</span> pc1; <span class="nb">destruct</span> H11; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">rewrite</span> AssocMap.gss <span class="kr">in</span> H9; <span class="nb">eauto</span>; <span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">+</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> o0 <span class="kr">with</span> pc1; <span class="nb">destruct</span> H11; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">rewrite</span> AssocMap.gss <span class="kr">in</span> H9; <span class="nb">eauto</span>; <span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">+</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion</span> H2.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion</span> H9.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">rewrite</span> H.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> tr_instr_Inop.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> Z.leb_le.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">eapply</span> in_map <span class="kr">with</span> (f := fst) <span class="kr">in</span> H9.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">contradiction</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">+</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> o <span class="kr">with</span> pc1; <span class="nb">destruct</span> H16; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">rewrite</span> AssocMap.gss <span class="kr">in</span> H14; <span class="nb">eauto</span>; <span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">+</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> o0 <span class="kr">with</span> pc1; <span class="nb">destruct</span> H16; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">rewrite</span> AssocMap.gss <span class="kr">in</span> H14; <span class="nb">eauto</span>; <span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">+</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion</span> H2.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion</span> H14.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">unfold</span> nonblock.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">replace</span> (st_st s4) <span class="kr">with</span> (st_st s2) <span class="bp">by</span> <span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">econstructor</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> Z.leb_le; <span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> EQ1.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">eapply</span> in_map <span class="kr">with</span> (f := fst) <span class="kr">in</span> H14.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">contradiction</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">+</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> o <span class="kr">with</span> pc1; <span class="nb">destruct</span> H16; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">rewrite</span> AssocMap.gss <span class="kr">in</span> H14; <span class="nb">eauto</span>; <span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">+</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> o0 <span class="kr">with</span> pc1; <span class="nb">destruct</span> H16; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">rewrite</span> AssocMap.gss <span class="kr">in</span> H14; <span class="nb">eauto</span>; <span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">+</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion</span> H2.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion</span> H14.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">rewrite</span> &lt;- e2.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">replace</span> (st_st s2) <span class="kr">with</span> (st_st s0) <span class="bp">by</span> <span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">econstructor</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> Z.leb_le; <span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> EQ1.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">eapply</span> in_map <span class="kr">with</span> (f := fst) <span class="kr">in</span> H14.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">contradiction</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">+</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> o <span class="kr">with</span> pc1; <span class="nb">destruct</span> H11; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">rewrite</span> AssocMap.gss <span class="kr">in</span> H9; <span class="nb">eauto</span>; <span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">+</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> o0 <span class="kr">with</span> pc1; <span class="nb">destruct</span> H11; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">rewrite</span> AssocMap.gss <span class="kr">in</span> H9; <span class="nb">eauto</span>; <span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">+</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> H2.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">*</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion</span> H2.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">        </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">replace</span> (st_st s2) <span class="kr">with</span> (st_st s0) <span class="bp">by</span> <span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">        </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">econstructor</span>.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> Z.leb_le; <span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">        </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">eauto with</span> htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">*</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> in_map <span class="kr">with</span> (f := fst) <span class="kr">in</span> H2.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">contradiction</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">+</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> o <span class="kr">with</span> pc1; <span class="nb">destruct</span> H11; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">rewrite</span> AssocMap.gss <span class="kr">in</span> H9; <span class="nb">eauto</span>; <span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">+</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> o0 <span class="kr">with</span> pc1; <span class="nb">destruct</span> H11; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">rewrite</span> AssocMap.gss <span class="kr">in</span> H9; <span class="nb">eauto</span>; <span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">+</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> H2.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">*</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion</span> H2.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">        </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">replace</span> (st_st s2) <span class="kr">with</span> (st_st s0) <span class="bp">by</span> <span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">        </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">econstructor</span>; <span class="kp">try</span> (<span class="nb">apply</span> Z.leb_le; <span class="nb">apply</span> andb_prop <span class="kr">in</span> EQN; <span class="nb">apply</span> EQN).</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">        </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">eauto with</span> htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">*</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> in_map <span class="kr">with</span> (f := fst) <span class="kr">in</span> H2.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">contradiction</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
    <span class="c">(*+ destruct o with pc1; destruct H16; simpl in *; rewrite AssocMap.gss in H14; eauto; congruence.</span>
<span class="c">    + destruct o0 with pc1; destruct H16; simpl in *; rewrite AssocMap.gss in H14; eauto; congruence.</span>
<span class="c">    + inversion H2.</span>
<span class="c">      * inversion H14. constructor. congruence.</span>
<span class="c">      * apply in_map with (f := fst) in H14. contradiction.</span>
<span class="c">      *)</span>
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">+</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> o <span class="kr">with</span> pc1; <span class="nb">destruct</span> H11; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">rewrite</span> AssocMap.gss <span class="kr">in</span> H9; <span class="nb">eauto</span>; <span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">+</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> o0 <span class="kr">with</span> pc1; <span class="nb">destruct</span> H11; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">rewrite</span> AssocMap.gss <span class="kr">in</span> H9; <span class="nb">eauto</span>; <span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">+</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion</span> H2.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">*</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion</span> H9.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">        </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">replace</span> (st_st s2) <span class="kr">with</span> (st_st s0) <span class="bp">by</span> <span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">        </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">eauto with</span> htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">*</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> in_map <span class="kr">with</span> (f := fst) <span class="kr">in</span> H9.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">contradiction</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">+</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> o <span class="kr">with</span> pc1; <span class="nb">destruct</span> H11; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">rewrite</span> AssocMap.gss <span class="kr">in</span> H9; <span class="nb">eauto</span>; <span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><span class="coq-input"><span class="highlight">+</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">destruct</span> o0 <span class="kr">with</span> pc1; <span class="nb">destruct</span> H11; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">rewrite</span> AssocMap.gss <span class="kr">in</span> H9; <span class="nb">eauto</span>; <span class="bp">congruence</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkad" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkad"><span class="highlight">+</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">instr1 = RTL.Ireturn None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, RTL.Ireturn None) = (pc, instr) \/
In (pc, instr) l -&gt; c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc1 = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, RTL.Ireturn None) = (pc1, instr) \/
In (pc1, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_datapath s1) ! pc1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_datapath s1 pc1 = <span class="nb">left</span> e1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_controllogic s1) ! pc1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_controllogic s1 pc1 = <span class="nb">left</span> e2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">OK tt
  {|
  st_st := st_st s1;
  st_freshreg := st_freshreg s1;
  st_freshstate := st_freshstate s1;
  st_scldecls := st_scldecls s1;
  st_arrdecls := st_arrdecls s1;
  st_datapath := AssocMap.<span class="nb">set</span> pc1
                   (Vseq
                      (block fin
                       (Vlit (ZToValue <span class="mi">1</span>)))
                      (block rtrn
                       (Vlit (ZToValue <span class="mi">0</span>))))
                   (st_datapath s1);
  st_controllogic := AssocMap.<span class="nb">set</span> pc1 Vskip
                       (st_controllogic s1) |}
  (add_instr_skip_state_incr s1 pc1
     (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
        (block rtrn (Vlit (ZToValue <span class="mi">0</span>)))) e1 e2) =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">tt = x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{|
st_st := st_st s1;
st_freshreg := st_freshreg s1;
st_freshstate := st_freshstate s1;
st_scldecls := st_scldecls s1;
st_arrdecls := st_arrdecls s1;
st_datapath := AssocMap.<span class="nb">set</span> pc1
                 (Vseq
                    (block fin
                       (Vlit (ZToValue <span class="mi">1</span>)))
                    (block rtrn
                       (Vlit (ZToValue <span class="mi">0</span>))))
                 (st_datapath s1);
st_controllogic := AssocMap.<span class="nb">set</span> pc1 Vskip
                     (st_controllogic s1) |} =
s0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_instr fin rtrn (st_st s2) stack instr
  (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
     (block rtrn (Vlit (ZToValue <span class="mi">0</span>)))) Vskip</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkae" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkae"><span class="highlight"><span class="nb">inversion</span> H2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">instr1 = RTL.Ireturn None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, RTL.Ireturn None) = (pc, instr) \/
In (pc, instr) l -&gt; c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc1 = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, RTL.Ireturn None) = (pc1, instr) \/
In (pc1, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_datapath s1) ! pc1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_datapath s1 pc1 = <span class="nb">left</span> e1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_controllogic s1) ! pc1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_controllogic s1 pc1 = <span class="nb">left</span> e2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">OK tt
  {|
  st_st := st_st s1;
  st_freshreg := st_freshreg s1;
  st_freshstate := st_freshstate s1;
  st_scldecls := st_scldecls s1;
  st_arrdecls := st_arrdecls s1;
  st_datapath := AssocMap.<span class="nb">set</span> pc1
                   (Vseq
                      (block fin
                       (Vlit (ZToValue <span class="mi">1</span>)))
                      (block rtrn
                       (Vlit (ZToValue <span class="mi">0</span>))))
                   (st_datapath s1);
  st_controllogic := AssocMap.<span class="nb">set</span> pc1 Vskip
                       (st_controllogic s1) |}
  (add_instr_skip_state_incr s1 pc1
     (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
        (block rtrn (Vlit (ZToValue <span class="mi">0</span>)))) e1 e2) =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">tt = x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{|
st_st := st_st s1;
st_freshreg := st_freshreg s1;
st_freshstate := st_freshstate s1;
st_scldecls := st_scldecls s1;
st_arrdecls := st_arrdecls s1;
st_datapath := AssocMap.<span class="nb">set</span> pc1
                 (Vseq
                    (block fin
                       (Vlit (ZToValue <span class="mi">1</span>)))
                    (block rtrn
                       (Vlit (ZToValue <span class="mi">0</span>))))
                 (st_datapath s1);
st_controllogic := AssocMap.<span class="nb">set</span> pc1 Vskip
                     (st_controllogic s1) |} =
s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, RTL.Ireturn None) = (pc1, instr)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_instr fin rtrn (st_st s2) stack instr
  (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
     (block rtrn (Vlit (ZToValue <span class="mi">0</span>)))) Vskip</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkaf" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">instr1 = RTL.Ireturn None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, RTL.Ireturn None) = (pc, instr) \/
In (pc, instr) l -&gt; c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc1 = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, RTL.Ireturn None) = (pc1, instr) \/
In (pc1, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_datapath s1) ! pc1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_datapath s1 pc1 = <span class="nb">left</span> e1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_controllogic s1) ! pc1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_controllogic s1 pc1 = <span class="nb">left</span> e2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">OK tt
  {|
  st_st := st_st s1;
  st_freshreg := st_freshreg s1;
  st_freshstate := st_freshstate s1;
  st_scldecls := st_scldecls s1;
  st_arrdecls := st_arrdecls s1;
  st_datapath := AssocMap.<span class="nb">set</span> pc1
                   (Vseq
                      (block fin
                       (Vlit (ZToValue <span class="mi">1</span>)))
                      (block rtrn
                       (Vlit (ZToValue <span class="mi">0</span>))))
                   (st_datapath s1);
  st_controllogic := AssocMap.<span class="nb">set</span> pc1 Vskip
                       (st_controllogic s1) |}
  (add_instr_skip_state_incr s1 pc1
     (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
        (block rtrn (Vlit (ZToValue <span class="mi">0</span>)))) e1 e2) =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">tt = x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{|
st_st := st_st s1;
st_freshreg := st_freshreg s1;
st_freshstate := st_freshstate s1;
st_scldecls := st_scldecls s1;
st_arrdecls := st_arrdecls s1;
st_datapath := AssocMap.<span class="nb">set</span> pc1
                 (Vseq
                    (block fin
                       (Vlit (ZToValue <span class="mi">1</span>)))
                    (block rtrn
                       (Vlit (ZToValue <span class="mi">0</span>))))
                 (st_datapath s1);
st_controllogic := AssocMap.<span class="nb">set</span> pc1 Vskip
                     (st_controllogic s1) |} =
s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (pc1, instr) l</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkaf"><hr></label><div class="goal-conclusion"><span class="highlight">tr_instr fin rtrn (st_st s2) stack instr
  (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
     (block rtrn (Vlit (ZToValue <span class="mi">0</span>)))) Vskip</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkb0" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkb0"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">instr1 = RTL.Ireturn None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, RTL.Ireturn None) = (pc, instr) \/
In (pc, instr) l -&gt; c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc1 = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, RTL.Ireturn None) = (pc1, instr) \/
In (pc1, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_datapath s1) ! pc1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_datapath s1 pc1 = <span class="nb">left</span> e1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_controllogic s1) ! pc1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_controllogic s1 pc1 = <span class="nb">left</span> e2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">OK tt
  {|
  st_st := st_st s1;
  st_freshreg := st_freshreg s1;
  st_freshstate := st_freshstate s1;
  st_scldecls := st_scldecls s1;
  st_arrdecls := st_arrdecls s1;
  st_datapath := AssocMap.<span class="nb">set</span> pc1
                   (Vseq
                      (block fin
                       (Vlit (ZToValue <span class="mi">1</span>)))
                      (block rtrn
                       (Vlit (ZToValue <span class="mi">0</span>))))
                   (st_datapath s1);
  st_controllogic := AssocMap.<span class="nb">set</span> pc1 Vskip
                       (st_controllogic s1) |}
  (add_instr_skip_state_incr s1 pc1
     (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
        (block rtrn (Vlit (ZToValue <span class="mi">0</span>)))) e1 e2) =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">tt = x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{|
st_st := st_st s1;
st_freshreg := st_freshreg s1;
st_freshstate := st_freshstate s1;
st_scldecls := st_scldecls s1;
st_arrdecls := st_arrdecls s1;
st_datapath := AssocMap.<span class="nb">set</span> pc1
                 (Vseq
                    (block fin
                       (Vlit (ZToValue <span class="mi">1</span>)))
                    (block rtrn
                       (Vlit (ZToValue <span class="mi">0</span>))))
                 (st_datapath s1);
st_controllogic := AssocMap.<span class="nb">set</span> pc1 Vskip
                     (st_controllogic s1) |} =
s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, RTL.Ireturn None) = (pc1, instr)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_instr fin rtrn (st_st s2) stack instr
  (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
     (block rtrn (Vlit (ZToValue <span class="mi">0</span>)))) Vskip</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkb1" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkb1"><span class="highlight"><span class="nb">inversion</span> H9.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">instr1 = RTL.Ireturn None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, RTL.Ireturn None) = (pc, instr) \/
In (pc, instr) l -&gt; c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc1 = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, RTL.Ireturn None) = (pc1, instr) \/
In (pc1, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_datapath s1) ! pc1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_datapath s1 pc1 = <span class="nb">left</span> e1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_controllogic s1) ! pc1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_controllogic s1 pc1 = <span class="nb">left</span> e2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">OK tt
  {|
  st_st := st_st s1;
  st_freshreg := st_freshreg s1;
  st_freshstate := st_freshstate s1;
  st_scldecls := st_scldecls s1;
  st_arrdecls := st_arrdecls s1;
  st_datapath := AssocMap.<span class="nb">set</span> pc1
                   (Vseq
                      (block fin
                       (Vlit (ZToValue <span class="mi">1</span>)))
                      (block rtrn
                       (Vlit (ZToValue <span class="mi">0</span>))))
                   (st_datapath s1);
  st_controllogic := AssocMap.<span class="nb">set</span> pc1 Vskip
                       (st_controllogic s1) |}
  (add_instr_skip_state_incr s1 pc1
     (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
        (block rtrn (Vlit (ZToValue <span class="mi">0</span>)))) e1 e2) =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">tt = x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{|
st_st := st_st s1;
st_freshreg := st_freshreg s1;
st_freshstate := st_freshstate s1;
st_scldecls := st_scldecls s1;
st_arrdecls := st_arrdecls s1;
st_datapath := AssocMap.<span class="nb">set</span> pc1
                 (Vseq
                    (block fin
                       (Vlit (ZToValue <span class="mi">1</span>)))
                    (block rtrn
                       (Vlit (ZToValue <span class="mi">0</span>))))
                 (st_datapath s1);
st_controllogic := AssocMap.<span class="nb">set</span> pc1 Vskip
                     (st_controllogic s1) |} =
s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, RTL.Ireturn None) = (pc1, instr)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.Ireturn None = instr</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_instr fin rtrn (st_st s2) stack 
  (RTL.Ireturn None)
  (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
     (block rtrn (Vlit (ZToValue <span class="mi">0</span>)))) Vskip</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">        </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkb2" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkb2"><span class="highlight"><span class="nb">replace</span> (st_st s2) <span class="kr">with</span> (st_st s0) <span class="bp">by</span> <span class="bp">congruence</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">instr1 = RTL.Ireturn None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, RTL.Ireturn None) = (pc, instr) \/
In (pc, instr) l -&gt; c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc1 = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, RTL.Ireturn None) = (pc1, instr) \/
In (pc1, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_datapath s1) ! pc1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_datapath s1 pc1 = <span class="nb">left</span> e1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_controllogic s1) ! pc1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_controllogic s1 pc1 = <span class="nb">left</span> e2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">OK tt
  {|
  st_st := st_st s1;
  st_freshreg := st_freshreg s1;
  st_freshstate := st_freshstate s1;
  st_scldecls := st_scldecls s1;
  st_arrdecls := st_arrdecls s1;
  st_datapath := AssocMap.<span class="nb">set</span> pc1
                   (Vseq
                      (block fin
                       (Vlit (ZToValue <span class="mi">1</span>)))
                      (block rtrn
                       (Vlit (ZToValue <span class="mi">0</span>))))
                   (st_datapath s1);
  st_controllogic := AssocMap.<span class="nb">set</span> pc1 Vskip
                       (st_controllogic s1) |}
  (add_instr_skip_state_incr s1 pc1
     (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
        (block rtrn (Vlit (ZToValue <span class="mi">0</span>)))) e1 e2) =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">tt = x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{|
st_st := st_st s1;
st_freshreg := st_freshreg s1;
st_freshstate := st_freshstate s1;
st_scldecls := st_scldecls s1;
st_arrdecls := st_arrdecls s1;
st_datapath := AssocMap.<span class="nb">set</span> pc1
                 (Vseq
                    (block fin
                       (Vlit (ZToValue <span class="mi">1</span>)))
                    (block rtrn
                       (Vlit (ZToValue <span class="mi">0</span>))))
                 (st_datapath s1);
st_controllogic := AssocMap.<span class="nb">set</span> pc1 Vskip
                     (st_controllogic s1) |} =
s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, RTL.Ireturn None) = (pc1, instr)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.Ireturn None = instr</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_instr fin rtrn (st_st s0) stack 
  (RTL.Ireturn None)
  (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
     (block rtrn (Vlit (ZToValue <span class="mi">0</span>)))) Vskip</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">        </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">eauto with</span> htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp">      </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkb3" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkb3"><span class="highlight">*</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">instr1 = RTL.Ireturn None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, RTL.Ireturn None) = (pc, instr) \/
In (pc, instr) l -&gt; c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc1 = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, RTL.Ireturn None) = (pc1, instr) \/
In (pc1, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_datapath s1) ! pc1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_datapath s1 pc1 = <span class="nb">left</span> e1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_controllogic s1) ! pc1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_controllogic s1 pc1 = <span class="nb">left</span> e2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">OK tt
  {|
  st_st := st_st s1;
  st_freshreg := st_freshreg s1;
  st_freshstate := st_freshstate s1;
  st_scldecls := st_scldecls s1;
  st_arrdecls := st_arrdecls s1;
  st_datapath := AssocMap.<span class="nb">set</span> pc1
                   (Vseq
                      (block fin
                       (Vlit (ZToValue <span class="mi">1</span>)))
                      (block rtrn
                       (Vlit (ZToValue <span class="mi">0</span>))))
                   (st_datapath s1);
  st_controllogic := AssocMap.<span class="nb">set</span> pc1 Vskip
                       (st_controllogic s1) |}
  (add_instr_skip_state_incr s1 pc1
     (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
        (block rtrn (Vlit (ZToValue <span class="mi">0</span>)))) e1 e2) =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">tt = x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{|
st_st := st_st s1;
st_freshreg := st_freshreg s1;
st_freshstate := st_freshstate s1;
st_scldecls := st_scldecls s1;
st_arrdecls := st_arrdecls s1;
st_datapath := AssocMap.<span class="nb">set</span> pc1
                 (Vseq
                    (block fin
                       (Vlit (ZToValue <span class="mi">1</span>)))
                    (block rtrn
                       (Vlit (ZToValue <span class="mi">0</span>))))
                 (st_datapath s1);
st_controllogic := AssocMap.<span class="nb">set</span> pc1 Vskip
                     (st_controllogic s1) |} =
s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (pc1, instr) l</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_instr fin rtrn (st_st s2) stack instr
  (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
     (block rtrn (Vlit (ZToValue <span class="mi">0</span>)))) Vskip</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkb4" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkb4"><span class="highlight"><span class="nb">apply</span> in_map <span class="kr">with</span> (f := fst) <span class="kr">in</span> H9.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">instr1 = RTL.Ireturn None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, RTL.Ireturn None) = (pc, instr) \/
In (pc, instr) l -&gt; c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc1 = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, RTL.Ireturn None) = (pc1, instr) \/
In (pc1, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_datapath s1) ! pc1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_datapath s1 pc1 = <span class="nb">left</span> e1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(st_controllogic s1) ! pc1 = None</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">check_empty_node_controllogic s1 pc1 = <span class="nb">left</span> e2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">OK tt
  {|
  st_st := st_st s1;
  st_freshreg := st_freshreg s1;
  st_freshstate := st_freshstate s1;
  st_scldecls := st_scldecls s1;
  st_arrdecls := st_arrdecls s1;
  st_datapath := AssocMap.<span class="nb">set</span> pc1
                   (Vseq
                      (block fin
                       (Vlit (ZToValue <span class="mi">1</span>)))
                      (block rtrn
                       (Vlit (ZToValue <span class="mi">0</span>))))
                   (st_datapath s1);
  st_controllogic := AssocMap.<span class="nb">set</span> pc1 Vskip
                       (st_controllogic s1) |}
  (add_instr_skip_state_incr s1 pc1
     (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
        (block rtrn (Vlit (ZToValue <span class="mi">0</span>)))) e1 e2) =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">tt = x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{|
st_st := st_st s1;
st_freshreg := st_freshreg s1;
st_freshstate := st_freshstate s1;
st_scldecls := st_scldecls s1;
st_arrdecls := st_arrdecls s1;
st_datapath := AssocMap.<span class="nb">set</span> pc1
                 (Vseq
                    (block fin
                       (Vlit (ZToValue <span class="mi">1</span>)))
                    (block rtrn
                       (Vlit (ZToValue <span class="mi">0</span>))))
                 (st_datapath s1);
st_controllogic := AssocMap.<span class="nb">set</span> pc1 Vskip
                     (st_controllogic s1) |} =
s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (fst (pc1, instr)) (map fst l)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_instr fin rtrn (st_st s2) stack instr
  (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
     (block rtrn (Vlit (ZToValue <span class="mi">0</span>)))) Vskip</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">contradiction</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkb5" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkb5"><span class="highlight">-</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_code c pc instr (st_datapath s2)
  (st_controllogic s2) fin rtrn 
  (st_st s2) stack</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">eapply</span> IHl.</span></span><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkb6" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkb6"><span class="highlight"><span class="nb">apply</span> EQ0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">list_norepet (map fst l)</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkb7" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkb7"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt; c ! pc = Some instr</span></div></blockquote><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkb8" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkb8"><hr></label><div class="goal-conclusion"><span class="highlight">In (pc, instr) l</span></div></blockquote><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkb9" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkb9"><hr></label><div class="goal-conclusion"><span class="highlight">c ! pc = Some instr</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkba" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkba"><span class="highlight"><span class="bp">assumption</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt; c ! pc = Some instr</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkbb" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkbb"><hr></label><div class="goal-conclusion"><span class="highlight">In (pc, instr) l</span></div></blockquote><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkbc" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkbc"><hr></label><div class="goal-conclusion"><span class="highlight">c ! pc = Some instr</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkbd" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkbd"><span class="highlight"><span class="nb">destruct</span> H2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt; c ! pc = Some instr</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkbe" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkbe"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt; c ! pc = Some instr</span></div></blockquote><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkbf" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkbf"><hr></label><div class="goal-conclusion"><span class="highlight">In (pc, instr) l</span></div></blockquote><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkc0" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkc0"><hr></label><div class="goal-conclusion"><span class="highlight">c ! pc = Some instr</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkc1" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkc1"><span class="highlight"><span class="nb">inversion</span> H2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc1 = pc</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">instr1 = instr</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt; c ! pc = Some instr</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkc2" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkc2"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt; c ! pc = Some instr</span></div></blockquote><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkc3" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkc3"><hr></label><div class="goal-conclusion"><span class="highlight">In (pc, instr) l</span></div></blockquote><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkc4" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkc4"><hr></label><div class="goal-conclusion"><span class="highlight">c ! pc = Some instr</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkc5" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkc5"><span class="highlight"><span class="nb">subst</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc, instr) = (pc, instr)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc0</span> : node) (<span class="nv">instr0</span> : RTL.instruction),
(pc, instr) = (pc0, instr0) \/ In (pc0, instr0) l -&gt;
c ! pc0 = Some instr0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt; c ! pc = Some instr</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkc6" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkc6"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt; c ! pc = Some instr</span></div></blockquote><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkc7" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkc7"><hr></label><div class="goal-conclusion"><span class="highlight">In (pc, instr) l</span></div></blockquote><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkc8" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkc8"><hr></label><div class="goal-conclusion"><span class="highlight">c ! pc = Some instr</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkc9" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkc9"><span class="highlight"><span class="bp">contradiction</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt; c ! pc = Some instr</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkca" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkca"><hr></label><div class="goal-conclusion"><span class="highlight">In (pc, instr) l</span></div></blockquote><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkcb" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkcb"><hr></label><div class="goal-conclusion"><span class="highlight">c ! pc = Some instr</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkcc" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkcc"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (pc0, instr0) l</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">c ! pc0 = Some instr0</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkcd" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkcd"><hr></label><div class="goal-conclusion"><span class="highlight">In (pc, instr) l</span></div></blockquote><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkce" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkce"><hr></label><div class="goal-conclusion"><span class="highlight">c ! pc = Some instr</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkcf" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkcf"><span class="highlight"><span class="nb">specialize</span> H1 <span class="kr">with</span> pc0 instr0.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc0, instr0) \/
In (pc0, instr0) l -&gt; c ! pc0 = Some instr0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (pc0, instr0) l</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">c ! pc0 = Some instr0</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkd0" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkd0"><hr></label><div class="goal-conclusion"><span class="highlight">In (pc, instr) l</span></div></blockquote><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkd1" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkd1"><hr></label><div class="goal-conclusion"><span class="highlight">c ! pc = Some instr</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkd2" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkd2"><span class="highlight"><span class="nb">destruct</span> H1.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (pc0, instr0) l</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(pc1, instr1) = (pc0, instr0) \/ In (pc0, instr0) l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkd3" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (pc0, instr0) l</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkd3"><hr></label><div class="goal-conclusion"><span class="highlight">c ! pc0 = c ! pc0</span></div></blockquote><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkd4" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkd4"><hr></label><div class="goal-conclusion"><span class="highlight">In (pc, instr) l</span></div></blockquote><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkd5" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkd5"><hr></label><div class="goal-conclusion"><span class="highlight">c ! pc = Some instr</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkd6" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkd6"><span class="highlight"><span class="bp">tauto</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (pc0, instr0) l</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">c ! pc0 = c ! pc0</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkd7" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkd7"><hr></label><div class="goal-conclusion"><span class="highlight">In (pc, instr) l</span></div></blockquote><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkd8" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkd8"><hr></label><div class="goal-conclusion"><span class="highlight">c ! pc = Some instr</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkd9" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkd9"><span class="highlight"><span class="nb">trivial</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In (pc, instr) l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkda" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkda"><hr></label><div class="goal-conclusion"><span class="highlight">c ! pc = Some instr</span></div></blockquote></div></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">    </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkdb" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkdb"><span class="highlight"><span class="nb">destruct</span> H2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In (pc, instr) l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkdc" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkdc"><hr></label><div class="goal-conclusion"><span class="highlight">In (pc, instr) l</span></div></blockquote><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkdd" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkdd"><hr></label><div class="goal-conclusion"><span class="highlight">c ! pc = Some instr</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkde" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkde"><span class="highlight">inv H2.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc0</span> : node) (<span class="nv">instr0</span> : RTL.instruction),
(pc, instr) = (pc0, instr0) \/ In (pc0, instr0) l -&gt;
c ! pc0 = Some instr0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In (pc, instr) l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chkdf" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chkdf"><hr></label><div class="goal-conclusion"><span class="highlight">In (pc, instr) l</span></div></blockquote><input class="coq-extra-goal-toggle" id="htlgenspec-v-chke0" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chke0"><hr></label><div class="goal-conclusion"><span class="highlight">c ! pc = Some instr</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chke1" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chke1"><span class="highlight"><span class="bp">contradiction</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In (pc, instr) l</span></div></blockquote><div class="coq-extra-goals"><input class="coq-extra-goal-toggle" id="htlgenspec-v-chke2" style="display: none" type="checkbox"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><label class="goal-separator coq-extra-goal-label" for="htlgenspec-v-chke2"><hr></label><div class="goal-conclusion"><span class="highlight">c ! pc = Some instr</span></div></blockquote></div></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chke3" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chke3"><span class="highlight"><span class="bp">assumption</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">pc1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (node * RTL.instruction)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">fin</span> <span class="nv">rtrn</span> <span class="nv">stack</span> : reg) 
  (<span class="nv">s</span> <span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;) 
  (<span class="nv">x</span> : unit) (<span class="nv">c</span> : PTree.t RTL.instruction),
HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s = 
OK x s&#39; i -&gt;
list_norepet (map fst l) -&gt;
(<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
 In (pc, instr) l -&gt; c ! pc = Some instr) -&gt;
<span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) l -&gt;
c ! pc = Some instr -&gt;
tr_code c pc instr (st_datapath s&#39;)
  (st_controllogic s&#39;) fin rtrn 
  (st_st s&#39;) stack</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fin, rtrn, stack</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s2) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">PTree.t RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
(pc1, instr1) = (pc, instr) \/ In (pc, instr) l -&gt;
c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">node</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">instr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(pc1, instr1) = (pc, instr) \/ In (pc, instr) l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">c ! pc = Some instr</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ In pc1 (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list_norepet (map fst l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s0) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span> instr1 <span class="kr">with</span>
| RTL.Inop n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span> add_instr pc1 n&#39; Vskip
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iop op args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> instr &lt;- translate_instr op args;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst instr)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Iload mem addr args dst n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> src &lt;-
     translate_arr_access mem addr args stack;
     <span class="kp">do</span> _ &lt;- declare_reg None dst <span class="mi">32</span>;
     add_instr pc1 n&#39; (nonblock dst src)
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Istore mem addr args src n&#39; =&gt;
    <span class="kr">if</span> Z.pos n&#39; &lt;=? Int.max_unsigned
    <span class="kr">then</span>
     <span class="kp">do</span> dst &lt;-
     translate_arr_access mem addr args stack;
     add_instr pc1 n&#39; (Vnonblock dst (Vvar src))
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Icall _ _ _ _ _ =&gt;
    error
      (Errors.msg <span class="s2">&quot;Calls are not implemented.&quot;</span>)
| RTL.Itailcall _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Tailcalls are not implemented.&quot;</span>)
| RTL.Ibuiltin _ _ _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Builtin functions not implemented.&quot;</span>)
| RTL.Icond cond args n1 n2 =&gt;
    <span class="kr">if</span>
     (Z.pos n1 &lt;=? Int.max_unsigned) &amp;&amp;
     (Z.pos n2 &lt;=? Int.max_unsigned)
    <span class="kr">then</span>
     <span class="kp">do</span> e &lt;- translate_condition cond args;
     add_branch_instr e pc1 n1 n2
    <span class="kr">else</span>
     error
       (Errors.msg <span class="s2">&quot;State is larger than 2^32.&quot;</span>)
| RTL.Ijumptable _ _ =&gt;
    error
      (Errors.msg
         <span class="s2">&quot;Ijumptable: Case statement not supported.&quot;</span>)
| RTL.Ireturn (Some r&#39;) =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vvar r&#39;)))
| RTL.Ireturn None =&gt;
    add_instr_skip pc1
      (Vseq (block fin (Vlit (ZToValue <span class="mi">1</span>)))
         (block rtrn (Vlit (ZToValue <span class="mi">0</span>))))
<span class="kr">end</span> s1 =
OK x0 s0 (state_incr_intro s1 s0 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr fin rtrn stack) l s0 =
OK x s2 (state_incr_intro s0 s2 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pc &lt;&gt; pc1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">c ! pc = Some instr</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Hint Resolve</span> iter_expand_instr_spec : htlspec.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chke4" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chke4"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">create_arr_inv</span> : <span class="kr">forall</span> <span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span>,
    create_arr w x y z = OK (a, b) c d -&gt;
    y = b /\ a = z.(st_freshreg) /\ c.(st_freshreg) = Pos.succ (z.(st_freshreg)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">w</span> : option io) (<span class="nv">x</span> <span class="nv">y</span> : nat) (<span class="nv">z</span> : st) (<span class="nv">a</span> : reg)
  (<span class="nv">b</span> : nat) (<span class="nv">c</span> : st) (<span class="nv">d</span> : st_prop z c),
create_arr w x y z = OK (a, b) c d -&gt;
y = b /\
a = st_freshreg z /\
st_freshreg c = Pos.succ (st_freshreg z)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chke5" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chke5"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">w</span> : option io) (<span class="nv">x</span> <span class="nv">y</span> : nat) (<span class="nv">z</span> : st) (<span class="nv">a</span> : reg)
  (<span class="nv">b</span> : nat) (<span class="nv">c</span> : st) (<span class="nv">d</span> : st_prop z c),
create_arr w x y z = OK (a, b) c d -&gt;
y = b /\
a = st_freshreg z /\
st_freshreg c = Pos.succ (st_freshreg z)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion</span> <span class="mi">1</span>; <span class="nb">split</span>; <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chke6" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chke6"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">create_reg_inv</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">s</span> <span class="nv">r</span> <span class="nv">s&#39;</span> <span class="nv">i</span>,
    create_reg a b s = OK r s&#39; i -&gt;
    r = s.(st_freshreg) /\ s&#39;.(st_freshreg) = Pos.succ (s.(st_freshreg)).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> : option io) (<span class="nv">b</span> : nat) (<span class="nv">s</span> : st) (<span class="nv">r</span> : reg)
  (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
create_reg a b s = OK r s&#39; i -&gt;
r = st_freshreg s /\
st_freshreg s&#39; = Pos.succ (st_freshreg s)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chke7" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chke7"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">a</span> : option io) (<span class="nv">b</span> : nat) (<span class="nv">s</span> : st) (<span class="nv">r</span> : reg)
  (<span class="nv">s&#39;</span> : st) (<span class="nv">i</span> : st_prop s s&#39;),
create_reg a b s = OK r s&#39; i -&gt;
r = st_freshreg s /\
st_freshreg s&#39; = Pos.succ (st_freshreg s)</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">inversion</span> <span class="mi">1</span>; <span class="nb">auto</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chke8" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chke8"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">transl_module_correct</span> :
  <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">m</span>,
    transl_module f = Errors.OK m -&gt; tr_module f m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">f</span> : RTL.function) (<span class="nv">m</span> : module),
transl_module f = Errors.OK m -&gt; tr_module f m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chke9" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chke9"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">f</span> : RTL.function) (<span class="nv">m</span> : module),
transl_module f = Errors.OK m -&gt; tr_module f m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkea" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkea"><span class="highlight"><span class="nb">intros until</span> m.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">module</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transl_module f = Errors.OK m -&gt; tr_module f m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkeb" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkeb"><span class="highlight"><span class="nb">unfold</span> transl_module.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">module</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">run_mon (max_state f) (transf_module f) = Errors.OK m -&gt;
tr_module f m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkec" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkec"><span class="highlight"><span class="nb">unfold</span> run_mon.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">module</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">match</span> transf_module f (max_state f) <span class="kr">with</span>
| Error err =&gt; Errors.Error err
| OK a _ _ =&gt; Errors.OK a
<span class="kr">end</span> = Errors.OK m -&gt; tr_module f m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chked" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chked"><span class="highlight"><span class="nb">destruct</span> (transf_module f (max_state f)) <span class="nb">eqn</span>:?; <span class="kp">try</span> <span class="bp">discriminate</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m, m0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">module</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">transf_module f (max_state f) = OK m0 s&#39; s</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Errors.OK m0 = Errors.OK m -&gt; tr_module f m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkee" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkee"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m, m0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">module</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">transf_module f (max_state f) = OK m0 s&#39; s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Errors.OK m0 = Errors.OK m</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f m</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkef" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkef"><span class="highlight">inv H.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">module</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">transf_module f (max_state f) = OK m s&#39; s</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkf0" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkf0"><span class="highlight"><span class="nb">inversion</span> s; <span class="nb">subst</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">module</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">transf_module f (max_state f) = OK m s&#39; s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st (max_state f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg (max_state f)) (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate (max_state f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath (max_state f)) ! n = None \/
(st_datapath s&#39;) ! n =
(st_datapath (max_state f)) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic (max_state f)) ! n = None \/
(st_controllogic s&#39;) ! n =
(st_controllogic (max_state f)) ! n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkf1" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkf1"><span class="highlight"><span class="nb">unfold</span> transf_module <span class="kr">in</span> *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">module</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kr">if</span> stack_correct (RTL.fn_stacksize f)
 <span class="kr">then</span>
  <span class="kp">do</span> fin &lt;- create_reg (Some Voutput) <span class="mi">1</span>;
  <span class="kp">do</span> rtrn &lt;- create_reg (Some Voutput) <span class="mi">32</span>;
  <span class="kp">do</span> (stack, stack_len)&lt;-
  create_arr None <span class="mi">32</span>
    (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>));
  <span class="kp">do</span> _ &lt;-
  HTLMonadExtra.collectlist
    (transf_instr fin rtrn stack)
    (PTree.elements (RTL.fn_code f));
  <span class="kp">do</span> _ &lt;-
  HTLMonadExtra.collectlist
    (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt;
     declare_reg (Some Vinput) r <span class="mi">32</span>)
    (RTL.fn_params f);
  <span class="kp">do</span> start &lt;- create_reg (Some Vinput) <span class="mi">1</span>;
  <span class="kp">do</span> rst &lt;- create_reg (Some Vinput) <span class="mi">1</span>;
  <span class="kp">do</span> clk &lt;- create_reg (Some Vinput) <span class="mi">1</span>;
  <span class="kp">do</span> current_state &lt;- get;
  <span class="kr">match</span>
    zle
      (Z.pos
         (max_pc_map
            (st_datapath current_state)))
      Int.max_unsigned
  <span class="kr">with</span>
  | <span class="nb">left</span> LEDATA =&gt;
      <span class="kr">match</span>
        zle
          (Z.pos
             (max_pc_map
                (st_controllogic current_state)))
          Int.max_unsigned
      <span class="kr">with</span>
      | <span class="nb">left</span> LECTRL =&gt;
          ret
            {|
            mod_params := RTL.fn_params f;
            mod_datapath := st_datapath
                        current_state;
            mod_controllogic := st_controllogic
                        current_state;
            mod_entrypoint := RTL.fn_entrypoint
                        f;
            mod_st := st_st current_state;
            mod_stk := stack;
            mod_stk_len := stack_len;
            mod_finish := fin;
            mod_return := rtrn;
            mod_start := start;
            mod_reset := rst;
            mod_clk := clk;
            mod_scldecls := st_scldecls
                        current_state;
            mod_arrdecls := st_arrdecls
                        current_state;
            mod_wf := conj
                        (max_pc_wf
                        (st_controllogic
                        current_state) LECTRL)
                        (max_pc_wf
                        (st_datapath
                        current_state) LEDATA) |}
      | <span class="nb">right</span> _ =&gt;
          error
            (Errors.msg
               <span class="s2">&quot;More than 2^32 states.&quot;</span>)
      <span class="kr">end</span>
  | <span class="nb">right</span> _ =&gt;
      error
        (Errors.msg <span class="s2">&quot;More than 2^32 states.&quot;</span>)
  <span class="kr">end</span>
 <span class="kr">else</span>
  error (Errors.msg <span class="s2">&quot;Stack size misalignment.&quot;</span>))
  (max_state f) = OK m s&#39; s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st (max_state f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg (max_state f)) (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate (max_state f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath (max_state f)) ! n = None \/
(st_datapath s&#39;) ! n =
(st_datapath (max_state f)) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic (max_state f)) ! n = None \/
(st_controllogic s&#39;) ! n =
(st_controllogic (max_state f)) ! n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkf2" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkf2"><span class="highlight"><span class="nb">unfold</span> stack_correct <span class="kr">in</span> *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">module</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kr">if</span>
  (<span class="mi">0</span> &lt;=? RTL.fn_stacksize f) &amp;&amp;
  (RTL.fn_stacksize f &lt;? Ptrofs.modulus) &amp;&amp;
  (RTL.fn_stacksize f mod <span class="mi">4</span> =? <span class="mi">0</span>)
 <span class="kr">then</span>
  <span class="kp">do</span> fin &lt;- create_reg (Some Voutput) <span class="mi">1</span>;
  <span class="kp">do</span> rtrn &lt;- create_reg (Some Voutput) <span class="mi">32</span>;
  <span class="kp">do</span> (stack, stack_len)&lt;-
  create_arr None <span class="mi">32</span>
    (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>));
  <span class="kp">do</span> _ &lt;-
  HTLMonadExtra.collectlist
    (transf_instr fin rtrn stack)
    (PTree.elements (RTL.fn_code f));
  <span class="kp">do</span> _ &lt;-
  HTLMonadExtra.collectlist
    (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt;
     declare_reg (Some Vinput) r <span class="mi">32</span>)
    (RTL.fn_params f);
  <span class="kp">do</span> start &lt;- create_reg (Some Vinput) <span class="mi">1</span>;
  <span class="kp">do</span> rst &lt;- create_reg (Some Vinput) <span class="mi">1</span>;
  <span class="kp">do</span> clk &lt;- create_reg (Some Vinput) <span class="mi">1</span>;
  <span class="kp">do</span> current_state &lt;- get;
  <span class="kr">match</span>
    zle
      (Z.pos
         (max_pc_map
            (st_datapath current_state)))
      Int.max_unsigned
  <span class="kr">with</span>
  | <span class="nb">left</span> LEDATA =&gt;
      <span class="kr">match</span>
        zle
          (Z.pos
             (max_pc_map
                (st_controllogic current_state)))
          Int.max_unsigned
      <span class="kr">with</span>
      | <span class="nb">left</span> LECTRL =&gt;
          ret
            {|
            mod_params := RTL.fn_params f;
            mod_datapath := st_datapath
                        current_state;
            mod_controllogic := st_controllogic
                        current_state;
            mod_entrypoint := RTL.fn_entrypoint
                        f;
            mod_st := st_st current_state;
            mod_stk := stack;
            mod_stk_len := stack_len;
            mod_finish := fin;
            mod_return := rtrn;
            mod_start := start;
            mod_reset := rst;
            mod_clk := clk;
            mod_scldecls := st_scldecls
                        current_state;
            mod_arrdecls := st_arrdecls
                        current_state;
            mod_wf := conj
                        (max_pc_wf
                        (st_controllogic
                        current_state) LECTRL)
                        (max_pc_wf
                        (st_datapath
                        current_state) LEDATA) |}
      | <span class="nb">right</span> _ =&gt;
          error
            (Errors.msg
               <span class="s2">&quot;More than 2^32 states.&quot;</span>)
      <span class="kr">end</span>
  | <span class="nb">right</span> _ =&gt;
      error
        (Errors.msg <span class="s2">&quot;More than 2^32 states.&quot;</span>)
  <span class="kr">end</span>
 <span class="kr">else</span>
  error (Errors.msg <span class="s2">&quot;Stack size misalignment.&quot;</span>))
  (max_state f) = OK m s&#39; s</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st (max_state f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg (max_state f)) (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate (max_state f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath (max_state f)) ! n = None \/
(st_datapath s&#39;) ! n =
(st_datapath (max_state f)) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic (max_state f)) ! n = None \/
(st_controllogic s&#39;) ! n =
(st_controllogic (max_state f)) ! n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkf3" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkf3"><span class="highlight"><span class="nb">destruct</span> (<span class="mi">0</span> &lt;=? RTL.fn_stacksize f) <span class="nb">eqn</span>:STACK_BOUND_LOW;
    <span class="nb">destruct</span> (RTL.fn_stacksize f &lt;? Integers.Ptrofs.modulus) <span class="nb">eqn</span>:STACK_BOUND_HIGH;
    <span class="nb">destruct</span> (RTL.fn_stacksize f mod <span class="mi">4</span> =? <span class="mi">0</span>) <span class="nb">eqn</span>:STACK_ALIGN;
    crush;
    monadInv Heqr.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">module</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK x s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 = OK x0 s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK (x1, x2) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist 
  (transf_instr x x0 x1)
  (PTree.elements (RTL.fn_code f)) s2 =
OK x3 s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK x4 s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 = OK x5 s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 = OK x6 s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 = OK x7 s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8, s8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s8</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s8 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s8 INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">match</span>
  zle (Z.pos (max_pc_map (st_datapath x8)))
    Int.max_unsigned
<span class="kr">with</span>
| <span class="nb">left</span> LEDATA =&gt;
    <span class="kr">match</span>
      zle
        (Z.pos (max_pc_map (st_controllogic x8)))
        Int.max_unsigned
    <span class="kr">with</span>
    | <span class="nb">left</span> LECTRL =&gt;
        ret
          {|
          mod_params := RTL.fn_params f;
          mod_datapath := st_datapath x8;
          mod_controllogic := st_controllogic x8;
          mod_entrypoint := RTL.fn_entrypoint f;
          mod_st := st_st x8;
          mod_stk := x1;
          mod_stk_len := x2;
          mod_finish := x;
          mod_return := x0;
          mod_start := x5;
          mod_reset := x6;
          mod_clk := x7;
          mod_scldecls := st_scldecls x8;
          mod_arrdecls := st_arrdecls x8;
          mod_wf := conj
                      (max_pc_wf
                        (st_controllogic x8)
                        LECTRL)
                      (max_pc_wf
                        (st_datapath x8) LEDATA) |}
    | <span class="nb">right</span> _ =&gt;
        error
          (Errors.msg <span class="s2">&quot;More than 2^32 states.&quot;</span>)
    <span class="kr">end</span>
| <span class="nb">right</span> _ =&gt;
    error (Errors.msg <span class="s2">&quot;More than 2^32 states.&quot;</span>)
<span class="kr">end</span> s8 = OK m s&#39; INCR16</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f m</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkf4" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkf4"><span class="highlight"><span class="kp">repeat</span> unfold_match EQ9.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">module</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK x s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 = OK x0 s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK (x1, x2) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist 
  (transf_instr x x0 x1)
  (PTree.elements (RTL.fn_code f)) s2 =
OK x3 s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK x4 s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 = OK x5 s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 = OK x6 s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 = OK x7 s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8, s8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s8</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s8 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s8 INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ret
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := x1;
  mod_stk_len := x2;
  mod_finish := x;
  mod_return := x0;
  mod_start := x5;
  mod_reset := x6;
  mod_clk := x7;
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj
              (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}
  s8 = OK m s&#39; INCR16</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f m</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkf5" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkf5"><span class="highlight">monadInv EQ9.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK x s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 = OK x0 s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK (x1, x2) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist 
  (transf_instr x x0 x1)
  (PTree.elements (RTL.fn_code f)) s2 =
OK x3 s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK x4 s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 = OK x5 s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 = OK x6 s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 = OK x7 s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := x1;
  mod_stk_len := x2;
  mod_finish := x;
  mod_return := x0;
  mod_start := x5;
  mod_reset := x6;
  mod_clk := x7;
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp"><span class="highlight">
  <span class="c">(* TODO: We should be able to fold this into the automation. *)</span>
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkf6" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkf6"><span class="highlight"><span class="nb">pose proof</span> (create_arr_inv _ _ _ _ _ _ _ _ EQ0) <span class="kr">as</span> STK_LEN.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK x s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 = OK x0 s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK (x1, x2) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist 
  (transf_instr x x0 x1)
  (PTree.elements (RTL.fn_code f)) s2 =
OK x3 s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK x4 s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 = OK x5 s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 = OK x6 s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 = OK x7 s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STK_LEN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>) = x2 /\
x1 = st_freshreg s1 /\
st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := x1;
  mod_stk_len := x2;
  mod_finish := x;
  mod_return := x0;
  mod_start := x5;
  mod_reset := x6;
  mod_clk := x7;
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkf7" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkf7"><span class="highlight">inv STK_LEN.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK x s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 = OK x0 s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK (x1, Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2
  INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist 
  (transf_instr x x0 x1)
  (PTree.elements (RTL.fn_code f)) s2 =
OK x3 s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK x4 s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 = OK x5 s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 = OK x6 s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 = OK x7 s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = st_freshreg s1 /\
st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := x1;
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := x;
  mod_return := x0;
  mod_start := x5;
  mod_reset := x6;
  mod_clk := x7;
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkf8" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkf8"><span class="highlight">inv H5.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK x s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 = OK x0 s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (st_freshreg s1,
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr x x0 (st_freshreg s1))
  (PTree.elements (RTL.fn_code f)) s2 =
OK x3 s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK x4 s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 = OK x5 s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 = OK x6 s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 = OK x7 s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := st_freshreg s1;
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := x;
  mod_return := x0;
  mod_start := x5;
  mod_reset := x6;
  mod_clk := x7;
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkf9" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkf9"><span class="highlight"><span class="nb">pose proof</span> (create_reg_inv _ _ _ _ _ _ EQ) <span class="kr">as</span> FIN_VAL.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK x s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 = OK x0 s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (st_freshreg s1,
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr x x0 (st_freshreg s1))
  (PTree.elements (RTL.fn_code f)) s2 =
OK x3 s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK x4 s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 = OK x5 s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 = OK x6 s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 = OK x7 s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">FIN_VAL</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x = st_freshreg (max_state f) /\
st_freshreg s0 =
Pos.succ (st_freshreg (max_state f))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := st_freshreg s1;
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := x;
  mod_return := x0;
  mod_start := x5;
  mod_reset := x6;
  mod_clk := x7;
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkfa" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkfa"><span class="highlight">inv FIN_VAL.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK (st_freshreg (max_state f)) s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 = OK x0 s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (st_freshreg s1,
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr (st_freshreg (max_state f)) x0
     (st_freshreg s1))
  (PTree.elements (RTL.fn_code f)) s2 =
OK x3 s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK x4 s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 = OK x5 s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 = OK x6 s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 = OK x7 s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ (st_freshreg (max_state f))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := st_freshreg s1;
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := st_freshreg (max_state f);
  mod_return := x0;
  mod_start := x5;
  mod_reset := x6;
  mod_clk := x7;
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkfb" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkfb"><span class="highlight"><span class="nb">pose proof</span> (create_reg_inv _ _ _ _ _ _ EQ1) <span class="kr">as</span> RET_VAL.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK (st_freshreg (max_state f)) s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 = OK x0 s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (st_freshreg s1,
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr (st_freshreg (max_state f)) x0
     (st_freshreg s1))
  (PTree.elements (RTL.fn_code f)) s2 =
OK x3 s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK x4 s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 = OK x5 s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 = OK x6 s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 = OK x7 s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ (st_freshreg (max_state f))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">RET_VAL</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x0 = st_freshreg s0 /\
st_freshreg s1 = Pos.succ (st_freshreg s0)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := st_freshreg s1;
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := st_freshreg (max_state f);
  mod_return := x0;
  mod_start := x5;
  mod_reset := x6;
  mod_clk := x7;
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkfc" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkfc"><span class="highlight">inv RET_VAL.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK (st_freshreg (max_state f)) s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 =
OK (st_freshreg s0) s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (st_freshreg s1,
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr (st_freshreg (max_state f))
     (st_freshreg s0) (st_freshreg s1))
  (PTree.elements (RTL.fn_code f)) s2 =
OK x3 s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK x4 s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 = OK x5 s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 = OK x6 s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 = OK x7 s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ (st_freshreg (max_state f))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = Pos.succ (st_freshreg s0)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := st_freshreg s1;
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := st_freshreg (max_state f);
  mod_return := st_freshreg s0;
  mod_start := x5;
  mod_reset := x6;
  mod_clk := x7;
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkfd" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkfd"><span class="highlight"><span class="nb">destruct</span> x3.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK (st_freshreg (max_state f)) s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 =
OK (st_freshreg s0) s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (st_freshreg s1,
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr (st_freshreg (max_state f))
     (st_freshreg s0) (st_freshreg s1))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK x4 s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 = OK x5 s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 = OK x6 s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 = OK x7 s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ (st_freshreg (max_state f))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = Pos.succ (st_freshreg s0)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := st_freshreg s1;
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := st_freshreg (max_state f);
  mod_return := st_freshreg s0;
  mod_start := x5;
  mod_reset := x6;
  mod_clk := x7;
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkfe" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkfe"><span class="highlight"><span class="nb">destruct</span> x4.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK (st_freshreg (max_state f)) s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 =
OK (st_freshreg s0) s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (st_freshreg s1,
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr (st_freshreg (max_state f))
     (st_freshreg s0) (st_freshreg s1))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK tt s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 = OK x5 s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 = OK x6 s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 = OK x7 s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ (st_freshreg (max_state f))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = Pos.succ (st_freshreg s0)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := st_freshreg s1;
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := st_freshreg (max_state f);
  mod_return := st_freshreg s0;
  mod_start := x5;
  mod_reset := x6;
  mod_clk := x7;
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chkff" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chkff"><span class="highlight"><span class="nb">pose proof</span> (collect_trans_instr_freshreg_trans _ _ _ _ _ _ _ EQ2) <span class="kr">as</span> TR_INSTR.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK (st_freshreg (max_state f)) s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 =
OK (st_freshreg s0) s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (st_freshreg s1,
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr (st_freshreg (max_state f))
     (st_freshreg s0) (st_freshreg s1))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK tt s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 = OK x5 s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 = OK x6 s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 = OK x7 s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ (st_freshreg (max_state f))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = Pos.succ (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = st_freshreg s3</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := st_freshreg s1;
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := st_freshreg (max_state f);
  mod_return := st_freshreg s0;
  mod_start := x5;
  mod_reset := x6;
  mod_clk := x7;
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk100" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk100"><span class="highlight"><span class="nb">pose proof</span> (collect_declare_freshreg_trans _ _ _ _ _ _ EQ3) <span class="kr">as</span> TR_DEC.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK (st_freshreg (max_state f)) s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 =
OK (st_freshreg s0) s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (st_freshreg s1,
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr (st_freshreg (max_state f))
     (st_freshreg s0) (st_freshreg s1))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK tt s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 = OK x5 s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 = OK x6 s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 = OK x7 s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ (st_freshreg (max_state f))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = Pos.succ (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 = st_freshreg s4</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := st_freshreg s1;
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := st_freshreg (max_state f);
  mod_return := st_freshreg s0;
  mod_start := x5;
  mod_reset := x6;
  mod_clk := x7;
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk101" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk101"><span class="highlight"><span class="nb">pose proof</span> (create_reg_inv _ _ _ _ _ _ EQ4) <span class="kr">as</span> START_VAL.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK (st_freshreg (max_state f)) s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 =
OK (st_freshreg s0) s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (st_freshreg s1,
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr (st_freshreg (max_state f))
     (st_freshreg s0) (st_freshreg s1))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK tt s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 = OK x5 s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 = OK x6 s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 = OK x7 s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ (st_freshreg (max_state f))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = Pos.succ (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 = st_freshreg s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">START_VAL</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x5 = st_freshreg s4 /\
st_freshreg s5 = Pos.succ (st_freshreg s4)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := st_freshreg s1;
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := st_freshreg (max_state f);
  mod_return := st_freshreg s0;
  mod_start := x5;
  mod_reset := x6;
  mod_clk := x7;
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk102" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk102"><span class="highlight">inv START_VAL.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK (st_freshreg (max_state f)) s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 =
OK (st_freshreg s0) s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (st_freshreg s1,
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr (st_freshreg (max_state f))
     (st_freshreg s0) (st_freshreg s1))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK tt s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 =
OK (st_freshreg s4) s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 = OK x6 s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 = OK x7 s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ (st_freshreg (max_state f))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = Pos.succ (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 = st_freshreg s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 = Pos.succ (st_freshreg s4)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := st_freshreg s1;
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := st_freshreg (max_state f);
  mod_return := st_freshreg s0;
  mod_start := st_freshreg s4;
  mod_reset := x6;
  mod_clk := x7;
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk103" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk103"><span class="highlight"><span class="nb">pose proof</span> (create_reg_inv _ _ _ _ _ _ EQ5) <span class="kr">as</span> RESET_VAL.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK (st_freshreg (max_state f)) s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 =
OK (st_freshreg s0) s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (st_freshreg s1,
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr (st_freshreg (max_state f))
     (st_freshreg s0) (st_freshreg s1))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK tt s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 =
OK (st_freshreg s4) s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 = OK x6 s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 = OK x7 s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ (st_freshreg (max_state f))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = Pos.succ (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 = st_freshreg s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 = Pos.succ (st_freshreg s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">RESET_VAL</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x6 = st_freshreg s5 /\
st_freshreg s6 = Pos.succ (st_freshreg s5)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := st_freshreg s1;
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := st_freshreg (max_state f);
  mod_return := st_freshreg s0;
  mod_start := st_freshreg s4;
  mod_reset := x6;
  mod_clk := x7;
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk104" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk104"><span class="highlight">inv RESET_VAL.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK (st_freshreg (max_state f)) s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 =
OK (st_freshreg s0) s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (st_freshreg s1,
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr (st_freshreg (max_state f))
     (st_freshreg s0) (st_freshreg s1))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK tt s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 =
OK (st_freshreg s4) s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 =
OK (st_freshreg s5) s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 = OK x7 s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ (st_freshreg (max_state f))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = Pos.succ (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 = st_freshreg s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 = Pos.succ (st_freshreg s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s6 = Pos.succ (st_freshreg s5)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := st_freshreg s1;
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := st_freshreg (max_state f);
  mod_return := st_freshreg s0;
  mod_start := st_freshreg s4;
  mod_reset := st_freshreg s5;
  mod_clk := x7;
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk105" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk105"><span class="highlight"><span class="nb">pose proof</span> (create_reg_inv _ _ _ _ _ _ EQ6) <span class="kr">as</span> CLK_VAL.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK (st_freshreg (max_state f)) s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 =
OK (st_freshreg s0) s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (st_freshreg s1,
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr (st_freshreg (max_state f))
     (st_freshreg s0) (st_freshreg s1))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK tt s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 =
OK (st_freshreg s4) s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 =
OK (st_freshreg s5) s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reg</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 = OK x7 s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ (st_freshreg (max_state f))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = Pos.succ (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 = st_freshreg s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 = Pos.succ (st_freshreg s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s6 = Pos.succ (st_freshreg s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">CLK_VAL</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x7 = st_freshreg s6 /\
st_freshreg s7 = Pos.succ (st_freshreg s6)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := st_freshreg s1;
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := st_freshreg (max_state f);
  mod_return := st_freshreg s0;
  mod_start := st_freshreg s4;
  mod_reset := st_freshreg s5;
  mod_clk := x7;
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk106" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk106"><span class="highlight">inv CLK_VAL.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK (st_freshreg (max_state f)) s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 =
OK (st_freshreg s0) s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (st_freshreg s1,
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr (st_freshreg (max_state f))
     (st_freshreg s0) (st_freshreg s1))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK tt s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 =
OK (st_freshreg s4) s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 =
OK (st_freshreg s5) s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 =
OK (st_freshreg s6) s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ (st_freshreg (max_state f))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = Pos.succ (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 = st_freshreg s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 = Pos.succ (st_freshreg s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s6 = Pos.succ (st_freshreg s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s7 = Pos.succ (st_freshreg s6)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := st_freshreg s1;
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := st_freshreg (max_state f);
  mod_return := st_freshreg s0;
  mod_start := st_freshreg s4;
  mod_reset := st_freshreg s5;
  mod_clk := st_freshreg s6;
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk107" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk107"><span class="highlight"><span class="nb">rewrite</span> H9 <span class="kr">in</span> *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK (st_freshreg (max_state f)) s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 =
OK (st_freshreg s0) s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (st_freshreg s1,
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr (st_freshreg (max_state f))
     (st_freshreg s0) (st_freshreg s1))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK tt s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 =
OK (st_freshreg s4) s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 =
OK (st_freshreg s5) s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 =
OK (Pos.succ (st_freshreg s5)) s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ (st_freshreg (max_state f))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = Pos.succ (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 = st_freshreg s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 = Pos.succ (st_freshreg s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s6 = Pos.succ (st_freshreg s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s7 =
Pos.succ (Pos.succ (st_freshreg s5))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := st_freshreg s1;
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := st_freshreg (max_state f);
  mod_return := st_freshreg s0;
  mod_start := st_freshreg s4;
  mod_reset := st_freshreg s5;
  mod_clk := Pos.succ (st_freshreg s5);
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk108" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk108"><span class="highlight"><span class="nb">rewrite</span> H8 <span class="kr">in</span> *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK (st_freshreg (max_state f)) s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 =
OK (st_freshreg s0) s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (st_freshreg s1,
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr (st_freshreg (max_state f))
     (st_freshreg s0) (st_freshreg s1))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK tt s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 =
OK (st_freshreg s4) s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 =
OK (Pos.succ (st_freshreg s4)) s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 =
OK (Pos.succ (Pos.succ (st_freshreg s4))) s7
  INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ (st_freshreg (max_state f))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = Pos.succ (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 = st_freshreg s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 = Pos.succ (st_freshreg s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s6 =
Pos.succ (Pos.succ (st_freshreg s4))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s7 =
Pos.succ (Pos.succ (Pos.succ (st_freshreg s4)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := st_freshreg s1;
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := st_freshreg (max_state f);
  mod_return := st_freshreg s0;
  mod_start := st_freshreg s4;
  mod_reset := Pos.succ (st_freshreg s4);
  mod_clk := Pos.succ (Pos.succ (st_freshreg s4));
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk109" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk109"><span class="highlight"><span class="nb">replace</span> (st_freshreg s4) <span class="kr">with</span> (st_freshreg s2) <span class="kr">in</span> * <span class="bp">by</span> <span class="bp">congruence</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK (st_freshreg (max_state f)) s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 =
OK (st_freshreg s0) s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (st_freshreg s1,
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr (st_freshreg (max_state f))
     (st_freshreg s0) (st_freshreg s1))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK tt s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 =
OK (st_freshreg s2) s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 =
OK (Pos.succ (st_freshreg s2)) s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 =
OK (Pos.succ (Pos.succ (st_freshreg s2))) s7
  INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ (st_freshreg (max_state f))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = Pos.succ (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 = st_freshreg s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 = Pos.succ (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s6 =
Pos.succ (Pos.succ (st_freshreg s2))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s7 =
Pos.succ (Pos.succ (Pos.succ (st_freshreg s2)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := st_freshreg s1;
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := st_freshreg (max_state f);
  mod_return := st_freshreg s0;
  mod_start := st_freshreg s2;
  mod_reset := Pos.succ (st_freshreg s2);
  mod_clk := Pos.succ (Pos.succ (st_freshreg s2));
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk10a" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk10a"><span class="highlight"><span class="nb">rewrite</span> H6 <span class="kr">in</span> *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK (st_freshreg (max_state f)) s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 =
OK (st_freshreg s0) s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (st_freshreg s1,
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr (st_freshreg (max_state f))
     (st_freshreg s0) (st_freshreg s1))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK tt s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 =
OK (Pos.succ (st_freshreg s1)) s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 =
OK (Pos.succ (Pos.succ (st_freshreg s1))) s6
  INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 =
OK
  (Pos.succ
     (Pos.succ (Pos.succ (st_freshreg s1)))) s7
  INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 = Pos.succ (st_freshreg s1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ (st_freshreg (max_state f))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = Pos.succ (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (st_freshreg s1) = st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 = Pos.succ (st_freshreg s1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 =
Pos.succ (Pos.succ (st_freshreg s1))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s6 =
Pos.succ (Pos.succ (Pos.succ (st_freshreg s1)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s7 =
Pos.succ
  (Pos.succ
     (Pos.succ (Pos.succ (st_freshreg s1))))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := st_freshreg s1;
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := st_freshreg (max_state f);
  mod_return := st_freshreg s0;
  mod_start := Pos.succ (st_freshreg s1);
  mod_reset := Pos.succ (Pos.succ (st_freshreg s1));
  mod_clk := Pos.succ
               (Pos.succ (Pos.succ (st_freshreg s1)));
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk10b" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk10b"><span class="highlight"><span class="nb">rewrite</span> H7 <span class="kr">in</span> *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK (st_freshreg (max_state f)) s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 =
OK (st_freshreg s0) s1 INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (Pos.succ (st_freshreg s0),
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr (st_freshreg (max_state f))
     (st_freshreg s0)
     (Pos.succ (st_freshreg s0)))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK tt s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 =
OK (Pos.succ (Pos.succ (st_freshreg s0))) s5
  INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 =
OK
  (Pos.succ
     (Pos.succ (Pos.succ (st_freshreg s0)))) s6
  INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 =
OK
  (Pos.succ
     (Pos.succ
        (Pos.succ (Pos.succ (st_freshreg s0)))))
  s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 =
Pos.succ (Pos.succ (st_freshreg s0))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ (st_freshreg (max_state f))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 = Pos.succ (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (Pos.succ (st_freshreg s0)) =
st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 =
Pos.succ (Pos.succ (st_freshreg s0))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 =
Pos.succ (Pos.succ (Pos.succ (st_freshreg s0)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s6 =
Pos.succ
  (Pos.succ
     (Pos.succ (Pos.succ (st_freshreg s0))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s7 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ (Pos.succ (st_freshreg s0)))))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := Pos.succ (st_freshreg s0);
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := st_freshreg (max_state f);
  mod_return := st_freshreg s0;
  mod_start := Pos.succ (Pos.succ (st_freshreg s0));
  mod_reset := Pos.succ
                 (Pos.succ (Pos.succ (st_freshreg s0)));
  mod_clk := Pos.succ
               (Pos.succ
                  (Pos.succ
                     (Pos.succ (st_freshreg s0))));
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk10c" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk10c"><span class="highlight"><span class="nb">rewrite</span> H5 <span class="kr">in</span> *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK (st_freshreg (max_state f)) s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 =
OK (Pos.succ (st_freshreg (max_state f))) s1
  INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (Pos.succ
     (Pos.succ (st_freshreg (max_state f))),
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr (st_freshreg (max_state f))
     (Pos.succ (st_freshreg (max_state f)))
     (Pos.succ
        (Pos.succ (st_freshreg (max_state f)))))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK tt s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 =
OK
  (Pos.succ
     (Pos.succ
        (Pos.succ (st_freshreg (max_state f)))))
  s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 =
OK
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (st_freshreg (max_state f))))))
  s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 =
OK
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (st_freshreg (max_state f)))))))
  s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 =
Pos.succ
  (Pos.succ
     (Pos.succ (st_freshreg (max_state f))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ (st_freshreg (max_state f))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 =
Pos.succ (Pos.succ (st_freshreg (max_state f)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ
  (Pos.succ
     (Pos.succ (st_freshreg (max_state f)))) =
st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 =
Pos.succ
  (Pos.succ
     (Pos.succ (st_freshreg (max_state f))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ (st_freshreg (max_state f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s6 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (st_freshreg (max_state f))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s7 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (st_freshreg (max_state f)))))))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := Pos.succ
               (Pos.succ (st_freshreg (max_state f)));
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := st_freshreg (max_state f);
  mod_return := Pos.succ (st_freshreg (max_state f));
  mod_start := Pos.succ
                 (Pos.succ
                    (Pos.succ
                       (st_freshreg (max_state f))));
  mod_reset := Pos.succ
                 (Pos.succ
                    (Pos.succ
                       (Pos.succ
                        (st_freshreg (max_state f)))));
  mod_clk := Pos.succ
               (Pos.succ
                  (Pos.succ
                     (Pos.succ
                        (Pos.succ
                        (st_freshreg (max_state f))))));
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp"> </span></span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk10d" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk10d"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> *.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s&#39;)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s&#39;) ! n = (AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s&#39;) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop (max_state f) s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">1</span> (max_state f) =
OK (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  s0 INCR</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s0 s1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Voutput) <span class="mi">32</span> s0 =
OK
  (Pos.succ
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f)))) s1
  INCR1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s1 s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_arr None <span class="mi">32</span>
  (Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s1 =
OK
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))),
  Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>)) s2 INCR3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s2 s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f)))
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f))))
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 INCR5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s3 s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 = 
OK tt s4 INCR7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s4 s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s4 =
OK
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))
  s5 INCR9</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s5 s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s5 =
OK
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (RTL.max_reg_function f)))))))
  s6 INCR11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s6 s7</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">create_reg (Some Vinput) <span class="mi">1</span> s6 =
OK
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (Pos.succ
                       (RTL.max_reg_function f))))))))
  s7 INCR13</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s7 s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">get s7 = OK x8 s&#39; INCR15</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">INCR16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_prop s&#39; s&#39;</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath x8)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic x8)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic x8)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s1 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (RTL.max_reg_function f))))) =
st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s6 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (RTL.max_reg_function f)))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s7 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (Pos.succ
                       (RTL.max_reg_function f))))))))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath x8;
  mod_controllogic := st_controllogic x8;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st x8;
  mod_stk := Pos.succ
               (Pos.succ
                  (Pos.succ
                     (Pos.succ
                        (RTL.max_reg_function f))));
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := Pos.succ
                  (Pos.succ (RTL.max_reg_function f));
  mod_return := Pos.succ
                  (Pos.succ
                     (Pos.succ
                        (RTL.max_reg_function f)));
  mod_start := Pos.succ
                 (Pos.succ
                    (Pos.succ
                       (Pos.succ
                        (Pos.succ
                        (RTL.max_reg_function f)))));
  mod_reset := Pos.succ
                 (Pos.succ
                    (Pos.succ
                       (Pos.succ
                        (Pos.succ
                        (Pos.succ
                        (RTL.max_reg_function f))))));
  mod_clk := Pos.succ
               (Pos.succ
                  (Pos.succ
                     (Pos.succ
                        (Pos.succ
                        (Pos.succ
                        (Pos.succ
                        (RTL.max_reg_function f)))))));
  mod_scldecls := st_scldecls x8;
  mod_arrdecls := st_arrdecls x8;
  mod_wf := conj (max_pc_wf (st_controllogic x8) l0)
              (max_pc_wf (st_datapath x8) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk10e" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk10e"><span class="highlight">inv_incr.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H96</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H97</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H98</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H99</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s10) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H100</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s10) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s10) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H91</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H92</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s11)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H93</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s11)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H94</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s11) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H95</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s11) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H86</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s11 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H87</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s11) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H88</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s11) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H89</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s11) ! n = None \/
(st_datapath s10) ! n = (st_datapath s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H90</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s11) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s1 = st_datapath s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H81</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s11 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H82</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s11) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H83</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s11) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H84</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s11) ! n = None \/
(st_datapath s0) ! n = (st_datapath s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H85</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s11) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H76</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H77</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H78</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H79</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s10) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H80</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s11 = st_datapath s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H71</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H72</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H73</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H74</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H75</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H66</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s2 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H67</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s2) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H68</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s2) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H69</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s2) ! n = None \/
(st_datapath s10) ! n = (st_datapath s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H70</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s2) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s0 = st_datapath s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s2 = st_st s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s2) (st_freshreg s3)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s2) (st_freshstate s3)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s2) ! n = None \/
(st_datapath s3) ! n = (st_datapath s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s2) ! n = None \/
(st_controllogic s3) ! n =
(st_controllogic s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H61</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s3 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H62</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s3) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H63</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s3) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H64</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s3) ! n = None \/
(st_datapath s10) ! n = (st_datapath s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H65</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s3) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f)))
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f))))
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 (state_incr_intro s2 s3 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s3 = st_st s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s3) (st_freshreg s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s3) (st_freshstate s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s3) ! n = None \/
(st_datapath s4) ! n = (st_datapath s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s3) ! n = None \/
(st_controllogic s4) ! n =
(st_controllogic s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H56</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s4 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H57</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s4) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H58</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s4) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H59</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s4) ! n = None \/
(st_datapath s10) ! n = (st_datapath s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H60</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s4) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 =
OK tt s4 (state_incr_intro s3 s4 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H51</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s4 = st_st s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H52</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s4) (st_freshreg s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H53</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s4) (st_freshstate s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H54</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s4) ! n = None \/
(st_datapath s5) ! n = (st_datapath s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H55</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s4) ! n = None \/
(st_controllogic s5) ! n =
(st_controllogic s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H46</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s5 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H47</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s5) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H48</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s5) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H49</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s5) ! n = None \/
(st_datapath s10) ! n = (st_datapath s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H50</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s5) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s4 = st_datapath s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H41</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s5 = st_st s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H42</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s5) (st_freshreg s6)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H43</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s5) (st_freshstate s6)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H44</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s5) ! n = None \/
(st_datapath s6) ! n = (st_datapath s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H45</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s5) ! n = None \/
(st_controllogic s6) ! n =
(st_controllogic s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H36</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s6 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H37</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s6) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H38</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s6) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H39</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s6) ! n = None \/
(st_datapath s10) ! n = (st_datapath s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H40</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s6) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s5 = st_datapath s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H31</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s6 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H32</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s6) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H33</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s6) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H34</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s6) ! n = None \/
(st_datapath s10) ! n = (st_datapath s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H35</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s6) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H26</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s9 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H27</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s9) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H28</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s9) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H29</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s9) ! n = None \/
(st_datapath s10) ! n = (st_datapath s9) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H30</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s9) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s9) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s6 = st_datapath s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s8 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H22</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s8) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H23</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s8) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H24</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s8) ! n = None \/
(st_datapath s10) ! n = (st_datapath s8) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H25</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s8) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s8) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s7 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H17</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s7) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H18</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s7) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H19</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s7) ! n = None \/
(st_datapath s10) ! n = (st_datapath s7) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H20</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s7) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s7) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic s10)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic s10)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath s10)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath s10)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s11 =
Pos.succ
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (RTL.max_reg_function f))))) =
st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s6 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (RTL.max_reg_function f)))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s10 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (Pos.succ
                       (RTL.max_reg_function f))))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s6 = st_controllogic s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s5 = st_controllogic s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s4 = st_controllogic s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s11 = st_controllogic s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s1 = st_controllogic s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s0 = st_controllogic s2</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_module f
  {|
  mod_params := RTL.fn_params f;
  mod_datapath := st_datapath s10;
  mod_controllogic := st_controllogic s10;
  mod_entrypoint := RTL.fn_entrypoint f;
  mod_st := st_st s10;
  mod_stk := Pos.succ
               (Pos.succ
                  (Pos.succ
                     (Pos.succ
                        (RTL.max_reg_function f))));
  mod_stk_len := Z.to_nat (RTL.fn_stacksize f / <span class="mi">4</span>);
  mod_finish := Pos.succ
                  (Pos.succ (RTL.max_reg_function f));
  mod_return := Pos.succ
                  (Pos.succ
                     (Pos.succ
                        (RTL.max_reg_function f)));
  mod_start := Pos.succ
                 (Pos.succ
                    (Pos.succ
                       (Pos.succ
                        (Pos.succ
                        (RTL.max_reg_function f)))));
  mod_reset := Pos.succ
                 (Pos.succ
                    (Pos.succ
                       (Pos.succ
                        (Pos.succ
                        (Pos.succ
                        (RTL.max_reg_function f))))));
  mod_clk := Pos.succ
               (Pos.succ
                  (Pos.succ
                     (Pos.succ
                        (Pos.succ
                        (Pos.succ
                        (Pos.succ
                        (RTL.max_reg_function f)))))));
  mod_scldecls := st_scldecls s10;
  mod_arrdecls := st_arrdecls s10;
  mod_wf := conj (max_pc_wf (st_controllogic s10) l0)
              (max_pc_wf (st_datapath s10) l) |}</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk10f" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk10f"><span class="highlight"><span class="nb">econstructor</span>; <span class="nb">simpl</span>; <span class="nb">auto</span>; <span class="kp">try</span> <span class="bp">lia</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H96</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H97</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H98</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H99</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s10) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H100</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s10) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s10) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H91</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H92</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s11)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H93</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s11)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H94</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s11) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H95</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s11) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H86</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s11 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H87</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s11) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H88</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s11) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H89</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s11) ! n = None \/
(st_datapath s10) ! n = (st_datapath s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H90</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s11) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s1 = st_datapath s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H81</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s11 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H82</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s11) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H83</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s11) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H84</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s11) ! n = None \/
(st_datapath s0) ! n = (st_datapath s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H85</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s11) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H76</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H77</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H78</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H79</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s10) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H80</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s11 = st_datapath s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H71</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H72</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H73</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H74</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H75</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H66</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s2 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H67</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s2) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H68</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s2) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H69</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s2) ! n = None \/
(st_datapath s10) ! n = (st_datapath s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H70</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s2) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s0 = st_datapath s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s2 = st_st s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s2) (st_freshreg s3)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s2) (st_freshstate s3)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s2) ! n = None \/
(st_datapath s3) ! n = (st_datapath s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s2) ! n = None \/
(st_controllogic s3) ! n =
(st_controllogic s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H61</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s3 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H62</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s3) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H63</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s3) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H64</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s3) ! n = None \/
(st_datapath s10) ! n = (st_datapath s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H65</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s3) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f)))
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f))))
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 (state_incr_intro s2 s3 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s3 = st_st s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s3) (st_freshreg s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s3) (st_freshstate s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s3) ! n = None \/
(st_datapath s4) ! n = (st_datapath s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s3) ! n = None \/
(st_controllogic s4) ! n =
(st_controllogic s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H56</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s4 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H57</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s4) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H58</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s4) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H59</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s4) ! n = None \/
(st_datapath s10) ! n = (st_datapath s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H60</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s4) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 =
OK tt s4 (state_incr_intro s3 s4 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H51</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s4 = st_st s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H52</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s4) (st_freshreg s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H53</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s4) (st_freshstate s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H54</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s4) ! n = None \/
(st_datapath s5) ! n = (st_datapath s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H55</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s4) ! n = None \/
(st_controllogic s5) ! n =
(st_controllogic s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H46</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s5 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H47</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s5) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H48</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s5) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H49</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s5) ! n = None \/
(st_datapath s10) ! n = (st_datapath s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H50</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s5) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s4 = st_datapath s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H41</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s5 = st_st s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H42</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s5) (st_freshreg s6)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H43</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s5) (st_freshstate s6)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H44</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s5) ! n = None \/
(st_datapath s6) ! n = (st_datapath s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H45</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s5) ! n = None \/
(st_controllogic s6) ! n =
(st_controllogic s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H36</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s6 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H37</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s6) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H38</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s6) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H39</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s6) ! n = None \/
(st_datapath s10) ! n = (st_datapath s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H40</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s6) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s5 = st_datapath s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H31</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s6 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H32</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s6) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H33</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s6) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H34</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s6) ! n = None \/
(st_datapath s10) ! n = (st_datapath s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H35</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s6) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H26</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s9 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H27</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s9) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H28</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s9) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H29</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s9) ! n = None \/
(st_datapath s10) ! n = (st_datapath s9) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H30</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s9) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s9) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s6 = st_datapath s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s8 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H22</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s8) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H23</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s8) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H24</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s8) ! n = None \/
(st_datapath s10) ! n = (st_datapath s8) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H25</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s8) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s8) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s7 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H17</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s7) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H18</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s7) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H19</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s7) ! n = None \/
(st_datapath s10) ! n = (st_datapath s7) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H20</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s7) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s7) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic s10)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic s10)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath s10)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath s10)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s11 =
Pos.succ
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (RTL.max_reg_function f))))) =
st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s6 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (RTL.max_reg_function f)))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s10 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (Pos.succ
                       (RTL.max_reg_function f))))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s6 = st_controllogic s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s5 = st_controllogic s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s4 = st_controllogic s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s11 = st_controllogic s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s1 = st_controllogic s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s0 = st_controllogic s2</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : positive) (<span class="nv">i</span> : RTL.instruction),
(RTL.fn_code f) ! pc = Some i -&gt;
tr_code (RTL.fn_code f) pc i 
  (st_datapath s10) (st_controllogic s10)
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (Pos.succ
     (Pos.succ (Pos.succ (RTL.max_reg_function f))))
  (st_st s10)
  (Pos.succ
     (Pos.succ
        (Pos.succ (Pos.succ (RTL.max_reg_function f)))))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk110" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk110"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H96</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H97</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H98</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H99</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s10) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H100</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s10) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s10) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H91</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H92</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s11)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H93</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s11)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H94</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s11) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H95</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s11) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H86</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s11 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H87</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s11) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H88</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s11) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H89</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s11) ! n = None \/
(st_datapath s10) ! n = (st_datapath s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H90</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s11) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s1 = st_datapath s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H81</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s11 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H82</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s11) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H83</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s11) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H84</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s11) ! n = None \/
(st_datapath s0) ! n = (st_datapath s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H85</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s11) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H76</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H77</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H78</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H79</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s10) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H80</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s11 = st_datapath s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H71</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H72</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H73</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H74</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H75</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H66</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s2 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H67</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s2) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H68</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s2) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H69</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s2) ! n = None \/
(st_datapath s10) ! n = (st_datapath s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H70</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s2) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s0 = st_datapath s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s2 = st_st s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s2) (st_freshreg s3)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s2) (st_freshstate s3)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s2) ! n = None \/
(st_datapath s3) ! n = (st_datapath s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s2) ! n = None \/
(st_controllogic s3) ! n =
(st_controllogic s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H61</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s3 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H62</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s3) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H63</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s3) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H64</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s3) ! n = None \/
(st_datapath s10) ! n = (st_datapath s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H65</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s3) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f)))
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f))))
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 (state_incr_intro s2 s3 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s3 = st_st s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s3) (st_freshreg s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s3) (st_freshstate s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s3) ! n = None \/
(st_datapath s4) ! n = (st_datapath s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s3) ! n = None \/
(st_controllogic s4) ! n =
(st_controllogic s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H56</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s4 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H57</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s4) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H58</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s4) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H59</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s4) ! n = None \/
(st_datapath s10) ! n = (st_datapath s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H60</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s4) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 =
OK tt s4 (state_incr_intro s3 s4 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H51</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s4 = st_st s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H52</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s4) (st_freshreg s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H53</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s4) (st_freshstate s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H54</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s4) ! n = None \/
(st_datapath s5) ! n = (st_datapath s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H55</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s4) ! n = None \/
(st_controllogic s5) ! n =
(st_controllogic s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H46</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s5 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H47</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s5) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H48</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s5) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H49</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s5) ! n = None \/
(st_datapath s10) ! n = (st_datapath s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H50</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s5) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s4 = st_datapath s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H41</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s5 = st_st s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H42</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s5) (st_freshreg s6)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H43</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s5) (st_freshstate s6)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H44</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s5) ! n = None \/
(st_datapath s6) ! n = (st_datapath s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H45</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s5) ! n = None \/
(st_controllogic s6) ! n =
(st_controllogic s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H36</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s6 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H37</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s6) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H38</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s6) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H39</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s6) ! n = None \/
(st_datapath s10) ! n = (st_datapath s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H40</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s6) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s5 = st_datapath s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H31</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s6 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H32</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s6) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H33</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s6) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H34</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s6) ! n = None \/
(st_datapath s10) ! n = (st_datapath s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H35</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s6) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H26</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s9 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H27</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s9) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H28</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s9) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H29</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s9) ! n = None \/
(st_datapath s10) ! n = (st_datapath s9) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H30</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s9) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s9) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s6 = st_datapath s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s8 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H22</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s8) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H23</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s8) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H24</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s8) ! n = None \/
(st_datapath s10) ! n = (st_datapath s8) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H25</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s8) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s8) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s7 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H17</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s7) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H18</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s7) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H19</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s7) ! n = None \/
(st_datapath s10) ! n = (st_datapath s7) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H20</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s7) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s7) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic s10)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic s10)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath s10)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath s10)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s11 =
Pos.succ
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (RTL.max_reg_function f))))) =
st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s6 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (RTL.max_reg_function f)))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s10 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (Pos.succ
                       (RTL.max_reg_function f))))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s6 = st_controllogic s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s5 = st_controllogic s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s4 = st_controllogic s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s11 = st_controllogic s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s1 = st_controllogic s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s0 = st_controllogic s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H101</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(RTL.fn_code f) ! pc = Some i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_code (RTL.fn_code f) pc i 
  (st_datapath s10) (st_controllogic s10)
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (Pos.succ
     (Pos.succ (Pos.succ (RTL.max_reg_function f))))
  (st_st s10)
  (Pos.succ
     (Pos.succ
        (Pos.succ (Pos.succ (RTL.max_reg_function f)))))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk111" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk111"><span class="highlight"><span class="nb">assert</span> (EQ3D := EQ3).</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H96</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H97</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H98</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H99</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s10) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H100</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s10) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s10) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H91</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H92</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s11)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H93</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s11)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H94</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s11) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H95</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s11) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H86</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s11 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H87</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s11) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H88</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s11) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H89</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s11) ! n = None \/
(st_datapath s10) ! n = (st_datapath s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H90</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s11) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s1 = st_datapath s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H81</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s11 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H82</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s11) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H83</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s11) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H84</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s11) ! n = None \/
(st_datapath s0) ! n = (st_datapath s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H85</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s11) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H76</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H77</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H78</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H79</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s10) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H80</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s11 = st_datapath s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H71</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H72</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H73</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H74</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H75</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H66</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s2 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H67</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s2) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H68</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s2) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H69</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s2) ! n = None \/
(st_datapath s10) ! n = (st_datapath s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H70</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s2) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s0 = st_datapath s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s2 = st_st s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s2) (st_freshreg s3)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s2) (st_freshstate s3)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s2) ! n = None \/
(st_datapath s3) ! n = (st_datapath s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s2) ! n = None \/
(st_controllogic s3) ! n =
(st_controllogic s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H61</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s3 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H62</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s3) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H63</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s3) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H64</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s3) ! n = None \/
(st_datapath s10) ! n = (st_datapath s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H65</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s3) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f)))
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f))))
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 (state_incr_intro s2 s3 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s3 = st_st s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s3) (st_freshreg s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s3) (st_freshstate s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s3) ! n = None \/
(st_datapath s4) ! n = (st_datapath s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s3) ! n = None \/
(st_controllogic s4) ! n =
(st_controllogic s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H56</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s4 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H57</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s4) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H58</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s4) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H59</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s4) ! n = None \/
(st_datapath s10) ! n = (st_datapath s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H60</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s4) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt; declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 =
OK tt s4 (state_incr_intro s3 s4 e p p0 o o0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H51</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s4 = st_st s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H52</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s4) (st_freshreg s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H53</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s4) (st_freshstate s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H54</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s4) ! n = None \/
(st_datapath s5) ! n = (st_datapath s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H55</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s4) ! n = None \/
(st_controllogic s5) ! n =
(st_controllogic s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H46</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s5 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H47</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s5) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H48</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s5) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H49</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s5) ! n = None \/
(st_datapath s10) ! n = (st_datapath s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H50</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s5) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s4 = st_datapath s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H41</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s5 = st_st s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H42</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s5) (st_freshreg s6)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H43</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s5) (st_freshstate s6)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H44</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s5) ! n = None \/
(st_datapath s6) ! n = (st_datapath s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H45</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s5) ! n = None \/
(st_controllogic s6) ! n =
(st_controllogic s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H36</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s6 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H37</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s6) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H38</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s6) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H39</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s6) ! n = None \/
(st_datapath s10) ! n = (st_datapath s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H40</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s6) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s5 = st_datapath s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H31</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s6 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H32</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s6) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H33</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s6) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H34</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s6) ! n = None \/
(st_datapath s10) ! n = (st_datapath s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H35</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s6) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H26</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s9 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H27</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s9) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H28</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s9) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H29</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s9) ! n = None \/
(st_datapath s10) ! n = (st_datapath s9) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H30</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s9) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s9) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s6 = st_datapath s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s8 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H22</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s8) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H23</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s8) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H24</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s8) ! n = None \/
(st_datapath s10) ! n = (st_datapath s8) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H25</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s8) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s8) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s7 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H17</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s7) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H18</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s7) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H19</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s7) ! n = None \/
(st_datapath s10) ! n = (st_datapath s7) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H20</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s7) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s7) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic s10)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic s10)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath s10)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath s10)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s11 =
Pos.succ
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (RTL.max_reg_function f))))) =
st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s6 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (RTL.max_reg_function f)))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s10 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (Pos.succ
                       (RTL.max_reg_function f))))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s6 = st_controllogic s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s5 = st_controllogic s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s4 = st_controllogic s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s11 = st_controllogic s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s1 = st_controllogic s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s0 = st_controllogic s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H101</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(RTL.fn_code f) ! pc = Some i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt;
   declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 =
OK tt s4 (state_incr_intro s3 s4 e p p0 o o0)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_code (RTL.fn_code f) pc i 
  (st_datapath s10) (st_controllogic s10)
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (Pos.succ
     (Pos.succ (Pos.succ (RTL.max_reg_function f))))
  (st_st s10)
  (Pos.succ
     (Pos.succ
        (Pos.succ (Pos.succ (RTL.max_reg_function f)))))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk112" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk112"><span class="highlight"><span class="nb">apply</span> collect_declare_datapath_trans <span class="kr">in</span> EQ3.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H96</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H97</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H98</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H99</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s10) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H100</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s10) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s10) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H91</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H92</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s11)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H93</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s11)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H94</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s11) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H95</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s11) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H86</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s11 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H87</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s11) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H88</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s11) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H89</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s11) ! n = None \/
(st_datapath s10) ! n = (st_datapath s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H90</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s11) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s1 = st_datapath s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H81</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s11 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H82</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s11) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H83</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s11) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H84</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s11) ! n = None \/
(st_datapath s0) ! n = (st_datapath s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H85</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s11) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H76</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H77</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H78</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H79</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s10) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H80</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s11 = st_datapath s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H71</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H72</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H73</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H74</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H75</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H66</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s2 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H67</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s2) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H68</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s2) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H69</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s2) ! n = None \/
(st_datapath s10) ! n = (st_datapath s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H70</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s2) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s0 = st_datapath s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s2 = st_st s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s2) (st_freshreg s3)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s2) (st_freshstate s3)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s2) ! n = None \/
(st_datapath s3) ! n = (st_datapath s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s2) ! n = None \/
(st_controllogic s3) ! n =
(st_controllogic s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H61</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s3 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H62</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s3) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H63</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s3) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H64</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s3) ! n = None \/
(st_datapath s10) ! n = (st_datapath s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H65</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s3) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f)))
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f))))
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 (state_incr_intro s2 s3 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s3 = st_st s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s3) (st_freshreg s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s3) (st_freshstate s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s3) ! n = None \/
(st_datapath s4) ! n = (st_datapath s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s3) ! n = None \/
(st_controllogic s4) ! n =
(st_controllogic s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H56</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s4 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H57</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s4) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H58</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s4) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H59</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s4) ! n = None \/
(st_datapath s10) ! n = (st_datapath s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H60</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s4) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s3 = st_datapath s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H51</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s4 = st_st s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H52</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s4) (st_freshreg s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H53</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s4) (st_freshstate s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H54</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s4) ! n = None \/
(st_datapath s5) ! n = (st_datapath s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H55</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s4) ! n = None \/
(st_controllogic s5) ! n =
(st_controllogic s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H46</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s5 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H47</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s5) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H48</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s5) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H49</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s5) ! n = None \/
(st_datapath s10) ! n = (st_datapath s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H50</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s5) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s4 = st_datapath s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H41</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s5 = st_st s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H42</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s5) (st_freshreg s6)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H43</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s5) (st_freshstate s6)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H44</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s5) ! n = None \/
(st_datapath s6) ! n = (st_datapath s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H45</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s5) ! n = None \/
(st_controllogic s6) ! n =
(st_controllogic s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H36</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s6 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H37</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s6) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H38</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s6) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H39</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s6) ! n = None \/
(st_datapath s10) ! n = (st_datapath s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H40</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s6) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s5 = st_datapath s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H31</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s6 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H32</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s6) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H33</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s6) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H34</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s6) ! n = None \/
(st_datapath s10) ! n = (st_datapath s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H35</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s6) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H26</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s9 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H27</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s9) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H28</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s9) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H29</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s9) ! n = None \/
(st_datapath s10) ! n = (st_datapath s9) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H30</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s9) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s9) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s6 = st_datapath s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s8 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H22</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s8) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H23</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s8) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H24</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s8) ! n = None \/
(st_datapath s10) ! n = (st_datapath s8) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H25</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s8) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s8) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s7 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H17</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s7) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H18</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s7) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H19</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s7) ! n = None \/
(st_datapath s10) ! n = (st_datapath s7) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H20</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s7) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s7) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic s10)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic s10)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath s10)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath s10)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s11 =
Pos.succ
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (RTL.max_reg_function f))))) =
st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s6 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (RTL.max_reg_function f)))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s10 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (Pos.succ
                       (RTL.max_reg_function f))))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s6 = st_controllogic s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s5 = st_controllogic s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s4 = st_controllogic s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s11 = st_controllogic s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s1 = st_controllogic s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s0 = st_controllogic s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H101</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(RTL.fn_code f) ! pc = Some i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (<span class="kr">fun</span> <span class="nv">r</span> : reg =&gt;
   declare_reg (Some Vinput) r <span class="mi">32</span>)
  (RTL.fn_params f) s3 =
OK tt s4 (state_incr_intro s3 s4 e p p0 o o0)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_code (RTL.fn_code f) pc i 
  (st_datapath s10) (st_controllogic s10)
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (Pos.succ
     (Pos.succ (Pos.succ (RTL.max_reg_function f))))
  (st_st s10)
  (Pos.succ
     (Pos.succ
        (Pos.succ (Pos.succ (RTL.max_reg_function f)))))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk113" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk113"><span class="highlight"><span class="nb">apply</span> collect_declare_controllogic_trans <span class="kr">in</span> EQ3D.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H96</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H97</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H98</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H99</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s10) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H100</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s10) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s10) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H91</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H92</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s11)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H93</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s11)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H94</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s11) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H95</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s11) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H86</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s11 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H87</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s11) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H88</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s11) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H89</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s11) ! n = None \/
(st_datapath s10) ! n = (st_datapath s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H90</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s11) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s1 = st_datapath s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H81</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s11 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H82</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s11) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H83</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s11) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H84</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s11) ! n = None \/
(st_datapath s0) ! n = (st_datapath s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H85</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s11) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H76</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H77</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H78</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H79</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s10) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H80</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s11 = st_datapath s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H71</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H72</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H73</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H74</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H75</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H66</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s2 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H67</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s2) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H68</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s2) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H69</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s2) ! n = None \/
(st_datapath s10) ! n = (st_datapath s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H70</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s2) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s0 = st_datapath s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s2 = st_st s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s2) (st_freshreg s3)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s2) (st_freshstate s3)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s2) ! n = None \/
(st_datapath s3) ! n = (st_datapath s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s2) ! n = None \/
(st_controllogic s3) ! n =
(st_controllogic s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H61</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s3 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H62</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s3) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H63</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s3) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H64</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s3) ! n = None \/
(st_datapath s10) ! n = (st_datapath s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H65</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s3) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f)))
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f))))
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 (state_incr_intro s2 s3 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s3 = st_st s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s3) (st_freshreg s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s3) (st_freshstate s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s3) ! n = None \/
(st_datapath s4) ! n = (st_datapath s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s3) ! n = None \/
(st_controllogic s4) ! n =
(st_controllogic s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H56</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s4 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H57</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s4) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H58</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s4) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H59</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s4) ! n = None \/
(st_datapath s10) ! n = (st_datapath s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H60</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s4) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s3 = st_datapath s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H51</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s4 = st_st s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H52</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s4) (st_freshreg s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H53</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s4) (st_freshstate s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H54</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s4) ! n = None \/
(st_datapath s5) ! n = (st_datapath s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H55</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s4) ! n = None \/
(st_controllogic s5) ! n =
(st_controllogic s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H46</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s5 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H47</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s5) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H48</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s5) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H49</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s5) ! n = None \/
(st_datapath s10) ! n = (st_datapath s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H50</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s5) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s4 = st_datapath s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H41</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s5 = st_st s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H42</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s5) (st_freshreg s6)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H43</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s5) (st_freshstate s6)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H44</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s5) ! n = None \/
(st_datapath s6) ! n = (st_datapath s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H45</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s5) ! n = None \/
(st_controllogic s6) ! n =
(st_controllogic s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H36</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s6 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H37</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s6) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H38</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s6) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H39</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s6) ! n = None \/
(st_datapath s10) ! n = (st_datapath s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H40</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s6) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s5 = st_datapath s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H31</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s6 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H32</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s6) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H33</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s6) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H34</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s6) ! n = None \/
(st_datapath s10) ! n = (st_datapath s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H35</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s6) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H26</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s9 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H27</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s9) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H28</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s9) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H29</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s9) ! n = None \/
(st_datapath s10) ! n = (st_datapath s9) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H30</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s9) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s9) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s6 = st_datapath s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s8 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H22</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s8) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H23</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s8) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H24</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s8) ! n = None \/
(st_datapath s10) ! n = (st_datapath s8) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H25</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s8) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s8) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s7 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H17</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s7) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H18</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s7) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H19</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s7) ! n = None \/
(st_datapath s10) ! n = (st_datapath s7) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H20</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s7) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s7) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic s10)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic s10)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath s10)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath s10)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s11 =
Pos.succ
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (RTL.max_reg_function f))))) =
st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s6 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (RTL.max_reg_function f)))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s10 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (Pos.succ
                       (RTL.max_reg_function f))))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s6 = st_controllogic s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s5 = st_controllogic s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s4 = st_controllogic s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s11 = st_controllogic s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s1 = st_controllogic s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s0 = st_controllogic s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H101</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(RTL.fn_code f) ! pc = Some i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s3 = st_controllogic s4</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_code (RTL.fn_code f) pc i 
  (st_datapath s10) (st_controllogic s10)
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (Pos.succ
     (Pos.succ (Pos.succ (RTL.max_reg_function f))))
  (st_st s10)
  (Pos.succ
     (Pos.succ
        (Pos.succ (Pos.succ (RTL.max_reg_function f)))))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk114" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk114"><span class="highlight"><span class="nb">replace</span> (st_controllogic s10) <span class="kr">with</span> (st_controllogic s3) <span class="bp">by</span> <span class="bp">congruence</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H96</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H97</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H98</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H99</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s10) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H100</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s10) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s10) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H91</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H92</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s11)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H93</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s11)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H94</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s11) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H95</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s11) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H86</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s11 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H87</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s11) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H88</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s11) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H89</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s11) ! n = None \/
(st_datapath s10) ! n = (st_datapath s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H90</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s11) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s1 = st_datapath s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H81</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s11 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H82</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s11) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H83</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s11) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H84</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s11) ! n = None \/
(st_datapath s0) ! n = (st_datapath s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H85</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s11) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H76</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H77</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H78</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H79</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s10) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H80</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s11 = st_datapath s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H71</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H72</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H73</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H74</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H75</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H66</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s2 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H67</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s2) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H68</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s2) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H69</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s2) ! n = None \/
(st_datapath s10) ! n = (st_datapath s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H70</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s2) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s0 = st_datapath s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s2 = st_st s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s2) (st_freshreg s3)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s2) (st_freshstate s3)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s2) ! n = None \/
(st_datapath s3) ! n = (st_datapath s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s2) ! n = None \/
(st_controllogic s3) ! n =
(st_controllogic s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H61</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s3 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H62</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s3) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H63</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s3) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H64</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s3) ! n = None \/
(st_datapath s10) ! n = (st_datapath s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H65</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s3) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f)))
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f))))
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 (state_incr_intro s2 s3 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s3 = st_st s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s3) (st_freshreg s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s3) (st_freshstate s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s3) ! n = None \/
(st_datapath s4) ! n = (st_datapath s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s3) ! n = None \/
(st_controllogic s4) ! n =
(st_controllogic s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H56</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s4 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H57</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s4) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H58</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s4) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H59</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s4) ! n = None \/
(st_datapath s10) ! n = (st_datapath s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H60</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s4) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s3 = st_datapath s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H51</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s4 = st_st s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H52</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s4) (st_freshreg s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H53</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s4) (st_freshstate s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H54</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s4) ! n = None \/
(st_datapath s5) ! n = (st_datapath s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H55</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s4) ! n = None \/
(st_controllogic s5) ! n =
(st_controllogic s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H46</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s5 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H47</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s5) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H48</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s5) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H49</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s5) ! n = None \/
(st_datapath s10) ! n = (st_datapath s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H50</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s5) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s4 = st_datapath s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H41</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s5 = st_st s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H42</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s5) (st_freshreg s6)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H43</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s5) (st_freshstate s6)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H44</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s5) ! n = None \/
(st_datapath s6) ! n = (st_datapath s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H45</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s5) ! n = None \/
(st_controllogic s6) ! n =
(st_controllogic s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H36</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s6 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H37</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s6) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H38</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s6) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H39</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s6) ! n = None \/
(st_datapath s10) ! n = (st_datapath s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H40</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s6) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s5 = st_datapath s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H31</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s6 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H32</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s6) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H33</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s6) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H34</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s6) ! n = None \/
(st_datapath s10) ! n = (st_datapath s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H35</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s6) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H26</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s9 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H27</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s9) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H28</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s9) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H29</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s9) ! n = None \/
(st_datapath s10) ! n = (st_datapath s9) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H30</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s9) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s9) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s6 = st_datapath s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s8 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H22</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s8) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H23</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s8) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H24</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s8) ! n = None \/
(st_datapath s10) ! n = (st_datapath s8) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H25</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s8) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s8) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s7 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H17</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s7) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H18</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s7) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H19</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s7) ! n = None \/
(st_datapath s10) ! n = (st_datapath s7) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H20</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s7) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s7) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic s10)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic s10)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath s10)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath s10)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s11 =
Pos.succ
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (RTL.max_reg_function f))))) =
st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s6 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (RTL.max_reg_function f)))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s10 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (Pos.succ
                       (RTL.max_reg_function f))))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s6 = st_controllogic s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s5 = st_controllogic s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s4 = st_controllogic s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s11 = st_controllogic s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s1 = st_controllogic s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s0 = st_controllogic s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H101</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(RTL.fn_code f) ! pc = Some i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s3 = st_controllogic s4</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_code (RTL.fn_code f) pc i 
  (st_datapath s10) (st_controllogic s3)
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (Pos.succ
     (Pos.succ (Pos.succ (RTL.max_reg_function f))))
  (st_st s10)
  (Pos.succ
     (Pos.succ
        (Pos.succ (Pos.succ (RTL.max_reg_function f)))))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk115" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk115"><span class="highlight"><span class="nb">replace</span> (st_datapath s10) <span class="kr">with</span> (st_datapath s3) <span class="bp">by</span> <span class="bp">congruence</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H96</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H97</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H98</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H99</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s10) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H100</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s10) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s10) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H91</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H92</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s11)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H93</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s11)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H94</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s11) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H95</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s11) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H86</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s11 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H87</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s11) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H88</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s11) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H89</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s11) ! n = None \/
(st_datapath s10) ! n = (st_datapath s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H90</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s11) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s1 = st_datapath s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H81</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s11 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H82</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s11) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H83</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s11) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H84</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s11) ! n = None \/
(st_datapath s0) ! n = (st_datapath s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H85</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s11) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H76</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H77</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H78</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H79</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s10) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H80</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s11 = st_datapath s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H71</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H72</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H73</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H74</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H75</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H66</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s2 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H67</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s2) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H68</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s2) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H69</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s2) ! n = None \/
(st_datapath s10) ! n = (st_datapath s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H70</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s2) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s0 = st_datapath s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s2 = st_st s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s2) (st_freshreg s3)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s2) (st_freshstate s3)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s2) ! n = None \/
(st_datapath s3) ! n = (st_datapath s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s2) ! n = None \/
(st_controllogic s3) ! n =
(st_controllogic s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H61</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s3 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H62</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s3) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H63</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s3) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H64</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s3) ! n = None \/
(st_datapath s10) ! n = (st_datapath s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H65</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s3) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f)))
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f))))
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 (state_incr_intro s2 s3 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s3 = st_st s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s3) (st_freshreg s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s3) (st_freshstate s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s3) ! n = None \/
(st_datapath s4) ! n = (st_datapath s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s3) ! n = None \/
(st_controllogic s4) ! n =
(st_controllogic s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H56</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s4 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H57</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s4) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H58</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s4) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H59</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s4) ! n = None \/
(st_datapath s10) ! n = (st_datapath s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H60</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s4) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s3 = st_datapath s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H51</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s4 = st_st s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H52</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s4) (st_freshreg s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H53</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s4) (st_freshstate s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H54</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s4) ! n = None \/
(st_datapath s5) ! n = (st_datapath s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H55</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s4) ! n = None \/
(st_controllogic s5) ! n =
(st_controllogic s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H46</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s5 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H47</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s5) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H48</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s5) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H49</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s5) ! n = None \/
(st_datapath s10) ! n = (st_datapath s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H50</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s5) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s4 = st_datapath s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H41</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s5 = st_st s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H42</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s5) (st_freshreg s6)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H43</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s5) (st_freshstate s6)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H44</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s5) ! n = None \/
(st_datapath s6) ! n = (st_datapath s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H45</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s5) ! n = None \/
(st_controllogic s6) ! n =
(st_controllogic s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H36</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s6 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H37</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s6) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H38</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s6) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H39</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s6) ! n = None \/
(st_datapath s10) ! n = (st_datapath s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H40</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s6) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s5 = st_datapath s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H31</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s6 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H32</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s6) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H33</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s6) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H34</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s6) ! n = None \/
(st_datapath s10) ! n = (st_datapath s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H35</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s6) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H26</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s9 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H27</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s9) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H28</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s9) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H29</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s9) ! n = None \/
(st_datapath s10) ! n = (st_datapath s9) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H30</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s9) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s9) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s6 = st_datapath s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s8 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H22</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s8) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H23</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s8) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H24</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s8) ! n = None \/
(st_datapath s10) ! n = (st_datapath s8) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H25</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s8) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s8) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s7 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H17</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s7) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H18</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s7) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H19</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s7) ! n = None \/
(st_datapath s10) ! n = (st_datapath s7) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H20</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s7) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s7) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic s10)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic s10)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath s10)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath s10)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s11 =
Pos.succ
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (RTL.max_reg_function f))))) =
st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s6 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (RTL.max_reg_function f)))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s10 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (Pos.succ
                       (RTL.max_reg_function f))))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s6 = st_controllogic s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s5 = st_controllogic s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s4 = st_controllogic s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s11 = st_controllogic s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s1 = st_controllogic s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s0 = st_controllogic s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H101</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(RTL.fn_code f) ! pc = Some i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s3 = st_controllogic s4</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_code (RTL.fn_code f) pc i 
  (st_datapath s3) (st_controllogic s3)
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (Pos.succ
     (Pos.succ (Pos.succ (RTL.max_reg_function f))))
  (st_st s10)
  (Pos.succ
     (Pos.succ
        (Pos.succ (Pos.succ (RTL.max_reg_function f)))))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk116" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk116"><span class="highlight"><span class="nb">replace</span> (st_st s10) <span class="kr">with</span> (st_st s3) <span class="bp">by</span> <span class="bp">congruence</span>.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H96</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H97</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H98</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H99</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s10) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H100</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s10) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s10) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H91</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H92</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s11)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H93</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s11)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H94</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s11) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H95</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s11) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H86</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s11 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H87</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s11) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H88</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s11) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H89</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s11) ! n = None \/
(st_datapath s10) ! n = (st_datapath s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H90</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s11) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s1 = st_datapath s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H81</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s11 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H82</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s11) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H83</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s11) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H84</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s11) ! n = None \/
(st_datapath s0) ! n = (st_datapath s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H85</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s11) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H76</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H77</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H78</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H79</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s10) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H80</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s11 = st_datapath s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H71</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H72</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H73</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H74</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H75</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H66</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s2 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H67</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s2) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H68</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s2) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H69</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s2) ! n = None \/
(st_datapath s10) ! n = (st_datapath s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H70</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s2) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s0 = st_datapath s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s2 = st_st s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s2) (st_freshreg s3)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s2) (st_freshstate s3)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s2) ! n = None \/
(st_datapath s3) ! n = (st_datapath s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s2) ! n = None \/
(st_controllogic s3) ! n =
(st_controllogic s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H61</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s3 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H62</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s3) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H63</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s3) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H64</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s3) ! n = None \/
(st_datapath s10) ! n = (st_datapath s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H65</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s3) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f)))
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f))))
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 (state_incr_intro s2 s3 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s3 = st_st s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s3) (st_freshreg s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s3) (st_freshstate s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s3) ! n = None \/
(st_datapath s4) ! n = (st_datapath s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s3) ! n = None \/
(st_controllogic s4) ! n =
(st_controllogic s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H56</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s4 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H57</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s4) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H58</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s4) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H59</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s4) ! n = None \/
(st_datapath s10) ! n = (st_datapath s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H60</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s4) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s3 = st_datapath s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H51</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s4 = st_st s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H52</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s4) (st_freshreg s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H53</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s4) (st_freshstate s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H54</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s4) ! n = None \/
(st_datapath s5) ! n = (st_datapath s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H55</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s4) ! n = None \/
(st_controllogic s5) ! n =
(st_controllogic s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H46</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s5 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H47</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s5) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H48</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s5) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H49</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s5) ! n = None \/
(st_datapath s10) ! n = (st_datapath s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H50</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s5) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s4 = st_datapath s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H41</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s5 = st_st s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H42</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s5) (st_freshreg s6)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H43</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s5) (st_freshstate s6)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H44</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s5) ! n = None \/
(st_datapath s6) ! n = (st_datapath s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H45</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s5) ! n = None \/
(st_controllogic s6) ! n =
(st_controllogic s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H36</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s6 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H37</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s6) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H38</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s6) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H39</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s6) ! n = None \/
(st_datapath s10) ! n = (st_datapath s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H40</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s6) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s5 = st_datapath s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H31</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s6 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H32</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s6) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H33</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s6) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H34</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s6) ! n = None \/
(st_datapath s10) ! n = (st_datapath s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H35</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s6) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H26</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s9 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H27</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s9) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H28</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s9) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H29</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s9) ! n = None \/
(st_datapath s10) ! n = (st_datapath s9) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H30</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s9) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s9) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s6 = st_datapath s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s8 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H22</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s8) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H23</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s8) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H24</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s8) ! n = None \/
(st_datapath s10) ! n = (st_datapath s8) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H25</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s8) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s8) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s7 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H17</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s7) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H18</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s7) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H19</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s7) ! n = None \/
(st_datapath s10) ! n = (st_datapath s7) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H20</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s7) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s7) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic s10)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic s10)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath s10)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath s10)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s11 =
Pos.succ
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (RTL.max_reg_function f))))) =
st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s6 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (RTL.max_reg_function f)))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s10 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (Pos.succ
                       (RTL.max_reg_function f))))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s6 = st_controllogic s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s5 = st_controllogic s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s4 = st_controllogic s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s11 = st_controllogic s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s1 = st_controllogic s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s0 = st_controllogic s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H101</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(RTL.fn_code f) ! pc = Some i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s3 = st_controllogic s4</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tr_code (RTL.fn_code f) pc i 
  (st_datapath s3) (st_controllogic s3)
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (Pos.succ
     (Pos.succ (Pos.succ (RTL.max_reg_function f))))
  (st_st s3)
  (Pos.succ
     (Pos.succ
        (Pos.succ (Pos.succ (RTL.max_reg_function f)))))</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><input class="coq-toggle" id="htlgenspec-v-chk117" style="display: none" type="checkbox"><label class="coq-input" for="htlgenspec-v-chk117"><span class="highlight"><span class="nb">eapply</span> iter_expand_instr_spec; <span class="nb">eauto with</span> htlspec.</span></label><small class="coq-output"><div class="coq-output-sticky-wrapper"><div class="coq-goals"><blockquote class="coq-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.function</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s1, s10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H96</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H97</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H98</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H99</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s10) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H100</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_LOW</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= RTL.fn_stacksize f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_BOUND_HIGH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f &lt; <span class="mi">4294967296</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">STACK_ALIGN</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.fn_stacksize f mod <span class="mi">4</span> = <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ (RTL.max_reg_function f) = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))
  (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (Pos.succ (RTL.max_pc_function f))
  (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_datapath s10) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(AssocMap.empty stmnt) ! n = None \/
(st_controllogic s10) ! n =
(AssocMap.empty stmnt) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H91</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s1 = st_st s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H92</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s1) (st_freshreg s11)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H93</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s1) (st_freshstate s11)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H94</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s1) ! n = None \/
(st_datapath s11) ! n = (st_datapath s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H95</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s1) ! n = None \/
(st_controllogic s11) ! n =
(st_controllogic s1) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H86</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s11 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H87</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s11) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H88</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s11) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H89</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s11) ! n = None \/
(st_datapath s10) ! n = (st_datapath s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H90</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s11) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s1 = st_datapath s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H81</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s11 = st_st s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H82</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s11) (st_freshreg s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H83</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s11) (st_freshstate s0)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H84</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s11) ! n = None \/
(st_datapath s0) ! n = (st_datapath s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H85</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s11) ! n = None \/
(st_controllogic s0) ! n =
(st_controllogic s11) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H76</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H77</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H78</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H79</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s10) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H80</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s11 = st_datapath s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H71</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s0 = st_st s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H72</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s0) (st_freshreg s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H73</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s0) (st_freshstate s2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H74</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s0) ! n = None \/
(st_datapath s2) ! n = (st_datapath s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H75</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s0) ! n = None \/
(st_controllogic s2) ! n =
(st_controllogic s0) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H66</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s2 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H67</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s2) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H68</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s2) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H69</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s2) ! n = None \/
(st_datapath s10) ! n = (st_datapath s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H70</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s2) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s0 = st_datapath s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s2 = st_st s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s2) (st_freshreg s3)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s2) (st_freshstate s3)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s2) ! n = None \/
(st_datapath s3) ! n = (st_datapath s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s2) ! n = None \/
(st_controllogic s3) ! n =
(st_controllogic s2) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H61</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s3 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H62</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s3) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H63</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s3) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H64</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s3) ! n = None \/
(st_datapath s10) ! n = (st_datapath s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H65</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s3) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">HTLMonadExtra.collectlist
  (transf_instr
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f)))
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f))))
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))
  (PTree.elements (RTL.fn_code f)) s2 =
OK tt s3 (state_incr_intro s2 s3 e0 p1 p2 o1 o2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s3 = st_st s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s3) (st_freshreg s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s3) (st_freshstate s4)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s3) ! n = None \/
(st_datapath s4) ! n = (st_datapath s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">o0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s3) ! n = None \/
(st_controllogic s4) ! n =
(st_controllogic s3) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H56</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s4 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H57</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s4) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H58</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s4) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H59</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s4) ! n = None \/
(st_datapath s10) ! n = (st_datapath s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H60</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s4) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s3 = st_datapath s4</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H51</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s4 = st_st s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H52</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s4) (st_freshreg s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H53</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s4) (st_freshstate s5)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H54</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s4) ! n = None \/
(st_datapath s5) ! n = (st_datapath s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H55</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s4) ! n = None \/
(st_controllogic s5) ! n =
(st_controllogic s4) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H46</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s5 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H47</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s5) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H48</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s5) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H49</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s5) ! n = None \/
(st_datapath s10) ! n = (st_datapath s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H50</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s5) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s4 = st_datapath s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H41</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s5 = st_st s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H42</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s5) (st_freshreg s6)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H43</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s5) (st_freshstate s6)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H44</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s5) ! n = None \/
(st_datapath s6) ! n = (st_datapath s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H45</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s5) ! n = None \/
(st_controllogic s6) ! n =
(st_controllogic s5) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H36</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s6 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H37</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s6) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H38</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s6) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H39</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s6) ! n = None \/
(st_datapath s10) ! n = (st_datapath s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H40</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s6) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s5 = st_datapath s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H31</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s6 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H32</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s6) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H33</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s6) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H34</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s6) ! n = None \/
(st_datapath s10) ! n = (st_datapath s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H35</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s6) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s6) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H26</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s9 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H27</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s9) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H28</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s9) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H29</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s9) ! n = None \/
(st_datapath s10) ! n = (st_datapath s9) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H30</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s9) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s9) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_datapath s6 = st_datapath s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s8 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H22</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s8) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H23</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s8) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H24</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s8) ! n = None \/
(st_datapath s10) ! n = (st_datapath s8) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H25</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s8) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s8) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H16</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_st s7 = st_st s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H17</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshreg s7) (st_freshreg s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H18</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Ple (st_freshstate s7) (st_freshstate s10)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H19</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_datapath s7) ! n = None \/
(st_datapath s10) ! n = (st_datapath s7) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H20</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : positive,
(st_controllogic s7) ! n = None \/
(st_controllogic s10) ! n =
(st_controllogic s7) ! n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_controllogic s10)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_controllogic s10)))
  Int.max_unsigned = <span class="nb">left</span> l0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Z.pos (max_pc_map (st_datapath s10)) &lt;=
Int.max_unsigned</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Heqs9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">zle (Z.pos (max_pc_map (st_datapath s10)))
  Int.max_unsigned = <span class="nb">left</span> l</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s2 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s11 =
Pos.succ
  (Pos.succ (Pos.succ (RTL.max_reg_function f)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s0 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ (RTL.max_reg_function f))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_INSTR</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (RTL.max_reg_function f))))) =
st_freshreg s3</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">TR_DEC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s3 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ (RTL.max_reg_function f)))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H8</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s5 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ (RTL.max_reg_function f))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H9</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s6 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (RTL.max_reg_function f)))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H10</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_freshreg s10 =
Pos.succ
  (Pos.succ
     (Pos.succ
        (Pos.succ
           (Pos.succ
              (Pos.succ
                 (Pos.succ
                    (Pos.succ
                       (RTL.max_reg_function f))))))))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s6 = st_controllogic s10</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H11</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s5 = st_controllogic s6</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s4 = st_controllogic s5</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H13</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s11 = st_controllogic s0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H14</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s1 = st_controllogic s11</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H15</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s0 = st_controllogic s2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">pc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RTL.instruction</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H101</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(RTL.fn_code f) ! pc = Some i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">EQ3D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st_controllogic s3 = st_controllogic s4</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">pc</span> : node) (<span class="nv">instr</span> : RTL.instruction),
In (pc, instr) (PTree.elements (RTL.fn_code f)) -&gt;
(RTL.fn_code f) ! pc = Some instr</span></div></blockquote></div></div></small><span class="coq-wsp">
</span></span><span class="coq-wsp">  </span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="nb">apply</span> PTree.elements_complete.</span></span><span class="coq-wsp">
</span></span><span class="coq-sentence"><span class="coq-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div></dd>
</dl>
</div>
</div></body>
</html>
