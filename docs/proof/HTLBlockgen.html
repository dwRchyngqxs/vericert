<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.16: http://docutils.sourceforge.net/" />
<title>HTLBlockgen.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
</head>
<body>
<div class="alectryon-root alectryon-floating"><div class="document">


<pre class="alectryon-io"><!-- Generator: Alectryon v1.0 --><span class="coq-wsp"><span class="highlight"><span class="c">(* </span>
<span class="c"> * Vericert: Verified high-level synthesis.</span>
<span class="c"> * Copyright (C) 2020 Yann Herklotz &lt;yann@yannherklotz.com&gt;</span>
<span class="c"> *</span>
<span class="c"> * This program is free software: you can redistribute it and/or modify</span>
<span class="c"> * it under the terms of the GNU General Public License as published by</span>
<span class="c"> * the Free Software Foundation, either version 3 of the License, or</span>
<span class="c"> * (at your option) any later version.</span>
<span class="c"> *</span>
<span class="c"> * This program is distributed in the hope that it will be useful,</span>
<span class="c"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"> * GNU General Public License for more details.</span>
<span class="c"> *</span>
<span class="c"> * You should have received a copy of the GNU General Public License</span>
<span class="c"> * along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>
<span class="c"> *)</span>

<span class="c">(*From compcert Require Import Maps.</span>
<span class="c">From compcert Require Errors Globalenvs Integers.</span>
<span class="c">From compcert Require Import AST.</span>
<span class="c">From vericert Require Import RTLBlock Verilog HTL Vericertlib AssocMap ValueInt Statemonad.</span>

<span class="c">Hint Resolve AssocMap.gempty : htlh.</span>
<span class="c">Hint Resolve AssocMap.gso : htlh.</span>
<span class="c">Hint Resolve AssocMap.gss : htlh.</span>
<span class="c">Hint Resolve Ple_refl : htlh.</span>
<span class="c">Hint Resolve Ple_succ : htlh.</span>

<span class="c">Record state: Type := mkstate {</span>
<span class="c">  st_st : reg;</span>
<span class="c">  st_freshreg: reg;</span>
<span class="c">  st_freshstate: node;</span>
<span class="c">  st_scldecls: AssocMap.t (option io * scl_decl);</span>
<span class="c">  st_arrdecls: AssocMap.t (option io * arr_decl);</span>
<span class="c">  st_datapath: datapath;</span>
<span class="c">  st_controllogic: controllogic;</span>
<span class="c">}.</span>

<span class="c">Definition init_state (st : reg) : state :=</span>
<span class="c">  mkstate st</span>
<span class="c">          1%positive</span>
<span class="c">          1%positive</span>
<span class="c">          (AssocMap.empty (option io * scl_decl))</span>
<span class="c">          (AssocMap.empty (option io * arr_decl))</span>
<span class="c">          (AssocMap.empty stmnt)</span>
<span class="c">          (AssocMap.empty stmnt).</span>

<span class="c">Module HTLState &lt;: State.</span>

<span class="c">  Definition st := state.</span>

<span class="c">  Inductive st_incr: state -&gt; state -&gt; Prop :=</span>
<span class="c">    state_incr_intro:</span>
<span class="c">      forall (s1 s2: state),</span>
<span class="c">        st_st s1 = st_st s2 -&gt;</span>
<span class="c">        Ple s1.(st_freshreg) s2.(st_freshreg) -&gt;</span>
<span class="c">        Ple s1.(st_freshstate) s2.(st_freshstate) -&gt;</span>
<span class="c">        (forall n,</span>
<span class="c">            s1.(st_datapath)!n = None \/ s2.(st_datapath)!n = s1.(st_datapath)!n) -&gt;</span>
<span class="c">        (forall n,</span>
<span class="c">            s1.(st_controllogic)!n = None</span>
<span class="c">            \/ s2.(st_controllogic)!n = s1.(st_controllogic)!n) -&gt;</span>
<span class="c">        st_incr s1 s2.</span>
<span class="c">  Hint Constructors st_incr : htlh.</span>

<span class="c">  Definition st_prop := st_incr.</span>
<span class="c">  Hint Unfold st_prop : htlh.</span>

<span class="c">  Lemma st_refl : forall s, st_prop s s. Proof. auto with htlh. Qed.</span>

<span class="c">  Lemma st_trans :</span>
<span class="c">    forall s1 s2 s3, st_prop s1 s2 -&gt; st_prop s2 s3 -&gt; st_prop s1 s3.</span>
<span class="c">  Proof.</span>
<span class="c">    intros. inv H. inv H0. apply state_incr_intro; eauto using Ple_trans; intros; try congruence.</span>
<span class="c">    - destruct H4 with n; destruct H8 with n; intuition congruence.</span>
<span class="c">    - destruct H5 with n; destruct H9 with n; intuition congruence.</span>
<span class="c">  Qed.</span>

<span class="c">End HTLState.</span>
<span class="c">Export HTLState.</span>

<span class="c">Module HTLMonad := Statemonad(HTLState).</span>
<span class="c">Export HTLMonad.</span>

<span class="c">Module HTLMonadExtra := Monad.MonadExtra(HTLMonad).</span>
<span class="c">Import HTLMonadExtra.</span>
<span class="c">Export MonadNotation.</span>

<span class="c">Definition state_goto (st : reg) (n : node) : stmnt :=</span>
<span class="c">  Vnonblock (Vvar st) (Vlit (posToValue n)).</span>

<span class="c">Definition state_cond (st : reg) (c : expr) (n1 n2 : node) : stmnt :=</span>
<span class="c">  Vnonblock (Vvar st) (Vternary c (posToExpr n1) (posToExpr n2)).</span>

<span class="c">Definition check_empty_node_datapath:</span>
<span class="c">  forall (s: state) (n: node), { s.(st_datapath)!n = None } + { True }.</span>
<span class="c">Proof.</span>
<span class="c">  intros. case (s.(st_datapath)!n); tauto.</span>
<span class="c">Defined.</span>

<span class="c">Definition check_empty_node_controllogic:</span>
<span class="c">  forall (s: state) (n: node), { s.(st_controllogic)!n = None } + { True }.</span>
<span class="c">Proof.</span>
<span class="c">  intros. case (s.(st_controllogic)!n); tauto.</span>
<span class="c">Defined.</span>

<span class="c">Lemma add_instr_state_incr :</span>
<span class="c">  forall s n n&#39; st,</span>
<span class="c">    (st_datapath s)!n = None -&gt;</span>
<span class="c">    (st_controllogic s)!n = None -&gt;</span>
<span class="c">    st_incr s</span>
<span class="c">    (mkstate</span>
<span class="c">       s.(st_st)</span>
<span class="c">       s.(st_freshreg)</span>
<span class="c">       (st_freshstate s)</span>
<span class="c">       s.(st_scldecls)</span>
<span class="c">       s.(st_arrdecls)</span>
<span class="c">       (AssocMap.set n st s.(st_datapath))</span>
<span class="c">       (AssocMap.set n (state_goto s.(st_st) n&#39;) s.(st_controllogic))).</span>
<span class="c">Proof.</span>
<span class="c">  constructor; intros;</span>
<span class="c">    try (simpl; destruct (peq n n0); subst);</span>
<span class="c">    auto with htlh.</span>
<span class="c">Qed.</span>

<span class="c">Lemma declare_reg_state_incr :</span>
<span class="c">  forall i s r sz,</span>
<span class="c">    st_incr s</span>
<span class="c">    (mkstate</span>
<span class="c">       s.(st_st)</span>
<span class="c">       s.(st_freshreg)</span>
<span class="c">       s.(st_freshstate)</span>
<span class="c">       (AssocMap.set r (i, VScalar sz) s.(st_scldecls))</span>
<span class="c">       s.(st_arrdecls)</span>
<span class="c">       s.(st_datapath)</span>
<span class="c">       s.(st_controllogic)).</span>
<span class="c">Proof. auto with htlh. Qed.</span>

<span class="c">Definition declare_reg (i : option io) (r : reg) (sz : nat) : mon unit :=</span>
<span class="c">  fun s =&gt; OK tt (mkstate</span>
<span class="c">                s.(st_st)</span>
<span class="c">                s.(st_freshreg)</span>
<span class="c">                s.(st_freshstate)</span>
<span class="c">                (AssocMap.set r (i, VScalar sz) s.(st_scldecls))</span>
<span class="c">                s.(st_arrdecls)</span>
<span class="c">                s.(st_datapath)</span>
<span class="c">                s.(st_controllogic))</span>
<span class="c">              (declare_reg_state_incr i s r sz).</span>

<span class="c">Definition add_instr (n : node) (n&#39; : node) (st : stmnt) : mon unit :=</span>
<span class="c">  fun s =&gt;</span>
<span class="c">    match check_empty_node_datapath s n, check_empty_node_controllogic s n with</span>
<span class="c">    | left STM, left TRANS =&gt;</span>
<span class="c">      OK tt (mkstate</span>
<span class="c">               s.(st_st)</span>
<span class="c">               s.(st_freshreg)</span>
<span class="c">               (st_freshstate s)</span>
<span class="c">               s.(st_scldecls)</span>
<span class="c">               s.(st_arrdecls)</span>
<span class="c">               (AssocMap.set n st s.(st_datapath))</span>
<span class="c">               (AssocMap.set n (state_goto s.(st_st) n&#39;) s.(st_controllogic)))</span>
<span class="c">         (add_instr_state_incr s n n&#39; st STM TRANS)</span>
<span class="c">    | _, _ =&gt; Error (Errors.msg &quot;HTL.add_instr&quot;)</span>
<span class="c">    end.</span>

<span class="c">Lemma add_instr_skip_state_incr :</span>
<span class="c">  forall s n st,</span>
<span class="c">    (st_datapath s)!n = None -&gt;</span>
<span class="c">    (st_controllogic s)!n = None -&gt;</span>
<span class="c">    st_incr s</span>
<span class="c">    (mkstate</span>
<span class="c">       s.(st_st)</span>
<span class="c">       s.(st_freshreg)</span>
<span class="c">       (st_freshstate s)</span>
<span class="c">       s.(st_scldecls)</span>
<span class="c">       s.(st_arrdecls)</span>
<span class="c">       (AssocMap.set n st s.(st_datapath))</span>
<span class="c">       (AssocMap.set n Vskip s.(st_controllogic))).</span>
<span class="c">Proof.</span>
<span class="c">  constructor; intros;</span>
<span class="c">    try (simpl; destruct (peq n n0); subst);</span>
<span class="c">    auto with htlh.</span>
<span class="c">Qed.</span>

<span class="c">Definition add_instr_skip (n : node) (st : stmnt) : mon unit :=</span>
<span class="c">  fun s =&gt;</span>
<span class="c">    match check_empty_node_datapath s n, check_empty_node_controllogic s n with</span>
<span class="c">    | left STM, left TRANS =&gt;</span>
<span class="c">      OK tt (mkstate</span>
<span class="c">               s.(st_st)</span>
<span class="c">               s.(st_freshreg)</span>
<span class="c">               (st_freshstate s)</span>
<span class="c">               s.(st_scldecls)</span>
<span class="c">               s.(st_arrdecls)</span>
<span class="c">               (AssocMap.set n st s.(st_datapath))</span>
<span class="c">               (AssocMap.set n Vskip s.(st_controllogic)))</span>
<span class="c">         (add_instr_skip_state_incr s n st STM TRANS)</span>
<span class="c">    | _, _ =&gt; Error (Errors.msg &quot;HTL.add_instr&quot;)</span>
<span class="c">    end.</span>

<span class="c">Lemma add_node_skip_state_incr :</span>
<span class="c">  forall s n st,</span>
<span class="c">    (st_datapath s)!n = None -&gt;</span>
<span class="c">    (st_controllogic s)!n = None -&gt;</span>
<span class="c">    st_incr s</span>
<span class="c">    (mkstate</span>
<span class="c">       s.(st_st)</span>
<span class="c">       s.(st_freshreg)</span>
<span class="c">       (st_freshstate s)</span>
<span class="c">       s.(st_scldecls)</span>
<span class="c">       s.(st_arrdecls)</span>
<span class="c">       (AssocMap.set n Vskip s.(st_datapath))</span>
<span class="c">       (AssocMap.set n st s.(st_controllogic))).</span>
<span class="c">Proof.</span>
<span class="c">  constructor; intros;</span>
<span class="c">    try (simpl; destruct (peq n n0); subst);</span>
<span class="c">    auto with htlh.</span>
<span class="c">Qed.</span>

<span class="c">Definition add_node_skip (n : node) (st : stmnt) : mon unit :=</span>
<span class="c">  fun s =&gt;</span>
<span class="c">    match check_empty_node_datapath s n, check_empty_node_controllogic s n with</span>
<span class="c">    | left STM, left TRANS =&gt;</span>
<span class="c">      OK tt (mkstate</span>
<span class="c">               s.(st_st)</span>
<span class="c">               s.(st_freshreg)</span>
<span class="c">               (st_freshstate s)</span>
<span class="c">               s.(st_scldecls)</span>
<span class="c">               s.(st_arrdecls)</span>
<span class="c">               (AssocMap.set n Vskip s.(st_datapath))</span>
<span class="c">               (AssocMap.set n st s.(st_controllogic)))</span>
<span class="c">         (add_node_skip_state_incr s n st STM TRANS)</span>
<span class="c">    | _, _ =&gt; Error (Errors.msg &quot;HTL.add_instr&quot;)</span>
<span class="c">    end.</span>

<span class="c">Definition nonblock (dst : reg) (e : expr) := Vnonblock (Vvar dst) e.</span>
<span class="c">Definition block (dst : reg) (e : expr) := Vblock (Vvar dst) e.</span>

<span class="c">Definition bop (op : binop) (r1 r2 : reg) : expr :=</span>
<span class="c">  Vbinop op (Vvar r1) (Vvar r2).</span>

<span class="c">Definition boplit (op : binop) (r : reg) (l : Integers.int) : expr :=</span>
<span class="c">  Vbinop op (Vvar r) (Vlit (intToValue l)).</span>

<span class="c">Definition boplitz (op: binop) (r: reg) (l: Z) : expr :=</span>
<span class="c">  Vbinop op (Vvar r) (Vlit (ZToValue l)).</span>

<span class="c">Definition translate_comparison (c : Integers.comparison) (args : list reg) : mon expr :=</span>
<span class="c">  match c, args with</span>
<span class="c">  | Integers.Ceq, r1::r2::nil =&gt; ret (bop Veq r1 r2)</span>
<span class="c">  | Integers.Cne, r1::r2::nil =&gt; ret (bop Vne r1 r2)</span>
<span class="c">  | Integers.Clt, r1::r2::nil =&gt; ret (bop Vlt r1 r2)</span>
<span class="c">  | Integers.Cgt, r1::r2::nil =&gt; ret (bop Vgt r1 r2)</span>
<span class="c">  | Integers.Cle, r1::r2::nil =&gt; ret (bop Vle r1 r2)</span>
<span class="c">  | Integers.Cge, r1::r2::nil =&gt; ret (bop Vge r1 r2)</span>
<span class="c">  | _, _ =&gt; error (Errors.msg &quot;Htlgen: comparison instruction not implemented: other&quot;)</span>
<span class="c">  end.</span>

<span class="c">Definition translate_comparison_imm (c : Integers.comparison) (args : list reg) (i: Integers.int)</span>
<span class="c">  : mon expr :=</span>
<span class="c">  match c, args with</span>
<span class="c">  | Integers.Ceq, r1::nil =&gt; ret (boplit Veq r1 i)</span>
<span class="c">  | Integers.Cne, r1::nil =&gt; ret (boplit Vne r1 i)</span>
<span class="c">  | Integers.Clt, r1::nil =&gt; ret (boplit Vlt r1 i)</span>
<span class="c">  | Integers.Cgt, r1::nil =&gt; ret (boplit Vgt r1 i)</span>
<span class="c">  | Integers.Cle, r1::nil =&gt; ret (boplit Vle r1 i)</span>
<span class="c">  | Integers.Cge, r1::nil =&gt; ret (boplit Vge r1 i)</span>
<span class="c">  | _, _ =&gt; error (Errors.msg &quot;Htlgen: comparison_imm instruction not implemented: other&quot;)</span>
<span class="c">  end.</span>

<span class="c">Definition translate_comparisonu (c : Integers.comparison) (args : list reg) : mon expr :=</span>
<span class="c">  match c, args with</span>
<span class="c">  | Integers.Clt, r1::r2::nil =&gt; ret (bop Vltu r1 r2)</span>
<span class="c">  | Integers.Cgt, r1::r2::nil =&gt; ret (bop Vgtu r1 r2)</span>
<span class="c">  | Integers.Cle, r1::r2::nil =&gt; ret (bop Vleu r1 r2)</span>
<span class="c">  | Integers.Cge, r1::r2::nil =&gt; ret (bop Vgeu r1 r2)</span>
<span class="c">  | _, _ =&gt; error (Errors.msg &quot;Htlgen: comparison instruction not implemented: other&quot;)</span>
<span class="c">  end.</span>

<span class="c">Definition translate_comparison_immu (c : Integers.comparison) (args : list reg) (i: Integers.int)</span>
<span class="c">  : mon expr :=</span>
<span class="c">  match c, args with</span>
<span class="c">  | Integers.Clt, r1::nil =&gt; ret (boplit Vltu r1 i)</span>
<span class="c">  | Integers.Cgt, r1::nil =&gt; ret (boplit Vgtu r1 i)</span>
<span class="c">  | Integers.Cle, r1::nil =&gt; ret (boplit Vleu r1 i)</span>
<span class="c">  | Integers.Cge, r1::nil =&gt; ret (boplit Vgeu r1 i)</span>
<span class="c">  | _, _ =&gt; error (Errors.msg &quot;Htlgen: comparison_imm instruction not implemented: other&quot;)</span>
<span class="c">  end.</span>

<span class="c">Definition translate_condition (c : Op.condition) (args : list reg) : mon expr :=</span>
<span class="c">  match c, args with</span>
<span class="c">  | Op.Ccomp c, _ =&gt; translate_comparison c args</span>
<span class="c">  | Op.Ccompu c, _ =&gt; translate_comparisonu c args</span>
<span class="c">  | Op.Ccompimm c i, _ =&gt; translate_comparison_imm c args i</span>
<span class="c">  | Op.Ccompuimm c i, _ =&gt; translate_comparison_immu c args i</span>
<span class="c">  | Op.Cmaskzero n, _ =&gt; error (Errors.msg &quot;Htlgen: condition instruction not implemented: Cmaskzero&quot;)</span>
<span class="c">  | Op.Cmasknotzero n, _ =&gt; error (Errors.msg &quot;Htlgen: condition instruction not implemented: Cmasknotzero&quot;)</span>
<span class="c">  | _, _ =&gt; error (Errors.msg &quot;Htlgen: condition instruction not implemented: other&quot;)</span>
<span class="c">  end.</span>

<span class="c">Definition check_address_parameter_signed (p : Z) : bool :=</span>
<span class="c">  Z.leb Integers.Ptrofs.min_signed p</span>
<span class="c">  &amp;&amp; Z.leb p Integers.Ptrofs.max_signed.</span>

<span class="c">Definition check_address_parameter_unsigned (p : Z) : bool :=</span>
<span class="c">  Z.leb p Integers.Ptrofs.max_unsigned.</span>

<span class="c">Definition translate_eff_addressing (a: Op.addressing) (args: list reg) : mon expr :=</span>
<span class="c">  match a, args with (* TODO: We should be more methodical here; what are the possibilities?*)</span>
<span class="c">  | Op.Aindexed off, r1::nil =&gt;</span>
<span class="c">    if (check_address_parameter_signed off)</span>
<span class="c">    then ret (boplitz Vadd r1 off)</span>
<span class="c">    else error (Errors.msg &quot;Veriloggen: translate_eff_addressing (Aindexed): address out of bounds&quot;)</span>
<span class="c">  | Op.Ascaled scale offset, r1::nil =&gt;</span>
<span class="c">    if (check_address_parameter_signed scale) &amp;&amp; (check_address_parameter_signed offset)</span>
<span class="c">    then ret (Vbinop Vadd (boplitz Vmul r1 scale) (Vlit (ZToValue offset)))</span>
<span class="c">    else error (Errors.msg &quot;Veriloggen: translate_eff_addressing (Ascaled): address out of bounds&quot;)</span>
<span class="c">  | Op.Aindexed2 offset, r1::r2::nil =&gt;</span>
<span class="c">    if (check_address_parameter_signed offset)</span>
<span class="c">    then ret (Vbinop Vadd (bop Vadd r1 r2) (Vlit (ZToValue offset)))</span>
<span class="c">    else error (Errors.msg &quot;Veriloggen: translate_eff_addressing (Aindexed2): address out of bounds&quot;)</span>
<span class="c">  | Op.Aindexed2scaled scale offset, r1::r2::nil =&gt; (* Typical for dynamic array addressing *)</span>
<span class="c">    if (check_address_parameter_signed scale) &amp;&amp; (check_address_parameter_signed offset)</span>
<span class="c">    then ret (Vbinop Vadd (Vvar r1) (Vbinop Vadd (boplitz Vmul r2 scale) (Vlit (ZToValue offset))))</span>
<span class="c">    else error (Errors.msg &quot;Veriloggen: translate_eff_addressing (Aindexed2scaled): address out of bounds&quot;)</span>
<span class="c">  | Op.Ainstack a, nil =&gt; (* We need to be sure that the base address is aligned *)</span>
<span class="c">    let a := Integers.Ptrofs.unsigned a in</span>
<span class="c">    if (check_address_parameter_unsigned a)</span>
<span class="c">    then ret (Vlit (ZToValue a))</span>
<span class="c">    else error (Errors.msg &quot;Veriloggen: translate_eff_addressing (Ainstack): address out of bounds&quot;)</span>
<span class="c">  | _, _ =&gt; error (Errors.msg &quot;Veriloggen: translate_eff_addressing unsuported addressing&quot;)</span>
<span class="c">  end.</span>

<span class="c">(** Translate an instruction to a statement. FIX mulhs mulhu *)</span>
<span class="c">Definition translate_instr (op : Op.operation) (args : list reg) : mon expr :=</span>
<span class="c">  match op, args with</span>
<span class="c">  | Op.Omove, r::nil =&gt; ret (Vvar r)</span>
<span class="c">  | Op.Ointconst n, _ =&gt; ret (Vlit (intToValue n))</span>
<span class="c">  | Op.Oneg, r::nil =&gt; ret (Vunop Vneg (Vvar r))</span>
<span class="c">  | Op.Osub, r1::r2::nil =&gt; ret (bop Vsub r1 r2)</span>
<span class="c">  | Op.Omul, r1::r2::nil =&gt; ret (bop Vmul r1 r2)</span>
<span class="c">  | Op.Omulimm n, r::nil =&gt; ret (boplit Vmul r n)</span>
<span class="c">  | Op.Omulhs, r1::r2::nil =&gt; error (Errors.msg &quot;Htlgen: Instruction not implemented: mulhs&quot;)</span>
<span class="c">  | Op.Omulhu, r1::r2::nil =&gt; error (Errors.msg &quot;Htlgen: Instruction not implemented: mulhu&quot;)</span>
<span class="c">  | Op.Odiv, r1::r2::nil =&gt; ret (bop Vdiv r1 r2)</span>
<span class="c">  | Op.Odivu, r1::r2::nil =&gt; ret (bop Vdivu r1 r2)</span>
<span class="c">  | Op.Omod, r1::r2::nil =&gt; ret (bop Vmod r1 r2)</span>
<span class="c">  | Op.Omodu, r1::r2::nil =&gt; ret (bop Vmodu r1 r2)</span>
<span class="c">  | Op.Oand, r1::r2::nil =&gt; ret (bop Vand r1 r2)</span>
<span class="c">  | Op.Oandimm n, r::nil =&gt; ret (boplit Vand r n)</span>
<span class="c">  | Op.Oor, r1::r2::nil =&gt; ret (bop Vor r1 r2)</span>
<span class="c">  | Op.Oorimm n, r::nil =&gt; ret (boplit Vor r n)</span>
<span class="c">  | Op.Oxor, r1::r2::nil =&gt; ret (bop Vxor r1 r2)</span>
<span class="c">  | Op.Oxorimm n, r::nil =&gt; ret (boplit Vxor r n)</span>
<span class="c">  | Op.Onot, r::nil =&gt; ret (Vunop Vnot (Vvar r))</span>
<span class="c">  | Op.Oshl, r1::r2::nil =&gt; ret (bop Vshl r1 r2)</span>
<span class="c">  | Op.Oshlimm n, r::nil =&gt; ret (boplit Vshl r n)</span>
<span class="c">  | Op.Oshr, r1::r2::nil =&gt; ret (bop Vshr r1 r2)</span>
<span class="c">  | Op.Oshrimm n, r::nil =&gt; ret (boplit Vshr r n)</span>
<span class="c">  | Op.Oshrximm n, r::nil =&gt; error (Errors.msg &quot;Htlgen: Instruction not implemented: Oshrximm&quot;)</span>
<span class="c">  (*ret (Vbinop Vdiv (Vvar r)</span>
<span class="c">    (Vbinop Vshl (Vlit (ZToValue 1))</span>
<span class="c">    (Vlit (intToValue n))))*)</span>
<span class="c">  | Op.Oshru, r1::r2::nil =&gt; ret (bop Vshru r1 r2)</span>
<span class="c">  | Op.Oshruimm n, r::nil =&gt; ret (boplit Vshru r n)</span>
<span class="c">  | Op.Ororimm n, r::nil =&gt; error (Errors.msg &quot;Htlgen: Instruction not implemented: Ororimm&quot;)</span>
<span class="c">  (*ret (Vbinop Vor (boplit Vshru r (Integers.Int.modu n (Integers.Int.repr 32)))</span>
<span class="c">                                        (boplit Vshl r (Integers.Int.sub (Integers.Int.repr 32) (Integers.Int.modu n (Integers.Int.repr 32)))))*)</span>
<span class="c">  | Op.Oshldimm n, r::nil =&gt; ret (Vbinop Vor (boplit Vshl r n) (boplit Vshr r (Integers.Int.sub (Integers.Int.repr 32) n)))</span>
<span class="c">  | Op.Ocmp c, _ =&gt; translate_condition c args</span>
<span class="c">  | Op.Osel c AST.Tint, r1::r2::rl =&gt;</span>
<span class="c">    do tc &lt;- translate_condition c rl;</span>
<span class="c">    ret (Vternary tc (Vvar r1) (Vvar r2))</span>
<span class="c">  | Op.Olea a, _ =&gt; translate_eff_addressing a args</span>
<span class="c">  | _, _ =&gt; error (Errors.msg &quot;Htlgen: Instruction not implemented: other&quot;)</span>
<span class="c">  end.</span>

<span class="c">Lemma add_branch_instr_state_incr:</span>
<span class="c">  forall s e n n1 n2,</span>
<span class="c">    (st_datapath s) ! n = None -&gt;</span>
<span class="c">    (st_controllogic s) ! n = None -&gt;</span>
<span class="c">    st_incr s (mkstate</span>
<span class="c">                 s.(st_st)</span>
<span class="c">                (st_freshreg s)</span>
<span class="c">                (st_freshstate s)</span>
<span class="c">                s.(st_scldecls)</span>
<span class="c">                s.(st_arrdecls)</span>
<span class="c">                (AssocMap.set n Vskip (st_datapath s))</span>
<span class="c">                (AssocMap.set n (state_cond s.(st_st) e n1 n2) (st_controllogic s))).</span>
<span class="c">Proof.</span>
<span class="c">  intros. apply state_incr_intro; simpl;</span>
<span class="c">            try (intros; destruct (peq n0 n); subst);</span>
<span class="c">            auto with htlh.</span>
<span class="c">Qed.</span>

<span class="c">Definition add_branch_instr (e: expr) (n n1 n2: node) : mon unit :=</span>
<span class="c">  fun s =&gt;</span>
<span class="c">    match check_empty_node_datapath s n, check_empty_node_controllogic s n with</span>
<span class="c">    | left NSTM, left NTRANS =&gt;</span>
<span class="c">      OK tt (mkstate</span>
<span class="c">               s.(st_st)</span>
<span class="c">                (st_freshreg s)</span>
<span class="c">                (st_freshstate s)</span>
<span class="c">                s.(st_scldecls)</span>
<span class="c">                s.(st_arrdecls)</span>
<span class="c">                (AssocMap.set n Vskip (st_datapath s))</span>
<span class="c">                (AssocMap.set n (state_cond s.(st_st) e n1 n2) (st_controllogic s)))</span>
<span class="c">         (add_branch_instr_state_incr s e n n1 n2 NSTM NTRANS)</span>
<span class="c">    | _, _ =&gt; Error (Errors.msg &quot;Htlgen: add_branch_instr&quot;)</span>
<span class="c">    end.</span>

<span class="c">Definition translate_arr_access (mem : AST.memory_chunk) (addr : Op.addressing)</span>
<span class="c">           (args : list reg) (stack : reg) : mon expr :=</span>
<span class="c">  match mem, addr, args with (* TODO: We should be more methodical here; what are the possibilities?*)</span>
<span class="c">  | Mint32, Op.Aindexed off, r1::nil =&gt;</span>
<span class="c">    if (check_address_parameter_signed off)</span>
<span class="c">    then ret (Vvari stack (Vbinop Vdivu (boplitz Vadd r1 off) (Vlit (ZToValue 4))))</span>
<span class="c">    else error (Errors.msg &quot;HTLgen: translate_arr_access address out of bounds&quot;)</span>
<span class="c">  | Mint32, Op.Aindexed2scaled scale offset, r1::r2::nil =&gt; (* Typical for dynamic array addressing *)</span>
<span class="c">    if (check_address_parameter_signed scale) &amp;&amp; (check_address_parameter_signed offset)</span>
<span class="c">    then ret (Vvari stack</span>
<span class="c">                    (Vbinop Vdivu</span>
<span class="c">                            (Vbinop Vadd (boplitz Vadd r1 offset) (boplitz Vmul r2 scale))</span>
<span class="c">                            (Vlit (ZToValue 4))))</span>
<span class="c">    else error (Errors.msg &quot;HTLgen: translate_arr_access address out of bounds&quot;)</span>
<span class="c">  | Mint32, Op.Ainstack a, nil =&gt; (* We need to be sure that the base address is aligned *)</span>
<span class="c">    let a := Integers.Ptrofs.unsigned a in</span>
<span class="c">    if (check_address_parameter_unsigned a)</span>
<span class="c">    then ret (Vvari stack (Vlit (ZToValue (a / 4))))</span>
<span class="c">    else error (Errors.msg &quot;HTLgen: eff_addressing out of bounds stack offset&quot;)</span>
<span class="c">  | _, _, _ =&gt; error (Errors.msg &quot;HTLgen: translate_arr_access unsuported addressing&quot;)</span>
<span class="c">  end.</span>

<span class="c">Fixpoint enumerate (i : nat) (ns : list node) {struct ns} : list (nat * node) :=</span>
<span class="c">  match ns with</span>
<span class="c">  | n :: ns&#39; =&gt; (i, n) :: enumerate (i+1) ns&#39;</span>
<span class="c">  | nil =&gt; nil</span>
<span class="c">  end.</span>

<span class="c">Definition tbl_to_case_expr (st : reg) (ns : list node) : list (expr * stmnt) :=</span>
<span class="c">  List.map (fun a =&gt; match a with</span>
<span class="c">                    (i, n) =&gt; (Vlit (natToValue i), Vnonblock (Vvar st) (Vlit (posToValue n)))</span>
<span class="c">                  end)</span>
<span class="c">           (enumerate 0 ns).</span>

<span class="c">Definition transf_instr (fin rtrn stack: reg) (ni: node * instruction) : mon unit :=</span>
<span class="c">  match ni with</span>
<span class="c">    (n, i) =&gt;</span>
<span class="c">    match i with</span>
<span class="c">    | Inop n&#39; =&gt;</span>
<span class="c">      if Z.leb (Z.pos n&#39;) Integers.Int.max_unsigned then</span>
<span class="c">        add_instr n n&#39; Vskip</span>
<span class="c">      else error (Errors.msg &quot;State is larger than 2^32.&quot;)</span>
<span class="c">    | Iop op args dst n&#39; =&gt;</span>
<span class="c">      if Z.leb (Z.pos n&#39;) Integers.Int.max_unsigned then</span>
<span class="c">        do instr &lt;- translate_instr op args;</span>
<span class="c">        do _ &lt;- declare_reg None dst 32;</span>
<span class="c">        add_instr n n&#39; (nonblock dst instr)</span>
<span class="c">      else error (Errors.msg &quot;State is larger than 2^32.&quot;)</span>
<span class="c">    | Iload mem addr args dst n&#39; =&gt;</span>
<span class="c">      if Z.leb (Z.pos n&#39;) Integers.Int.max_unsigned then</span>
<span class="c">        do src &lt;- translate_arr_access mem addr args stack;</span>
<span class="c">        do _ &lt;- declare_reg None dst 32;</span>
<span class="c">        add_instr n n&#39; (nonblock dst src)</span>
<span class="c">      else error (Errors.msg &quot;State is larger than 2^32.&quot;)</span>
<span class="c">    | Istore mem addr args src n&#39; =&gt;</span>
<span class="c">      if Z.leb (Z.pos n&#39;) Integers.Int.max_unsigned then</span>
<span class="c">        do dst &lt;- translate_arr_access mem addr args stack;</span>
<span class="c">        add_instr n n&#39; (Vnonblock dst (Vvar src)) (* TODO: Could juse use add_instr? reg exists. *)</span>
<span class="c">      else error (Errors.msg &quot;State is larger than 2^32.&quot;)</span>
<span class="c">    | Icall _ _ _ _ _ =&gt; error (Errors.msg &quot;Calls are not implemented.&quot;)</span>
<span class="c">    | Itailcall _ _ _ =&gt; error (Errors.msg &quot;Tailcalls are not implemented.&quot;)</span>
<span class="c">    | Ibuiltin _ _ _ _ =&gt; error (Errors.msg &quot;Builtin functions not implemented.&quot;)</span>
<span class="c">    | Icond cond args n1 n2 =&gt;</span>
<span class="c">      if Z.leb (Z.pos n1) Integers.Int.max_unsigned &amp;&amp; Z.leb (Z.pos n2) Integers.Int.max_unsigned then</span>
<span class="c">        do e &lt;- translate_condition cond args;</span>
<span class="c">        add_branch_instr e n n1 n2</span>
<span class="c">      else error (Errors.msg &quot;State is larger than 2^32.&quot;)</span>
<span class="c">    | Ijumptable r tbl =&gt;</span>
<span class="c">      (*do s &lt;- get;</span>
<span class="c">      add_node_skip n (Vcase (Vvar r) (tbl_to_case_expr s.(st_st) tbl) (Some Vskip))*)</span>
<span class="c">      error (Errors.msg &quot;Ijumptable: Case statement not supported.&quot;)</span>
<span class="c">    | Ireturn r =&gt;</span>
<span class="c">      match r with</span>
<span class="c">      | Some r&#39; =&gt;</span>
<span class="c">        add_instr_skip n (Vseq (block fin (Vlit (ZToValue 1%Z))) (block rtrn (Vvar r&#39;)))</span>
<span class="c">      | None =&gt;</span>
<span class="c">        add_instr_skip n (Vseq (block fin (Vlit (ZToValue 1%Z))) (block rtrn (Vlit (ZToValue 0%Z))))</span>
<span class="c">      end</span>
<span class="c">    end</span>
<span class="c">  end.</span>

<span class="c">Lemma create_reg_state_incr:</span>
<span class="c">  forall s sz i,</span>
<span class="c">    st_incr s (mkstate</span>
<span class="c">         s.(st_st)</span>
<span class="c">         (Pos.succ (st_freshreg s))</span>
<span class="c">         (st_freshstate s)</span>
<span class="c">         (AssocMap.set s.(st_freshreg) (i, VScalar sz) s.(st_scldecls))</span>
<span class="c">         s.(st_arrdecls)</span>
<span class="c">         (st_datapath s)</span>
<span class="c">         (st_controllogic s)).</span>
<span class="c">Proof. constructor; simpl; auto with htlh. Qed.</span>

<span class="c">Definition create_reg (i : option io) (sz : nat) : mon reg :=</span>
<span class="c">  fun s =&gt; let r := s.(st_freshreg) in</span>
<span class="c">           OK r (mkstate</span>
<span class="c">                   s.(st_st)</span>
<span class="c">                   (Pos.succ r)</span>
<span class="c">                   (st_freshstate s)</span>
<span class="c">                   (AssocMap.set s.(st_freshreg) (i, VScalar sz) s.(st_scldecls))</span>
<span class="c">                   (st_arrdecls s)</span>
<span class="c">                   (st_datapath s)</span>
<span class="c">                   (st_controllogic s))</span>
<span class="c">              (create_reg_state_incr s sz i).</span>

<span class="c">Lemma create_arr_state_incr:</span>
<span class="c">  forall s sz ln i,</span>
<span class="c">    st_incr s (mkstate</span>
<span class="c">         s.(st_st)</span>
<span class="c">         (Pos.succ (st_freshreg s))</span>
<span class="c">         (st_freshstate s)</span>
<span class="c">         s.(st_scldecls)</span>
<span class="c">         (AssocMap.set s.(st_freshreg) (i, VArray sz ln) s.(st_arrdecls))</span>
<span class="c">         (st_datapath s)</span>
<span class="c">         (st_controllogic s)).</span>
<span class="c">Proof. constructor; simpl; auto with htlh. Qed.</span>

<span class="c">Definition create_arr (i : option io) (sz : nat) (ln : nat) : mon (reg * nat) :=</span>
<span class="c">  fun s =&gt; let r := s.(st_freshreg) in</span>
<span class="c">           OK (r, ln) (mkstate</span>
<span class="c">                   s.(st_st)</span>
<span class="c">                   (Pos.succ r)</span>
<span class="c">                   (st_freshstate s)</span>
<span class="c">                   s.(st_scldecls)</span>
<span class="c">                   (AssocMap.set s.(st_freshreg) (i, VArray sz ln) s.(st_arrdecls))</span>
<span class="c">                   (st_datapath s)</span>
<span class="c">                   (st_controllogic s))</span>
<span class="c">              (create_arr_state_incr s sz ln i).</span>

<span class="c">Definition stack_correct (sz : Z) : bool :=</span>
<span class="c">  (0 &lt;=? sz) &amp;&amp; (sz &lt;? Integers.Ptrofs.modulus) &amp;&amp; (Z.modulo sz 4 =? 0).</span>

<span class="c">Definition max_pc_map (m : Maps.PTree.t stmnt) :=</span>
<span class="c">  PTree.fold (fun m pc i =&gt; Pos.max m pc) m 1%positive.</span>

<span class="c">Lemma max_pc_map_sound:</span>
<span class="c">  forall m pc i, m!pc = Some i -&gt; Ple pc (max_pc_map m).</span>
<span class="c">Proof.</span>
<span class="c">  intros until i. unfold max_pc_function.</span>
<span class="c">  apply PTree_Properties.fold_rec with (P := fun c m =&gt; c!pc = Some i -&gt; Ple pc m).</span>
<span class="c">  (* extensionality *)</span>
<span class="c">  intros. apply H0. rewrite H; auto.</span>
<span class="c">  (* base case *)</span>
<span class="c">  rewrite PTree.gempty. congruence.</span>
<span class="c">  (* inductive case *)</span>
<span class="c">  intros. rewrite PTree.gsspec in H2. destruct (peq pc k).</span>
<span class="c">  inv H2. xomega.</span>
<span class="c">  apply Ple_trans with a. auto. xomega.</span>
<span class="c">Qed.</span>

<span class="c">Lemma max_pc_wf :</span>
<span class="c">  forall m, Z.pos (max_pc_map m) &lt;= Integers.Int.max_unsigned -&gt;</span>
<span class="c">            map_well_formed m.</span>
<span class="c">Proof.</span>
<span class="c">  unfold map_well_formed. intros.</span>
<span class="c">  exploit list_in_map_inv. eassumption. intros [x [A B]]. destruct x.</span>
<span class="c">  apply Maps.PTree.elements_complete in B. apply max_pc_map_sound in B.</span>
<span class="c">  unfold Ple in B. apply Pos2Z.pos_le_pos in B. subst.</span>
<span class="c">  simplify. transitivity (Z.pos (max_pc_map m)); eauto.</span>
<span class="c">Qed.</span>

<span class="c">Definition transf_module (f: function) : mon module :=</span>
<span class="c">  if stack_correct f.(fn_stacksize) then</span>
<span class="c">    do fin &lt;- create_reg (Some Voutput) 1;</span>
<span class="c">    do rtrn &lt;- create_reg (Some Voutput) 32;</span>
<span class="c">    do (stack, stack_len) &lt;- create_arr None 32 (Z.to_nat (f.(fn_stacksize) / 4));</span>
<span class="c">    do _ &lt;- collectlist (transf_instr fin rtrn stack) (Maps.PTree.elements f.(RTL.fn_code));</span>
<span class="c">    do _ &lt;- collectlist (fun r =&gt; declare_reg (Some Vinput) r 32) f.(RTL.fn_params);</span>
<span class="c">    do start &lt;- create_reg (Some Vinput) 1;</span>
<span class="c">    do rst &lt;- create_reg (Some Vinput) 1;</span>
<span class="c">    do clk &lt;- create_reg (Some Vinput) 1;</span>
<span class="c">    do current_state &lt;- get;</span>
<span class="c">    match zle (Z.pos (max_pc_map current_state.(st_datapath))) Integers.Int.max_unsigned,</span>
<span class="c">          zle (Z.pos (max_pc_map current_state.(st_controllogic))) Integers.Int.max_unsigned with</span>
<span class="c">    | left LEDATA, left LECTRL =&gt;</span>
<span class="c">        ret (mkmodule</span>
<span class="c">           f.(RTL.fn_params)</span>
<span class="c">           current_state.(st_datapath)</span>
<span class="c">           current_state.(st_controllogic)</span>
<span class="c">           f.(fn_entrypoint)</span>
<span class="c">           current_state.(st_st)</span>
<span class="c">           stack</span>
<span class="c">           stack_len</span>
<span class="c">           fin</span>
<span class="c">           rtrn</span>
<span class="c">           start</span>
<span class="c">           rst</span>
<span class="c">           clk</span>
<span class="c">           current_state.(st_scldecls)</span>
<span class="c">           current_state.(st_arrdecls)</span>
<span class="c">           (conj (max_pc_wf _ LECTRL) (max_pc_wf _ LEDATA)))</span>
<span class="c">    | _, _ =&gt; error (Errors.msg &quot;More than 2^32 states.&quot;)</span>
<span class="c">    end</span>
<span class="c">  else error (Errors.msg &quot;Stack size misalignment.&quot;).</span>

<span class="c">Definition max_state (f: function) : state :=</span>
<span class="c">  let st := Pos.succ (max_reg_function f) in</span>
<span class="c">  mkstate st</span>
<span class="c">          (Pos.succ st)</span>
<span class="c">          (Pos.succ (max_pc_function f))</span>
<span class="c">          (AssocMap.set st (None, VScalar 32) (st_scldecls (init_state st)))</span>
<span class="c">          (st_arrdecls (init_state st))</span>
<span class="c">          (st_datapath (init_state st))</span>
<span class="c">          (st_controllogic (init_state st)).</span>

<span class="c">Definition transl_module (f : function) : Errors.res module :=</span>
<span class="c">  run_mon (max_state f) (transf_module f).</span>

<span class="c">Definition transl_fundef := transf_partial_fundef transl_module.</span>

<span class="c">(* Definition transl_program (p : RTL.program) := transform_partial_program transl_fundef p. *)</span>

<span class="c">(*Definition transl_main_fundef f : Errors.res HTL.fundef :=</span>
<span class="c">  match f with</span>
<span class="c">  | Internal f =&gt; transl_fundef (Internal f)</span>
<span class="c">  | External f =&gt; Errors.Error (Errors.msg &quot;Could not find internal main function&quot;)</span>
<span class="c">  end.</span>

<span class="c">(** Translation of a whole program. *)</span>

<span class="c">Definition transl_program (p: RTL.program) : Errors.res HTL.program :=</span>
<span class="c">  transform_partial_program2 (fun i f =&gt; if Pos.eqb p.(AST.prog_main) i</span>
<span class="c">                                         then transl_fundef f</span>
<span class="c">                                         else transl_main_fundef f)</span>
<span class="c">                             (fun i v =&gt; Errors.OK v) p.</span>
<span class="c">*)</span>

<span class="c">Definition main_is_internal (p : RTLBlock.program) : bool :=</span>
<span class="c">  let ge := Globalenvs.Genv.globalenv p in</span>
<span class="c">  match Globalenvs.Genv.find_symbol ge p.(AST.prog_main) with</span>
<span class="c">  | Some b =&gt;</span>
<span class="c">    match Globalenvs.Genv.find_funct_ptr ge b with</span>
<span class="c">    | Some (AST.Internal _) =&gt; true</span>
<span class="c">    | _ =&gt; false</span>
<span class="c">    end</span>
<span class="c">  | _ =&gt; false</span>
<span class="c">  end.</span>

<span class="c">Definition transl_program (p : RTLBlock.program) : Errors.res HTL.program :=</span>
<span class="c">  if main_is_internal p</span>
<span class="c">  then transform_partial_program transl_fundef p</span>
<span class="c">  else Errors.Error (Errors.msg &quot;Main function is not Internal.&quot;).</span>
<span class="c">*)</span></span></span></pre>
</div>
</div></body>
</html>
