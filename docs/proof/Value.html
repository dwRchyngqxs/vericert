<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.16: http://docutils.sourceforge.net/" />
<title>Value.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
</head>
<body>
<div class="alectryon-root alectryon-floating"><div class="document">


<pre class="alectryon-io"><!-- Generator: Alectryon v1.0 --><span class="coq-wsp"><span class="highlight"><span class="c">(*(*</span>
<span class="c"> * Vericert: Verified high-level synthesis.</span>
<span class="c"> * Copyright (C) 2020 Yann Herklotz &lt;yann@yannherklotz.com&gt;</span>
<span class="c"> *</span>
<span class="c"> * This program is free software: you can redistribute it and/or modify</span>
<span class="c"> * it under the terms of the GNU General Public License as published by</span>
<span class="c"> * the Free Software Foundation, either version 3 of the License, or</span>
<span class="c"> * (at your option) any later version.</span>
<span class="c"> *</span>
<span class="c"> * This program is distributed in the hope that it will be useful,</span>
<span class="c"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c"> * GNU General Public License for more details.</span>
<span class="c"> *</span>
<span class="c"> * You should have received a copy of the GNU General Public License</span>
<span class="c"> * along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>
<span class="c"> *)</span>

<span class="c">(* begin hide *)</span>
<span class="c">From bbv Require Import Word.</span>
<span class="c">From bbv Require HexNotation WordScope.</span>
<span class="c">From Coq Require Import ZArith.ZArith FSets.FMapPositive Lia.</span>
<span class="c">From compcert Require Import lib.Integers common.Values.</span>
<span class="c">From vericert Require Import Vericertlib.</span>
<span class="c">(* end hide *)</span>

<span class="c">(** * Value</span>

<span class="c">A [value] is a bitvector with a specific size. We are using the implementation</span>
<span class="c">of the bitvector by mit-plv/bbv, because it has many theorems that we can reuse.</span>
<span class="c">However, we need to wrap it with an [Inductive] so that we can specify and match</span>
<span class="c">on the size of the [value]. This is necessary so that we can easily store</span>
<span class="c">[value]s of different sizes in a list or in a map.</span>

<span class="c">Using the default [word], this would not be possible, as the size is part of the type. *)</span>

<span class="c">Record value : Type :=</span>
<span class="c">  mkvalue {</span>
<span class="c">    vsize: nat;</span>
<span class="c">    vword: word vsize</span>
<span class="c">  }.</span>

<span class="c">(** ** Value conversions</span>

<span class="c">Various conversions to different number types such as [N], [Z], [positive] and</span>
<span class="c">[int], where the last one is a theory of integers of powers of 2 in CompCert. *)</span>

<span class="c">Definition wordToValue : forall sz : nat, word sz -&gt; value := mkvalue.</span>

<span class="c">Definition valueToWord : forall v : value, word (vsize v) := vword.</span>

<span class="c">Definition valueToNat (v :value) : nat :=</span>
<span class="c">  wordToNat (vword v).</span>

<span class="c">Definition natToValue sz (n : nat) : value :=</span>
<span class="c">  mkvalue sz (natToWord sz n).</span>

<span class="c">Definition valueToN (v : value) : N :=</span>
<span class="c">  wordToN (vword v).</span>

<span class="c">Definition NToValue sz (n : N) : value :=</span>
<span class="c">  mkvalue sz (NToWord sz n).</span>

<span class="c">Definition ZToValue (s : nat) (z : Z) : value :=</span>
<span class="c">  mkvalue s (ZToWord s z).</span>

<span class="c">Definition valueToZ (v : value) : Z :=</span>
<span class="c">  wordToZ (vword v).</span>

<span class="c">Definition uvalueToZ (v : value) : Z :=</span>
<span class="c">  uwordToZ (vword v).</span>

<span class="c">Definition posToValue sz (p : positive) : value :=</span>
<span class="c">  ZToValue sz (Zpos p).</span>

<span class="c">Definition posToValueAuto (p : positive) : value :=</span>
<span class="c">  let size := Pos.to_nat (Pos.size p) in</span>
<span class="c">  ZToValue size (Zpos p).</span>

<span class="c">Definition valueToPos (v : value) : positive :=</span>
<span class="c">  Z.to_pos (uvalueToZ v).</span>

<span class="c">Definition intToValue (i : Integers.int) : value :=</span>
<span class="c">  ZToValue Int.wordsize (Int.unsigned i).</span>

<span class="c">Definition valueToInt (i : value) : Integers.int :=</span>
<span class="c">  Int.repr (uvalueToZ i).</span>

<span class="c">Definition ptrToValue (i : Integers.ptrofs) : value :=</span>
<span class="c">  ZToValue Ptrofs.wordsize (Ptrofs.unsigned i).</span>

<span class="c">Definition valueToPtr (i : value) : Integers.ptrofs :=</span>
<span class="c">  Ptrofs.repr (uvalueToZ i).</span>

<span class="c">Definition valToValue (v : Values.val) : option value :=</span>
<span class="c">  match v with</span>
<span class="c">  | Values.Vint i =&gt; Some (intToValue i)</span>
<span class="c">  | Values.Vptr b off =&gt; if Z.eqb (Z.modulo (uvalueToZ (ptrToValue off)) 4) 0%Z</span>
<span class="c">                         then Some (ptrToValue off)</span>
<span class="c">                         else None</span>
<span class="c">  | Values.Vundef =&gt; Some (ZToValue 32 0%Z)</span>
<span class="c">  | _ =&gt; None</span>
<span class="c">  end.</span>

<span class="c">(** Convert a [value] to a [bool], so that choices can be made based on the</span>
<span class="c">result. This is also because comparison operators will give back [value] instead</span>
<span class="c">of [bool], so if they are in a condition, they will have to be converted before</span>
<span class="c">they can be used. *)</span>

<span class="c">Definition valueToBool (v : value) : bool :=</span>
<span class="c">  negb (weqb (@wzero (vsize v)) (vword v)).</span>

<span class="c">Definition boolToValue (sz : nat) (b : bool) : value :=</span>
<span class="c">  natToValue sz (if b then 1 else 0).</span>

<span class="c">(** ** Arithmetic operations *)</span>

<span class="c">Definition unify_word (sz1 sz2 : nat) (w1 : word sz2): sz1 = sz2 -&gt; word sz1.</span>
<span class="c">intros; subst; assumption. Defined.</span>

<span class="c">Lemma unify_word_unfold :</span>
<span class="c">  forall sz w,</span>
<span class="c">  unify_word sz sz w eq_refl = w.</span>
<span class="c">Proof. auto. Qed.</span>

<span class="c">Definition value_eq_size:</span>
<span class="c">  forall v1 v2 : value, { vsize v1 = vsize v2 } + { True }.</span>
<span class="c">Proof.</span>
<span class="c">  intros; destruct (Nat.eqb (vsize v1) (vsize v2)) eqn:?.</span>
<span class="c">  left; apply Nat.eqb_eq in Heqb; assumption.</span>
<span class="c">  right; trivial.</span>
<span class="c">Defined.</span>

<span class="c">Definition map_any {A : Type} (v1 v2 : value) (f : word (vsize v1) -&gt; word (vsize v1) -&gt; A)</span>
<span class="c">           (EQ : vsize v1 = vsize v2) : A :=</span>
<span class="c">    let w2 := unify_word (vsize v1) (vsize v2) (vword v2) EQ in</span>
<span class="c">    f (vword v1) w2.</span>

<span class="c">Definition map_any_opt {A : Type} (sz : nat) (v1 v2 : value) (f : word (vsize v1) -&gt; word (vsize v1) -&gt; A)</span>
<span class="c">  : option A :=</span>
<span class="c">  match value_eq_size v1 v2 with</span>
<span class="c">  | left EQ =&gt;</span>
<span class="c">    Some (map_any v1 v2 f EQ)</span>
<span class="c">  | _ =&gt; None</span>
<span class="c">  end.</span>

<span class="c">Definition map_word (f : forall sz : nat, word sz -&gt; word sz) (v : value) : value :=</span>
<span class="c">  mkvalue (vsize v) (f (vsize v) (vword v)).</span>

<span class="c">Definition map_word2 (f : forall sz : nat, word sz -&gt; word sz -&gt; word sz) (v1 v2 : value)</span>
<span class="c">           (EQ : (vsize v1 = vsize v2)) : value :=</span>
<span class="c">    let w2 := unify_word (vsize v1) (vsize v2) (vword v2) EQ in</span>
<span class="c">    mkvalue (vsize v1) (f (vsize v1) (vword v1) w2).</span>

<span class="c">Definition map_word2_opt (f : forall sz : nat, word sz -&gt; word sz -&gt; word sz) (v1 v2 : value)</span>
<span class="c">  : option value :=</span>
<span class="c">  match value_eq_size v1 v2 with</span>
<span class="c">  | left EQ =&gt; Some (map_word2 f v1 v2 EQ)</span>
<span class="c">  | _ =&gt; None</span>
<span class="c">  end.</span>

<span class="c">Definition eq_to_opt (v1 v2 : value) (f : vsize v1 = vsize v2 -&gt; value)</span>
<span class="c">  : option value :=</span>
<span class="c">  match value_eq_size v1 v2 with</span>
<span class="c">  | left EQ =&gt; Some (f EQ)</span>
<span class="c">  | _ =&gt; None</span>
<span class="c">  end.</span>

<span class="c">Lemma eqvalue {sz : nat} (x y : word sz) : x = y &lt;-&gt; mkvalue sz x = mkvalue sz y.</span>
<span class="c">Proof.</span>
<span class="c">  split; intros.</span>
<span class="c">  subst. reflexivity. inversion H. apply existT_wordToZ in H1.</span>
<span class="c">  apply wordToZ_inj. assumption.</span>
<span class="c">Qed.</span>

<span class="c">Lemma eqvaluef {sz : nat} (x y : word sz) : x = y -&gt; mkvalue sz x = mkvalue sz y.</span>
<span class="c">Proof. apply eqvalue. Qed.</span>

<span class="c">Lemma nevalue {sz : nat} (x y : word sz) : x &lt;&gt; y &lt;-&gt; mkvalue sz x &lt;&gt; mkvalue sz y.</span>
<span class="c">Proof. split; intros; intuition. apply H. apply eqvalue. assumption.</span>
<span class="c">       apply H. rewrite H0. trivial.</span>
<span class="c">Qed.</span>

<span class="c">Lemma nevaluef {sz : nat} (x y : word sz) : x &lt;&gt; y -&gt; mkvalue sz x &lt;&gt; mkvalue sz y.</span>
<span class="c">Proof. apply nevalue. Qed.</span>

<span class="c">(*Definition rewrite_word_size (initsz finalsz : nat) (w : word initsz)</span>
<span class="c">  : option (word finalsz) :=</span>
<span class="c">  match Nat.eqb initsz finalsz return option (word finalsz) with</span>
<span class="c">  | true =&gt; Some _</span>
<span class="c">  | false =&gt; None</span>
<span class="c">  end.*)</span>

<span class="c">Definition valueeq (sz : nat) (x y : word sz) :</span>
<span class="c">  {mkvalue sz x = mkvalue sz y} + {mkvalue sz x &lt;&gt; mkvalue sz y} :=</span>
<span class="c">  match weq x y with</span>
<span class="c">  | left eq =&gt; left (eqvaluef x y eq)</span>
<span class="c">  | right ne =&gt; right (nevaluef x y ne)</span>
<span class="c">  end.</span>

<span class="c">Definition valueeqb (x y : value) : bool :=</span>
<span class="c">  match value_eq_size x y with</span>
<span class="c">  | left EQ =&gt;</span>
<span class="c">    weqb (vword x) (unify_word (vsize x) (vsize y) (vword y) EQ)</span>
<span class="c">  | right _ =&gt; false</span>
<span class="c">  end.</span>

<span class="c">Definition value_projZ_eqb (v1 v2 : value) : bool := Z.eqb (valueToZ v1) (valueToZ v2).</span>

<span class="c">Theorem value_projZ_eqb_true :</span>
<span class="c">  forall v1 v2,</span>
<span class="c">  v1 = v2 -&gt; value_projZ_eqb v1 v2 = true.</span>
<span class="c">Proof. intros. subst. unfold value_projZ_eqb. apply Z.eqb_eq. trivial. Qed.</span>

<span class="c">Theorem valueeqb_true_iff :</span>
<span class="c">  forall v1 v2,</span>
<span class="c">  valueeqb v1 v2 = true &lt;-&gt; v1 = v2.</span>
<span class="c">Proof.</span>
<span class="c">  split; intros.</span>
<span class="c">  unfold valueeqb in H. destruct (value_eq_size v1 v2) eqn:?.</span>
<span class="c">  - destruct v1, v2. simpl in H.</span>
<span class="c">Abort.</span>

<span class="c">Definition value_int_eqb (v : value) (i : int) : bool :=</span>
<span class="c">  Z.eqb (valueToZ v) (Int.unsigned i).</span>

<span class="c">(** Arithmetic operations over [value], interpreting them as signed or unsigned</span>
<span class="c">depending on the operation.</span>

<span class="c">The arithmetic operations over [word] are over [N] by default, however, can also</span>
<span class="c">be called over [Z] explicitly, which is where the bits are interpreted in a</span>
<span class="c">signed manner. *)</span>

<span class="c">Definition vplus v1 v2 := map_word2 wplus v1 v2.</span>
<span class="c">Definition vplus_opt v1 v2 := map_word2_opt wplus v1 v2.</span>
<span class="c">Definition vminus v1 v2 := map_word2 wminus v1 v2.</span>
<span class="c">Definition vmul v1 v2 := map_word2 wmult v1 v2.</span>
<span class="c">Definition vdiv v1 v2 := map_word2 wdiv v1 v2.</span>
<span class="c">Definition vmod v1 v2 := map_word2 wmod v1 v2.</span>

<span class="c">Definition vmuls v1 v2 := map_word2 wmultZ v1 v2.</span>
<span class="c">Definition vdivs v1 v2 := map_word2 wdivZ v1 v2.</span>
<span class="c">Definition vmods v1 v2 := map_word2 wremZ v1 v2.</span>

<span class="c">(** ** Bitwise operations</span>

<span class="c">Bitwise operations over [value], which is independent of whether the number is</span>
<span class="c">signed or unsigned. *)</span>

<span class="c">Definition vnot v := map_word wnot v.</span>
<span class="c">Definition vneg v := map_word wneg v.</span>
<span class="c">Definition vbitneg v := boolToValue (vsize v) (negb (valueToBool v)).</span>
<span class="c">Definition vor v1 v2 := map_word2 wor v1 v2.</span>
<span class="c">Definition vand v1 v2 := map_word2 wand v1 v2.</span>
<span class="c">Definition vxor v1 v2 := map_word2 wxor v1 v2.</span>

<span class="c">(** ** Comparison operators</span>

<span class="c">Comparison operators that return a bool, there should probably be an equivalent</span>
<span class="c">which returns another number, however I might just add that as an explicit</span>
<span class="c">conversion. *)</span>

<span class="c">Definition veqb v1 v2 := map_any v1 v2 (@weqb (vsize v1)).</span>
<span class="c">Definition vneb v1 v2 EQ := negb (veqb v1 v2 EQ).</span>

<span class="c">Definition veq v1 v2 EQ := boolToValue (vsize v1) (veqb v1 v2 EQ).</span>
<span class="c">Definition vne v1 v2 EQ := boolToValue (vsize v1) (vneb v1 v2 EQ).</span>

<span class="c">Definition vltb v1 v2 := map_any v1 v2 wltb.</span>
<span class="c">Definition vleb v1 v2 EQ := negb (map_any v2 v1 wltb (eq_sym EQ)).</span>
<span class="c">Definition vgtb v1 v2 EQ := map_any v2 v1 wltb (eq_sym EQ).</span>
<span class="c">Definition vgeb v1 v2 EQ := negb (map_any v1 v2 wltb EQ).</span>

<span class="c">Definition vltsb v1 v2 := map_any v1 v2 wsltb.</span>
<span class="c">Definition vlesb v1 v2 EQ := negb (map_any v2 v1 wsltb (eq_sym EQ)).</span>
<span class="c">Definition vgtsb v1 v2 EQ := map_any v2 v1 wsltb (eq_sym EQ).</span>
<span class="c">Definition vgesb v1 v2 EQ := negb (map_any v1 v2 wsltb EQ).</span>

<span class="c">Definition vlt v1 v2 EQ := boolToValue (vsize v1) (vltb v1 v2 EQ).</span>
<span class="c">Definition vle v1 v2 EQ := boolToValue (vsize v1) (vleb v1 v2 EQ).</span>
<span class="c">Definition vgt v1 v2 EQ := boolToValue (vsize v1) (vgtb v1 v2 EQ).</span>
<span class="c">Definition vge v1 v2 EQ := boolToValue (vsize v1) (vgeb v1 v2 EQ).</span>

<span class="c">Definition vlts v1 v2 EQ := boolToValue (vsize v1) (vltsb v1 v2 EQ).</span>
<span class="c">Definition vles v1 v2 EQ := boolToValue (vsize v1) (vlesb v1 v2 EQ).</span>
<span class="c">Definition vgts v1 v2 EQ := boolToValue (vsize v1) (vgtsb v1 v2 EQ).</span>
<span class="c">Definition vges v1 v2 EQ := boolToValue (vsize v1) (vgesb v1 v2 EQ).</span>

<span class="c">(** ** Shift operators</span>

<span class="c">Shift operators on values. *)</span>

<span class="c">Definition shift_map (sz : nat) (f : word sz -&gt; nat -&gt; word sz) (w1 w2 : word sz) :=</span>
<span class="c">  f w1 (wordToNat w2).</span>

<span class="c">Definition vshl v1 v2 := map_word2 (fun sz =&gt; shift_map sz (@wlshift sz)) v1 v2.</span>
<span class="c">Definition vshr v1 v2 := map_word2 (fun sz =&gt; shift_map sz (@wrshift sz)) v1 v2.</span>

<span class="c">Module HexNotationValue.</span>
<span class="c">  Export HexNotation.</span>
<span class="c">  Import WordScope.</span>

<span class="c">  Notation &quot;sz &#39;&#39;h&#39; a&quot; := (NToValue sz (hex a)) (at level 50).</span>

<span class="c">End HexNotationValue.</span>

<span class="c">Inductive val_value_lessdef: val -&gt; value -&gt; Prop :=</span>
<span class="c">| val_value_lessdef_int:</span>
<span class="c">    forall i v&#39;,</span>
<span class="c">    i = valueToInt v&#39; -&gt;</span>
<span class="c">    val_value_lessdef (Vint i) v&#39;</span>
<span class="c">| val_value_lessdef_ptr:</span>
<span class="c">    forall b off v&#39;,</span>
<span class="c">    off = valueToPtr v&#39; -&gt;</span>
<span class="c">    (Z.modulo (uvalueToZ v&#39;) 4) = 0%Z -&gt;</span>
<span class="c">    val_value_lessdef (Vptr b off) v&#39;</span>
<span class="c">| lessdef_undef: forall v, val_value_lessdef Vundef v.</span>

<span class="c">Inductive opt_val_value_lessdef: option val -&gt; value -&gt; Prop :=</span>
<span class="c">| opt_lessdef_some:</span>
<span class="c">    forall v v&#39;, val_value_lessdef v v&#39; -&gt; opt_val_value_lessdef (Some v) v&#39;</span>
<span class="c">| opt_lessdef_none: forall v, opt_val_value_lessdef None v.</span>

<span class="c">Lemma valueToZ_ZToValue :</span>
<span class="c">  forall n z,</span>
<span class="c">  (- Z.of_nat (2 ^ n) &lt;= z &lt; Z.of_nat (2 ^ n))%Z -&gt;</span>
<span class="c">  valueToZ (ZToValue (S n) z) = z.</span>
<span class="c">Proof.</span>
<span class="c">  unfold valueToZ, ZToValue. simpl.</span>
<span class="c">  auto using wordToZ_ZToWord.</span>
<span class="c">Qed.</span>

<span class="c">Lemma uvalueToZ_ZToValue :</span>
<span class="c">  forall n z,</span>
<span class="c">  (0 &lt;= z &lt; 2 ^ Z.of_nat n)%Z -&gt;</span>
<span class="c">  uvalueToZ (ZToValue n z) = z.</span>
<span class="c">Proof.</span>
<span class="c">  unfold uvalueToZ, ZToValue. simpl.</span>
<span class="c">  auto using uwordToZ_ZToWord.</span>
<span class="c">Qed.</span>

<span class="c">Lemma uvalueToZ_ZToValue_full :</span>
<span class="c">  forall sz : nat,</span>
<span class="c">  (0 &lt; sz)%nat -&gt;</span>
<span class="c">  forall z : Z, uvalueToZ (ZToValue sz z) = (z mod 2 ^ Z.of_nat sz)%Z.</span>
<span class="c">Proof. unfold uvalueToZ, ZToValue. simpl. auto using uwordToZ_ZToWord_full. Qed.</span>

<span class="c">Lemma ZToValue_uvalueToZ :</span>
<span class="c">  forall v,</span>
<span class="c">  ZToValue (vsize v) (uvalueToZ v) = v.</span>
<span class="c">Proof.</span>
<span class="c">  intros.</span>
<span class="c">  unfold ZToValue, uvalueToZ.</span>
<span class="c">  rewrite ZToWord_uwordToZ. destruct v; auto.</span>
<span class="c">Qed.</span>

<span class="c">Lemma valueToPos_posToValueAuto :</span>
<span class="c">  forall p, valueToPos (posToValueAuto p) = p.</span>
<span class="c">Proof.</span>
<span class="c">  intros. unfold valueToPos, posToValueAuto.</span>
<span class="c">  rewrite uvalueToZ_ZToValue. auto. rewrite positive_nat_Z.</span>
<span class="c">  split. apply Zle_0_pos.</span>

<span class="c">  assert (p &lt; 2 ^ (Pos.size p))%positive by apply Pos.size_gt.</span>
<span class="c">  inversion H. rewrite &lt;- Z.compare_lt_iff. rewrite &lt;- H1.</span>
<span class="c">  simpl. rewrite &lt;- Pos2Z.inj_pow_pos. trivial.</span>
<span class="c">Qed.</span>

<span class="c">Lemma valueToPos_posToValue :</span>
<span class="c">  forall p, valueToPos (posToValueAuto p) = p.</span>
<span class="c">Proof.</span>
<span class="c">  intros. unfold valueToPos, posToValueAuto.</span>
<span class="c">  rewrite uvalueToZ_ZToValue. auto. rewrite positive_nat_Z.</span>
<span class="c">  split. apply Zle_0_pos.</span>

<span class="c">  assert (p &lt; 2 ^ (Pos.size p))%positive by apply Pos.size_gt.</span>
<span class="c">  inversion H. rewrite &lt;- Z.compare_lt_iff. rewrite &lt;- H1.</span>
<span class="c">  simpl. rewrite &lt;- Pos2Z.inj_pow_pos. trivial.</span>
<span class="c">Qed.</span>

<span class="c">Lemma valueToInt_intToValue :</span>
<span class="c">  forall v,</span>
<span class="c">  valueToInt (intToValue v) = v.</span>
<span class="c">Proof.</span>
<span class="c">  intros.</span>
<span class="c">  unfold valueToInt, intToValue. rewrite uvalueToZ_ZToValue. auto using Int.repr_unsigned.</span>
<span class="c">  split. apply Int.unsigned_range_2.</span>
<span class="c">  assert ((Int.unsigned v &lt;= Int.max_unsigned)%Z) by apply Int.unsigned_range_2.</span>
<span class="c">  apply Z.lt_le_pred in H. apply H.</span>
<span class="c">Qed.</span>

<span class="c">Lemma valueToPtr_ptrToValue :</span>
<span class="c">  forall v,</span>
<span class="c">  valueToPtr (ptrToValue v) = v.</span>
<span class="c">Proof.</span>
<span class="c">  intros.</span>
<span class="c">  unfold valueToPtr, ptrToValue. rewrite uvalueToZ_ZToValue. auto using Ptrofs.repr_unsigned.</span>
<span class="c">  split. apply Ptrofs.unsigned_range_2.</span>
<span class="c">  assert ((Ptrofs.unsigned v &lt;= Ptrofs.max_unsigned)%Z) by apply Ptrofs.unsigned_range_2.</span>
<span class="c">  apply Z.lt_le_pred in H. apply H.</span>
<span class="c">Qed.</span>

<span class="c">Lemma intToValue_valueToInt :</span>
<span class="c">  forall v,</span>
<span class="c">  vsize v = 32%nat -&gt;</span>
<span class="c">  intToValue (valueToInt v) = v.</span>
<span class="c">Proof.</span>
<span class="c">  intros. unfold valueToInt, intToValue. rewrite Int.unsigned_repr_eq.</span>
<span class="c">  unfold ZToValue, uvalueToZ. unfold Int.modulus. unfold Int.wordsize. unfold Wordsize_32.wordsize.</span>
<span class="c">  pose proof (uwordToZ_bound (vword v)).</span>
<span class="c">  rewrite Z.mod_small. rewrite &lt;- H. rewrite ZToWord_uwordToZ. destruct v; auto.</span>
<span class="c">  rewrite &lt;- H. rewrite two_power_nat_equiv. apply H0.</span>
<span class="c">Qed.</span>

<span class="c">Lemma ptrToValue_valueToPtr :</span>
<span class="c">  forall v,</span>
<span class="c">  vsize v = 32%nat -&gt;</span>
<span class="c">  ptrToValue (valueToPtr v) = v.</span>
<span class="c">Proof.</span>
<span class="c">  intros. unfold valueToPtr, ptrToValue. rewrite Ptrofs.unsigned_repr_eq.</span>
<span class="c">  unfold ZToValue, uvalueToZ. unfold Ptrofs.modulus. unfold Ptrofs.wordsize. unfold Wordsize_Ptrofs.wordsize.</span>
<span class="c">  pose proof (uwordToZ_bound (vword v)).</span>
<span class="c">  rewrite Z.mod_small. rewrite &lt;- H. rewrite ZToWord_uwordToZ. destruct v; auto.</span>
<span class="c">  rewrite &lt;- H. rewrite two_power_nat_equiv. apply H0.</span>
<span class="c">Qed.</span>

<span class="c">Lemma valToValue_lessdef :</span>
<span class="c">  forall v v&#39;,</span>
<span class="c">    valToValue v = Some v&#39; -&gt;</span>
<span class="c">    val_value_lessdef v v&#39;.</span>
<span class="c">Proof.</span>
<span class="c">  intros.</span>
<span class="c">  destruct v; try discriminate; constructor.</span>
<span class="c">  unfold valToValue in H. inversion H.</span>
<span class="c">  symmetry. apply valueToInt_intToValue.</span>
<span class="c">  inv H. destruct (uvalueToZ (ptrToValue i) mod 4 =? 0); try discriminate.</span>
<span class="c">  inv H1. symmetry. apply valueToPtr_ptrToValue.</span>
<span class="c">  inv H. destruct (uvalueToZ (ptrToValue i) mod 4 =? 0) eqn:?; try discriminate.</span>
<span class="c">  inv H1. apply Z.eqb_eq. apply Heqb0.</span>
<span class="c">Qed.</span>

<span class="c">Lemma boolToValue_ValueToBool :</span>
<span class="c">  forall b,</span>
<span class="c">  valueToBool (boolToValue 32 b) = b.</span>
<span class="c">Proof. destruct b; auto. Qed.</span>

<span class="c">Local Open Scope Z.</span>

<span class="c">Ltac word_op_value H :=</span>
<span class="c">  intros; unfold uvalueToZ, ZToValue; simpl; rewrite unify_word_unfold;</span>
<span class="c">  rewrite &lt;- H; rewrite uwordToZ_ZToWord_full; auto; omega.</span>

<span class="c">Lemma zadd_vplus :</span>
<span class="c">  forall sz z1 z2,</span>
<span class="c">  (sz &gt; 0)%nat -&gt;</span>
<span class="c">  uvalueToZ (vplus (ZToValue sz z1) (ZToValue sz z2) eq_refl) = (z1 + z2) mod 2 ^ Z.of_nat sz.</span>
<span class="c">Proof. word_op_value ZToWord_plus. Qed.</span>

<span class="c">Lemma zadd_vplus2 :</span>
<span class="c">  forall z1 z2,</span>
<span class="c">  vplus (ZToValue 32 z1) (ZToValue 32 z2) eq_refl = ZToValue 32 (z1 + z2).</span>
<span class="c">Proof.</span>
<span class="c">  intros. unfold vplus, ZToValue, map_word2. rewrite unify_word_unfold. simpl.</span>
<span class="c">  rewrite ZToWord_plus; auto.</span>
<span class="c">Qed.</span>

<span class="c">Lemma ZToValue_eq :</span>
<span class="c">  forall w1,</span>
<span class="c">  (mkvalue 32 w1) = (ZToValue 32 (wordToZ w1)). Abort.</span>

<span class="c">Lemma wordsize_32 :</span>
<span class="c">  Int.wordsize = 32%nat.</span>
<span class="c">Proof. auto. Qed.</span>

<span class="c">Lemma intadd_vplus :</span>
<span class="c">  forall i1 i2,</span>
<span class="c">  valueToInt (vplus (intToValue i1) (intToValue i2) eq_refl) = Int.add i1 i2.</span>
<span class="c">Proof.</span>
<span class="c">  intros. unfold Int.add, valueToInt, intToValue. rewrite zadd_vplus.</span>
<span class="c">  rewrite &lt;- Int.unsigned_repr_eq.</span>
<span class="c">  rewrite Int.repr_unsigned. auto. rewrite wordsize_32. omega.</span>
<span class="c">Qed.</span>

<span class="c">(*Lemma intadd_vplus2 :</span>
<span class="c">  forall v1 v2 EQ,</span>
<span class="c">  vsize v1 = 32%nat -&gt;</span>
<span class="c">  Int.add (valueToInt v1) (valueToInt v2) = valueToInt (vplus v1 v2 EQ).</span>
<span class="c">Proof.</span>
<span class="c">  intros. unfold Int.add, valueToInt, intToValue. repeat (rewrite Int.unsigned_repr).</span>
<span class="c">  rewrite (@vadd_vplus v1 v2 EQ). trivial.</span>
<span class="c">  unfold uvalueToZ. pose proof (@uwordToZ_bound (vsize v2) (vword v2)).</span>
<span class="c">  rewrite H in EQ. rewrite &lt;- EQ in H0 at 3.*)</span>
<span class="c">  (*rewrite zadd_vplus3. trivia*)</span>

<span class="c">Lemma valadd_vplus :</span>
<span class="c">  forall v1 v2 v1&#39; v2&#39; v v&#39; EQ,</span>
<span class="c">  val_value_lessdef v1 v1&#39; -&gt;</span>
<span class="c">  val_value_lessdef v2 v2&#39; -&gt;</span>
<span class="c">  Val.add v1 v2 = v -&gt;</span>
<span class="c">  vplus v1&#39; v2&#39; EQ = v&#39; -&gt;</span>
<span class="c">  val_value_lessdef v v&#39;.</span>
<span class="c">Proof.</span>
<span class="c">  intros. inv H; inv H0; constructor; simplify.</span>
<span class="c">  Abort.</span>

<span class="c">Lemma zsub_vminus :</span>
<span class="c">  forall sz z1 z2,</span>
<span class="c">  (sz &gt; 0)%nat -&gt;</span>
<span class="c">  uvalueToZ (vminus (ZToValue sz z1) (ZToValue sz z2) eq_refl) = (z1 - z2) mod 2 ^ Z.of_nat sz.</span>
<span class="c">Proof. word_op_value ZToWord_minus. Qed.</span>

<span class="c">Lemma zmul_vmul :</span>
<span class="c">  forall sz z1 z2,</span>
<span class="c">  (sz &gt; 0)%nat -&gt;</span>
<span class="c">  uvalueToZ (vmul (ZToValue sz z1) (ZToValue sz z2) eq_refl) = (z1 * z2) mod 2 ^ Z.of_nat sz.</span>
<span class="c">Proof. word_op_value ZToWord_mult. Qed.</span>

<span class="c">Local Open Scope N.</span>
<span class="c">Lemma zdiv_vdiv :</span>
<span class="c">  forall n1 n2,</span>
<span class="c">  n1 &lt; 2 ^ 32 -&gt;</span>
<span class="c">  n2 &lt; 2 ^ 32 -&gt;</span>
<span class="c">  n1 / n2 &lt; 2 ^ 32 -&gt;</span>
<span class="c">  valueToN (vdiv (NToValue 32 n1) (NToValue 32 n2) eq_refl) = n1 / n2.</span>
<span class="c">Proof.</span>
<span class="c">  intros; unfold valueToN, NToValue; simpl; rewrite unify_word_unfold. unfold wdiv.</span>
<span class="c">  unfold wordBin. repeat (rewrite wordToN_NToWord_2); auto.</span>
<span class="c">Qed.</span>

<span class="c">Lemma ZToValue_valueToNat :</span>
<span class="c">  forall x sz,</span>
<span class="c">  (sz &gt; 0)%nat -&gt;</span>
<span class="c">  (0 &lt;= x &lt; 2^(Z.of_nat sz))%Z -&gt;</span>
<span class="c">  valueToNat (ZToValue sz x) = Z.to_nat x.</span>
<span class="c">Proof.</span>
<span class="c">  destruct x; intros; unfold ZToValue, valueToNat; crush.</span>
<span class="c">  - rewrite wzero&#39;_def. apply wordToNat_wzero.</span>
<span class="c">  - rewrite posToWord_nat. rewrite wordToNat_natToWord_2. trivial.</span>
<span class="c">    clear H1.</span>
<span class="c">    lazymatch goal with</span>
<span class="c">    | [ H : context[(_ &lt; ?x)%Z] |- _ ] =&gt; replace x with (Z.of_nat (Z.to_nat x)) in H</span>
<span class="c">    end.</span>
<span class="c">    2: { apply Z2Nat.id; apply Z.pow_nonneg; lia. }</span>

<span class="c">    rewrite Z2Nat.inj_pow in H2; crush.</span>
<span class="c">    replace (Pos.to_nat 2) with 2%nat in H2 by reflexivity.</span>
<span class="c">    rewrite Nat2Z.id in H2.</span>
<span class="c">    rewrite &lt;- positive_nat_Z in H2.</span>
<span class="c">    apply Nat2Z.inj_lt in H2.</span>
<span class="c">    assumption.</span>
<span class="c">Qed.</span>
<span class="c">*)</span></span></span></pre>
</div>
</div></body>
</html>
